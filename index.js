/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/client.ts":
/*!**************************!*\
  !*** ./src/js/client.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client)\n/* harmony export */ });\n/* harmony import */ var _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jagex2/config/Component */ \"./src/js/jagex2/config/Component.ts\");\n/* harmony import */ var _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jagex2/graphics/Draw3D */ \"./src/js/jagex2/graphics/Draw3D.ts\");\n/* harmony import */ var _jagex2_io_Jagfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jagex2/io/Jagfile */ \"./src/js/jagex2/io/Jagfile.ts\");\n/* harmony import */ var _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jagex2/io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jagex2/client/GameShell */ \"./src/js/jagex2/client/GameShell.ts\");\n/* harmony import */ var _vendor_midi_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vendor/midi.js */ \"./src/js/vendor/midi.js\");\n/* harmony import */ var _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./jagex2/datastruct/LinkList */ \"./src/js/jagex2/datastruct/LinkList.ts\");\n/* harmony import */ var _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./jagex2/dash3d/World3D */ \"./src/js/jagex2/dash3d/World3D.ts\");\n/* harmony import */ var _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./jagex2/dash3d/World */ \"./src/js/jagex2/dash3d/World.ts\");\n/* harmony import */ var _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./jagex2/dash3d/CollisionMap */ \"./src/js/jagex2/dash3d/CollisionMap.ts\");\n/* harmony import */ var _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./jagex2/dash3d/entity/PlayerEntity */ \"./src/js/jagex2/dash3d/entity/PlayerEntity.ts\");\n/* harmony import */ var _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./jagex2/util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n/* harmony import */ var _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./jagex2/graphics/Canvas */ \"./src/js/jagex2/graphics/Canvas.ts\");\n/* harmony import */ var _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./jagex2/graphics/Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./jagex2/config/ObjType */ \"./src/js/jagex2/config/ObjType.ts\");\n/* harmony import */ var _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./jagex2/graphics/Colors */ \"./src/js/jagex2/graphics/Colors.ts\");\n/* harmony import */ var _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./jagex2/graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./jagex2/config/SeqType */ \"./src/js/jagex2/config/SeqType.ts\");\n/* harmony import */ var _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./jagex2/datastruct/JString */ \"./src/js/jagex2/datastruct/JString.ts\");\n/* harmony import */ var _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./jagex2/config/IdkType */ \"./src/js/jagex2/config/IdkType.ts\");\n/* harmony import */ var _jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./jagex2/util/JsUtil */ \"./src/js/jagex2/util/JsUtil.ts\");\n/* harmony import */ var _vendor_bzip__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./vendor/bzip */ \"./src/js/vendor/bzip.ts\");\n/* harmony import */ var _jagex2_util_AudioUtil__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./jagex2/util/AudioUtil */ \"./src/js/jagex2/util/AudioUtil.js\");\n/* harmony import */ var _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./jagex2/config/LocType */ \"./src/js/jagex2/config/LocType.ts\");\n/* harmony import */ var _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./jagex2/config/NpcType */ \"./src/js/jagex2/config/NpcType.ts\");\n/* harmony import */ var _jagex2_config_FloType__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./jagex2/config/FloType */ \"./src/js/jagex2/config/FloType.ts\");\n/* harmony import */ var _jagex2_config_SpotAnimType__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./jagex2/config/SpotAnimType */ \"./src/js/jagex2/config/SpotAnimType.ts\");\n/* harmony import */ var _jagex2_config_VarpType__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./jagex2/config/VarpType */ \"./src/js/jagex2/config/VarpType.ts\");\n/* harmony import */ var _jagex2_graphics_AnimBase__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./jagex2/graphics/AnimBase */ \"./src/js/jagex2/graphics/AnimBase.ts\");\n/* harmony import */ var _jagex2_graphics_AnimFrame__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./jagex2/graphics/AnimFrame */ \"./src/js/jagex2/graphics/AnimFrame.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// noinspection JSSuspiciousNameCombination\nclass Client extends _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    static clientversion = 225;\n    static nodeId = 10;\n    static portOffset = 0;\n    static members = true;\n    static lowMemory = false;\n    static serverAddress = '';\n    static httpAddress = '';\n    static showDebug = false;\n    static chatEra = 2; // 0 - early beta, 1 - late beta, 2 - launch\n    static cameraEditor = false;\n    static githubRepository = 'https://raw.githubusercontent.com/2004scape/Server/main';\n    // original keys:\n    static exponent = 58778699976184461502525193738213253649000149147835990136706041084440742975821n;\n    static modulus = 7162900525229798032761816791230527296329313291232324290237849263501208207972894053929065636522363163621000728841182238772712427862772219676577293600221789n;\n    static cyclelogic1 = 0;\n    static cyclelogic2 = 0;\n    static cyclelogic3 = 0;\n    static cyclelogic4 = 0;\n    static cyclelogic5 = 0;\n    static cyclelogic6 = 0;\n    static oplogic1 = 0;\n    static oplogic2 = 0;\n    static oplogic3 = 0;\n    static oplogic4 = 0;\n    static oplogic5 = 0;\n    static oplogic6 = 0;\n    static oplogic7 = 0;\n    static oplogic8 = 0;\n    static oplogic9 = 0;\n    static setHighMemory = () => {\n        _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_7__[\"default\"].lowMemory = false;\n        _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lowMemory = false;\n        Client.lowMemory = false;\n        _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_8__[\"default\"].lowMemory = false;\n    };\n    static setLowMemory = () => {\n        _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_7__[\"default\"].lowMemory = true;\n        _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].lowMemory = true;\n        Client.lowMemory = true;\n        _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_8__[\"default\"].lowMemory = true;\n    };\n    MAX_PLAYER_COUNT = 2048;\n    LOCAL_PLAYER_INDEX = 2047;\n    alreadyStarted = false;\n    errorStarted = false;\n    errorLoading = false;\n    errorHost = false;\n    // important client stuff\n    db = null;\n    loopCycle = 0;\n    archiveChecksums = [];\n    stream = null;\n    in = _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_3__[\"default\"].alloc(1);\n    out = _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_3__[\"default\"].alloc(1);\n    loginout = _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_3__[\"default\"].alloc(1);\n    serverSeed = 0n;\n    idleNetCycles = 0;\n    idleTimeout = 0;\n    systemUpdateTimer = 0;\n    randomIn = null;\n    packetType = 0;\n    packetSize = 0;\n    lastPacketType0 = 0;\n    lastPacketType1 = 0;\n    lastPacketType2 = 0;\n    // archives\n    titleArchive = null;\n    // login screen properties\n    redrawTitleBackground = true;\n    titleScreenState = 0;\n    titleLoginField = 0;\n    imageTitle2 = null;\n    imageTitle3 = null;\n    imageTitle4 = null;\n    imageTitle0 = null;\n    imageTitle1 = null;\n    imageTitle5 = null;\n    imageTitle6 = null;\n    imageTitle7 = null;\n    imageTitle8 = null;\n    imageTitlebox = null;\n    imageTitlebutton = null;\n    loginMessage0 = '';\n    loginMessage1 = '';\n    username = '';\n    password = '';\n    // fonts\n    fontPlain11 = null;\n    fontPlain12 = null;\n    fontBold12 = null;\n    fontQuill8 = null;\n    // login screen pillar flames properties\n    imageRunes = [];\n    flameActive = false;\n    imageFlamesLeft = null;\n    imageFlamesRight = null;\n    flameBuffer1 = null;\n    flameBuffer0 = null;\n    flameBuffer3 = null;\n    flameBuffer2 = null;\n    flameGradient = null;\n    flameGradient0 = null;\n    flameGradient1 = null;\n    flameGradient2 = null;\n    flameLineOffset = new Int32Array(256);\n    flameCycle0 = 0;\n    flameGradientCycle0 = 0;\n    flameGradientCycle1 = 0;\n    flamesInterval = null;\n    // game world properties\n    areaSidebar = null;\n    areaMapback = null;\n    areaViewport = null;\n    areaChatback = null;\n    areaBackbase1 = null;\n    areaBackbase2 = null;\n    areaBackhmid1 = null;\n    areaBackleft1 = null;\n    areaBackleft2 = null;\n    areaBackright1 = null;\n    areaBackright2 = null;\n    areaBacktop1 = null;\n    areaBacktop2 = null;\n    areaBackvmid1 = null;\n    areaBackvmid2 = null;\n    areaBackvmid3 = null;\n    areaBackhmid2 = null;\n    areaChatbackOffsets = null;\n    areaSidebarOffsets = null;\n    areaViewportOffsets = null;\n    compassMaskLineOffsets = new Int32Array(33);\n    compassMaskLineLengths = new Int32Array(33);\n    minimapMaskLineOffsets = new Int32Array(151);\n    minimapMaskLineLengths = new Int32Array(151);\n    imageInvback = null;\n    imageChatback = null;\n    imageMapback = null;\n    imageBackbase1 = null;\n    imageBackbase2 = null;\n    imageBackhmid1 = null;\n    imageSideicons = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(13, null);\n    imageMinimap = null;\n    imageCompass = null;\n    imageMapscene = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(50, null);\n    imageMapfunction = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(50, null);\n    imageHitmarks = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(20, null);\n    imageHeadicons = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(20, null);\n    imageMapflag = null;\n    imageCrosses = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(8, null);\n    imageMapdot0 = null;\n    imageMapdot1 = null;\n    imageMapdot2 = null;\n    imageMapdot3 = null;\n    imageScrollbar0 = null;\n    imageScrollbar1 = null;\n    imageRedstone1 = null;\n    imageRedstone2 = null;\n    imageRedstone3 = null;\n    imageRedstone1h = null;\n    imageRedstone2h = null;\n    imageRedstone1v = null;\n    imageRedstone2v = null;\n    imageRedstone3v = null;\n    imageRedstone1hv = null;\n    imageRedstone2hv = null;\n    genderButtonImage0 = null;\n    genderButtonImage1 = null;\n    activeMapFunctions = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(1000, null);\n    redrawSidebar = false;\n    redrawChatback = false;\n    redrawSideicons = false;\n    redrawPrivacySettings = false;\n    viewportInterfaceId = -1;\n    dragCycles = 0;\n    crossMode = 0;\n    crossCycle = 0;\n    crossX = 0;\n    crossY = 0;\n    overrideChat = 0;\n    menuVisible = false;\n    menuArea = 0;\n    menuX = 0;\n    menuY = 0;\n    menuWidth = 0;\n    menuHeight = 0;\n    menuSize = 0;\n    menuOption = [];\n    sidebarInterfaceId = -1;\n    chatInterfaceId = -1;\n    chatInterface = new _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    chatScrollHeight = 78;\n    chatScrollOffset = 0;\n    ignoreCount = 0;\n    ignoreName37 = [];\n    hintType = 0;\n    hintNpc = 0;\n    hintOffsetX = 0;\n    hintOffsetZ = 0;\n    hintPlayer = 0;\n    hintTileX = 0;\n    hintTileZ = 0;\n    hintHeight = 0;\n    skillExperience = [];\n    skillLevel = [];\n    skillBaseLevel = [];\n    levelExperience = [];\n    modalMessage = null;\n    flashingTab = -1;\n    selectedTab = 3;\n    tabInterfaceId = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    publicChatSetting = 0;\n    privateChatSetting = 0;\n    tradeChatSetting = 0;\n    scrollGrabbed = false;\n    scrollInputPadding = 0;\n    showSocialInput = false;\n    socialMessage = '';\n    socialInput = '';\n    socialAction = 0;\n    chatbackInput = '';\n    chatbackInputOpen = false;\n    stickyChatInterfaceId = -1;\n    messageText = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(100, null);\n    messageSender = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(100, null);\n    messageType = new Int32Array(100);\n    messageIds = new Int32Array(100);\n    privateMessageCount = 0;\n    splitPrivateChat = 0;\n    chatEffects = 0;\n    chatTyped = '';\n    viewportHoveredInterfaceIndex = 0;\n    sidebarHoveredInterfaceIndex = 0;\n    chatHoveredInterfaceIndex = 0;\n    objDragInterfaceId = 0;\n    objDragSlot = 0;\n    objDragArea = 0;\n    objGrabX = 0;\n    objGrabY = 0;\n    objDragCycles = 0;\n    objGrabThreshold = false;\n    objSelected = 0;\n    objSelectedSlot = 0;\n    objSelectedInterface = 0;\n    objInterface = 0;\n    objSelectedName = null;\n    selectedArea = 0;\n    selectedItem = 0;\n    selectedInterface = 0;\n    selectedCycle = 0;\n    pressedContinueOption = false;\n    varps = [];\n    varCache = [];\n    spellSelected = 0;\n    activeSpellId = 0;\n    activeSpellFlags = 0;\n    spellCaption = null;\n    mouseButtonsOption = 0;\n    menuAction = new Int32Array(500);\n    menuParamA = new Int32Array(500);\n    menuParamB = new Int32Array(500);\n    menuParamC = new Int32Array(500);\n    hoveredSlotParentId = 0;\n    hoveredSlot = 0;\n    lastHoveredInterfaceId = 0;\n    reportAbuseInput = '';\n    reportAbuseMuteOption = false;\n    reportAbuseInterfaceID = -1;\n    lastAddress = 0;\n    daysSinceLastLogin = 0;\n    daysSinceRecoveriesChanged = 0;\n    unreadMessages = 0;\n    activeMapFunctionCount = 0;\n    activeMapFunctionX = new Int32Array(1000);\n    activeMapFunctionZ = new Int32Array(1000);\n    // scene\n    scene = null;\n    sceneState = 0;\n    sceneDelta = 0;\n    sceneCycle = 0;\n    flagSceneTileX = 0;\n    flagSceneTileZ = 0;\n    cutscene = false;\n    cameraOffsetCycle = 0;\n    cameraAnticheatOffsetX = 0;\n    cameraAnticheatOffsetZ = 0;\n    cameraAnticheatAngle = 0;\n    cameraOffsetXModifier = 2;\n    cameraOffsetZModifier = 2;\n    cameraOffsetYawModifier = 1;\n    cameraModifierCycle = new Int32Array(5);\n    cameraModifierEnabled = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(5, false);\n    cameraModifierJitter = new Int32Array(5);\n    cameraModifierWobbleScale = new Int32Array(5);\n    cameraModifierWobbleSpeed = new Int32Array(5);\n    cameraX = 0;\n    cameraY = 0;\n    cameraZ = 0;\n    cameraPitch = 0;\n    cameraYaw = 0;\n    cameraPitchClamp = 0;\n    minimapOffsetCycle = 0;\n    minimapAnticheatAngle = 0;\n    minimapZoom = 0;\n    minimapZoomModifier = 1;\n    minimapAngleModifier = 2;\n    minimapLevel = -1;\n    baseX = 0;\n    baseZ = 0;\n    sceneCenterZoneX = 0;\n    sceneCenterZoneZ = 0;\n    sceneBaseTileX = 0;\n    sceneBaseTileZ = 0;\n    sceneMapLandData = null;\n    sceneMapLocData = null;\n    sceneMapIndex = null;\n    mapLastBaseX = 0;\n    mapLastBaseZ = 0;\n    textureBuffer = new Int8Array(16384);\n    levelCollisionMap = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].LEVELS, null);\n    currentLevel = 0;\n    cameraMovedWrite = 0;\n    orbitCameraPitch = 128;\n    orbitCameraYaw = 0;\n    orbitCameraYawVelocity = 0;\n    orbitCameraPitchVelocity = 0;\n    orbitCameraX = 0;\n    orbitCameraZ = 0;\n    levelHeightmap = null;\n    levelTileFlags = null;\n    tileLastOccupiedCycle = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.Int32Array2d(_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE);\n    projectX = 0;\n    projectY = 0;\n    cutsceneDstLocalTileX = 0;\n    cutsceneDstLocalTileZ = 0;\n    cutsceneDstHeight = 0;\n    cutsceneRotateSpeed = 0;\n    cutsceneRotateAcceleration = 0;\n    cutsceneSrcLocalTileX = 0;\n    cutsceneSrcLocalTileZ = 0;\n    cutsceneSrcHeight = 0;\n    cutsceneMoveSpeed = 0;\n    cutsceneMoveAcceleration = 0;\n    // entities\n    players = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(this.MAX_PLAYER_COUNT, null);\n    playerCount = 0;\n    playerIds = new Int32Array(this.MAX_PLAYER_COUNT);\n    entityUpdateCount = 0;\n    entityRemovalCount = 0;\n    entityUpdateIds = new Int32Array(this.MAX_PLAYER_COUNT);\n    entityRemovalIds = new Int32Array(1000);\n    playerAppearanceBuffer = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(this.MAX_PLAYER_COUNT, null);\n    npcs = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(8192, null);\n    npcCount = 0;\n    npcIds = new Int32Array(8192);\n    projectiles = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    spotanims = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    locList = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    temporaryLocs = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    levelObjStacks = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray3d(_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].LEVELS, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE, null);\n    spawnedLocations = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    // bfs pathfinder\n    bfsStepX = new Int32Array(4000);\n    bfsStepZ = new Int32Array(4000);\n    bfsDirection = new Int32Array(_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE * _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE);\n    bfsCost = new Int32Array(_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE * _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SIZE);\n    tryMoveNearest = 0;\n    // player\n    localPlayer = null;\n    energy = 0;\n    inMultizone = 0;\n    localPid = -1;\n    weightCarried = 0;\n    heartbeatTimer = 0;\n    wildernessLevel = 0;\n    worldLocationState = 0;\n    rights = false;\n    designGenderMale = true;\n    updateDesignModel = false;\n    designIdentikits = new Int32Array(7);\n    designColors = new Int32Array(5);\n    // friends/chats\n    friendCount = 0;\n    chatCount = 0;\n    static MAX_CHATS = 50;\n    chatX = new Int32Array(Client.MAX_CHATS);\n    chatY = new Int32Array(Client.MAX_CHATS);\n    chatHeight = new Int32Array(Client.MAX_CHATS);\n    chatWidth = new Int32Array(Client.MAX_CHATS);\n    chatColors = new Int32Array(Client.MAX_CHATS);\n    chatStyles = new Int32Array(Client.MAX_CHATS);\n    chatTimers = new Int32Array(Client.MAX_CHATS);\n    chats = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(Client.MAX_CHATS, null);\n    friendName = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(100, null);\n    friendName37 = new BigInt64Array(100);\n    friendWorld = new Int32Array(100);\n    socialName37 = null;\n    // audio\n    waveCount = 0;\n    waveEnabled = true;\n    waveIds = new Int32Array(50);\n    waveLoops = new Int32Array(50);\n    waveDelay = new Int32Array(50);\n    waveVolume = 192;\n    lastWaveId = -1;\n    lastWaveLoops = -1;\n    lastWaveLength = 0;\n    lastWaveStartTime = 0;\n    nextMusicDelay = 0;\n    midiActive = true;\n    currentMidi = null;\n    midiCrc = 0;\n    midiSize = 0;\n    midiVolume = 192;\n    // debug\n    // alt+shift click to add a tile overlay\n    userTileMarkers = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(16, null);\n    userTileMarkerIndex = 0;\n    lastTickFlag = false;\n    // ---- override functions\n    unload = () => {\n        try {\n            if (this.stream) {\n                this.stream.close();\n            }\n        }\n        catch (e) {\n            /* empty */\n        }\n        this.stream = null;\n        (0,_jagex2_util_AudioUtil__WEBPACK_IMPORTED_MODULE_22__.stopMidi)();\n        // this.midiThreadActive = false;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.out = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.loginout = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.in = null;\n        this.sceneMapIndex = null;\n        this.sceneMapLandData = null;\n        this.sceneMapLocData = null;\n        this.levelHeightmap = null;\n        this.levelTileFlags = null;\n        this.scene = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.levelCollisionMap = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.bfsDirection = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.bfsCost = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.bfsStepX = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.bfsStepZ = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.textureBuffer = null;\n        this.areaSidebar = null;\n        this.areaMapback = null;\n        this.areaViewport = null;\n        this.areaChatback = null;\n        this.areaBackbase1 = null;\n        this.areaBackbase2 = null;\n        this.areaBackhmid1 = null;\n        this.areaBackleft1 = null;\n        this.areaBackleft2 = null;\n        this.areaBackright1 = null;\n        this.areaBackright2 = null;\n        this.areaBacktop1 = null;\n        this.areaBacktop2 = null;\n        this.areaBackvmid1 = null;\n        this.areaBackvmid2 = null;\n        this.areaBackvmid3 = null;\n        this.areaBackhmid2 = null;\n        this.imageInvback = null;\n        this.imageMapback = null;\n        this.imageChatback = null;\n        this.imageBackbase1 = null;\n        this.imageBackbase2 = null;\n        this.imageBackhmid1 = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.imageSideicons = null;\n        this.imageRedstone1 = null;\n        this.imageRedstone2 = null;\n        this.imageRedstone3 = null;\n        this.imageRedstone1h = null;\n        this.imageRedstone2h = null;\n        this.imageRedstone1v = null;\n        this.imageRedstone2v = null;\n        this.imageRedstone3v = null;\n        this.imageRedstone1hv = null;\n        this.imageRedstone2hv = null;\n        this.imageCompass = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.imageHitmarks = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.imageHeadicons = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.imageCrosses = null;\n        this.imageMapdot0 = null;\n        this.imageMapdot1 = null;\n        this.imageMapdot2 = null;\n        this.imageMapdot3 = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.imageMapscene = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.imageMapfunction = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.tileLastOccupiedCycle = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.players = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.playerIds = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.entityUpdateIds = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.playerAppearanceBuffer = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.entityRemovalIds = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.npcs = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.npcIds = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.levelObjStacks = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.spawnedLocations = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.temporaryLocs = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.projectiles = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.spotanims = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.locList = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.menuParamB = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.menuParamC = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.menuAction = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.menuParamA = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.menuOption = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.varps = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.activeMapFunctionX = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.activeMapFunctionZ = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.activeMapFunctions = null;\n        this.imageMinimap = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.friendName = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.friendName37 = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.friendWorld = null;\n        this.imageTitle0 = null;\n        this.imageTitle1 = null;\n        this.imageTitle2 = null;\n        this.imageTitle3 = null;\n        this.imageTitle4 = null;\n        this.imageTitle5 = null;\n        this.imageTitle6 = null;\n        this.imageTitle7 = null;\n        this.imageTitle8 = null;\n        this.unloadTitle();\n        _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_23__[\"default\"].unload();\n        _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_24__[\"default\"].unload();\n        _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_14__[\"default\"].unload();\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        _jagex2_config_FloType__WEBPACK_IMPORTED_MODULE_25__[\"default\"].instances = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_19__[\"default\"].instances = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_17__[\"default\"].instances = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        _jagex2_config_SpotAnimType__WEBPACK_IMPORTED_MODULE_26__[\"default\"].instances = null;\n        _jagex2_config_SpotAnimType__WEBPACK_IMPORTED_MODULE_26__[\"default\"].modelCache = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        _jagex2_config_VarpType__WEBPACK_IMPORTED_MODULE_27__[\"default\"].instances = null;\n        this.drawArea = null;\n        _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_10__[\"default\"].modelCache = null;\n        _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].unload();\n        _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_7__[\"default\"].unload();\n        _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_16__[\"default\"].unload();\n        _jagex2_graphics_AnimBase__WEBPACK_IMPORTED_MODULE_28__[\"default\"].instances = [];\n        _jagex2_graphics_AnimFrame__WEBPACK_IMPORTED_MODULE_29__[\"default\"].instances = [];\n    };\n    getTitleScreenState() {\n        return this.titleScreenState;\n    }\n    isChatBackInputOpen() {\n        return this.chatbackInputOpen;\n    }\n    isShowSocialInput() {\n        return this.showSocialInput;\n    }\n    getChatInterfaceId() {\n        return this.chatInterfaceId;\n    }\n    getViewportInterfaceId() {\n        return this.viewportInterfaceId;\n    }\n    // ---- protected functions can be used by impl classes\n    unloadTitle = () => {\n        this.flameActive = false;\n        if (this.flamesInterval) {\n            clearInterval(this.flamesInterval);\n            this.flamesInterval = null;\n        }\n        this.imageTitlebox = null;\n        this.imageTitlebutton = null;\n        this.imageRunes = [];\n        this.flameGradient = null;\n        this.flameGradient0 = null;\n        this.flameGradient1 = null;\n        this.flameGradient2 = null;\n        this.flameBuffer0 = null;\n        this.flameBuffer1 = null;\n        this.flameBuffer3 = null;\n        this.flameBuffer2 = null;\n        this.imageFlamesLeft = null;\n        this.imageFlamesRight = null;\n    };\n    loadArchive = async (filename, displayName, crc, progress) => {\n        let retry = 5;\n        let data = await this.db?.cacheload(filename);\n        // if (data && Packet.crc32(data) !== crc) {\n        //     data = undefined;\n        // }\n        if (data) {\n            return new _jagex2_io_Jagfile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](data);\n        }\n        while (!data) {\n            await this.showProgress(progress, `Requesting ${displayName}`);\n            try {\n                data = await (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_20__.downloadUrl)(`${Client.httpAddress}/${filename}${crc}`);\n            }\n            catch (e) {\n                data = undefined;\n                for (let i = retry; i > 0; i--) {\n                    await this.showProgress(progress, `Error loading - Will retry in ${i} secs.`);\n                    await (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_20__.sleep)(1000);\n                }\n                retry *= 2;\n                if (retry > 60) {\n                    retry = 60;\n                }\n            }\n        }\n        await this.db?.cachesave(filename, data);\n        return new _jagex2_io_Jagfile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](data);\n    };\n    setMidi = async (name, crc, length) => {\n        let data = await this.db?.cacheload(name + '.mid');\n        // if (data && crc !== 12345678 && Packet.crc32(data) !== crc) {\n        //     data = undefined;\n        // }\n        if (!data) {\n            try {\n                data = await (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_20__.downloadUrl)(`${Client.httpAddress}/${name}_${crc}.mid`);\n                if (length !== data.length) {\n                    data = data.slice(0, length);\n                }\n            }\n            catch (e) {\n                /* empty */\n            }\n        }\n        if (!data) {\n            return;\n        }\n        await this.db?.cachesave(name + '.mid', data);\n        const uncompressedLength = new _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_3__[\"default\"](Uint8Array.from(data)).g4;\n        const uncompressed = _vendor_bzip__WEBPACK_IMPORTED_MODULE_21__[\"default\"].read(uncompressedLength, data, length, 4);\n        (0,_jagex2_util_AudioUtil__WEBPACK_IMPORTED_MODULE_22__.playMidi)(uncompressed, this.midiVolume);\n    };\n    drawError = () => {\n        _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillStyle = 'black';\n        _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillRect(0, 0, this.width, this.height);\n        this.setFramerate(1);\n        if (this.errorLoading) {\n            this.flameActive = false;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.font = 'bold 16px helvetica, sans-serif';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.textAlign = 'left';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillStyle = 'yellow';\n            let y = 35;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('Sorry, an error has occured whilst loading RuneScape', 30, y);\n            y += 50;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillStyle = 'white';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('To fix this try the following (in order):', 30, y);\n            y += 50;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.font = 'bold 12px helvetica, sans-serif';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('1: Try closing ALL open web-browser windows, and reloading', 30, y);\n            y += 30;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('2: Try clearing your web-browsers cache from tools->internet options', 30, y);\n            y += 30;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('3: Try using a different game-world', 30, y);\n            y += 30;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('4: Try rebooting your computer', 30, y);\n            y += 30;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('5: Try selecting a different version of Java from the play-game menu', 30, y);\n        }\n        if (this.errorHost) {\n            this.flameActive = false;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.font = 'bold 20px helvetica, sans-serif';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.textAlign = 'left';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillStyle = 'white';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('Error - unable to load game!', 50, 50);\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('To play RuneScape make sure you play from', 50, 100);\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('https://2004scape.org', 50, 150);\n        }\n        if (this.errorStarted) {\n            this.flameActive = false;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.font = 'bold 13px helvetica, sans-serif';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.textAlign = 'left';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillStyle = 'yellow';\n            let y = 35;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('Error a copy of RuneScape already appears to be loaded', 30, y);\n            y += 50;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillStyle = 'white';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('To fix this try the following (in order):', 30, y);\n            y += 50;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.font = 'bold 12px helvetica, sans-serif';\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('1: Try closing ALL open web-browser windows, and reloading', 30, y);\n            y += 30;\n            _jagex2_graphics_Canvas__WEBPACK_IMPORTED_MODULE_12__.canvas2d.fillText('2: Try rebooting your computer, and reloading', 30, y);\n        }\n    };\n    executeInterfaceScript = (com) => {\n        if (!com.scriptComparator) {\n            return false;\n        }\n        for (let i = 0; i < com.scriptComparator.length; i++) {\n            const value = this.executeClientscript1(com, i);\n            if (!com.scriptOperand) {\n                return false;\n            }\n            const operand = com.scriptOperand[i];\n            if (com.scriptComparator[i] === 2) {\n                if (value >= operand) {\n                    return false;\n                }\n            }\n            else if (com.scriptComparator[i] === 3) {\n                if (value <= operand) {\n                    return false;\n                }\n            }\n            else if (com.scriptComparator[i] === 4) {\n                if (value === operand) {\n                    return false;\n                }\n            }\n            else if (value !== operand) {\n                return false;\n            }\n        }\n        return true;\n    };\n    drawScrollbar = (x, y, scrollY, scrollHeight, height) => {\n        this.imageScrollbar0?.draw(x, y);\n        this.imageScrollbar1?.draw(x, y + height - 16);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fillRect(x, y + 16, 16, height - 32, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_TRACK);\n        let gripSize = (((height - 32) * height) / scrollHeight) | 0;\n        if (gripSize < 8) {\n            gripSize = 8;\n        }\n        const gripY = (((height - gripSize - 32) * scrollY) / (scrollHeight - height)) | 0;\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fillRect(x, y + gripY + 16, 16, gripSize, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_FOREGROUND);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawVerticalLine(x, y + gripY + 16, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_HIGHLIGHT, gripSize);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawVerticalLine(x + 1, y + gripY + 16, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_HIGHLIGHT, gripSize);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawHorizontalLine(x, y + gripY + 16, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_HIGHLIGHT, 16);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawHorizontalLine(x, y + gripY + 17, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_HIGHLIGHT, 16);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawVerticalLine(x + 15, y + gripY + 16, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_LOWLIGHT, gripSize);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawVerticalLine(x + 14, y + gripY + 17, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_LOWLIGHT, gripSize - 1);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawHorizontalLine(x, y + gripY + gripSize + 15, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_LOWLIGHT, 16);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawHorizontalLine(x + 1, y + gripY + gripSize + 14, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].SCROLLBAR_GRIP_LOWLIGHT, 15);\n    };\n    updateInterfaceAnimation = (id, delta) => {\n        let updated = false;\n        const parent = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[id];\n        if (!parent.childId) {\n            return false;\n        }\n        for (let i = 0; i < parent.childId.length && parent.childId[i] !== -1; i++) {\n            const child = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[parent.childId[i]];\n            if (child.type === 1) {\n                updated ||= this.updateInterfaceAnimation(child.id, delta);\n            }\n            if (child.type === 6 && (child.anim !== -1 || child.activeAnim !== -1)) {\n                const active = this.executeInterfaceScript(child);\n                let seqId;\n                if (active) {\n                    seqId = child.activeAnim;\n                }\n                else {\n                    seqId = child.anim;\n                }\n                if (seqId !== -1) {\n                    const type = _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_17__[\"default\"].instances[seqId];\n                    child.seqCycle += delta;\n                    if (type.delay) {\n                        while (child.seqCycle > type.delay[child.seqFrame]) {\n                            child.seqCycle -= type.delay[child.seqFrame] + 1;\n                            child.seqFrame++;\n                            if (child.seqFrame >= type.frameCount) {\n                                child.seqFrame -= type.replayoff;\n                                if (child.seqFrame < 0 || child.seqFrame >= type.frameCount) {\n                                    child.seqFrame = 0;\n                                }\n                            }\n                            updated = true;\n                        }\n                    }\n                }\n            }\n        }\n        return updated;\n    };\n    drawInterface = (com, x, y, scrollY, outline = false) => {\n        if (com.type !== 0 || !com.childId || (com.hide && this.viewportHoveredInterfaceIndex !== com.id && this.sidebarHoveredInterfaceIndex !== com.id && this.chatHoveredInterfaceIndex !== com.id)) {\n            return;\n        }\n        const left = _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].left;\n        const top = _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].top;\n        const right = _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].right;\n        const bottom = _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].bottom;\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].setBounds(x, y, x + com.width, y + com.height);\n        const children = com.childId.length;\n        for (let i = 0; i < children; i++) {\n            if (!com.childX || !com.childY) {\n                continue;\n            }\n            let childX = com.childX[i] + x;\n            let childY = com.childY[i] + y - scrollY;\n            const child = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[com.childId[i]];\n            childX += child.x;\n            childY += child.y;\n            if (outline) {\n                _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawRect(childX, childY, child.width, child.height, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n            }\n            if (child.clientCode > 0) {\n                this.updateInterfaceContent(child);\n            }\n            if (child.type === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_LAYER) {\n                if (child.scrollPosition > child.scroll - child.height) {\n                    child.scrollPosition = child.scroll - child.height;\n                }\n                if (child.scrollPosition < 0) {\n                    child.scrollPosition = 0;\n                }\n                this.drawInterface(child, childX, childY, child.scrollPosition, outline);\n                if (child.scroll > child.height) {\n                    this.drawScrollbar(childX + child.width, childY, child.scrollPosition, child.scroll, child.height);\n                }\n            }\n            else if (child.type === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_INV) {\n                let slot = 0;\n                for (let row = 0; row < child.height; row++) {\n                    for (let col = 0; col < child.width; col++) {\n                        if (!child.invSlotOffsetX || !child.invSlotOffsetY || !child.invSlotObjId || !child.invSlotObjCount) {\n                            continue;\n                        }\n                        let slotX = childX + col * (child.marginX + 32);\n                        let slotY = childY + row * (child.marginY + 32);\n                        if (slot < 20) {\n                            slotX += child.invSlotOffsetX[slot];\n                            slotY += child.invSlotOffsetY[slot];\n                        }\n                        if (child.invSlotObjId[slot] > 0) {\n                            let dx = 0;\n                            let dy = 0;\n                            const id = child.invSlotObjId[slot] - 1;\n                            if ((slotX >= -32 && slotX <= 512 && slotY >= -32 && slotY <= 334) || (this.objDragArea !== 0 && this.objDragSlot === slot)) {\n                                const icon = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_14__[\"default\"].getIcon(id, child.invSlotObjCount[slot]);\n                                if (this.objDragArea !== 0 && this.objDragSlot === slot && this.objDragInterfaceId === child.id) {\n                                    dx = this.mouseX - this.objGrabX;\n                                    dy = this.mouseY - this.objGrabY;\n                                    if (dx < 5 && dx > -5) {\n                                        dx = 0;\n                                    }\n                                    if (dy < 5 && dy > -5) {\n                                        dy = 0;\n                                    }\n                                    if (this.objDragCycles < 5) {\n                                        dx = 0;\n                                        dy = 0;\n                                    }\n                                    icon.drawAlpha(128, slotX + dx, slotY + dy);\n                                }\n                                else if (this.selectedArea !== 0 && this.selectedItem === slot && this.selectedInterface === child.id) {\n                                    icon.drawAlpha(128, slotX, slotY);\n                                }\n                                else {\n                                    icon.draw(slotX, slotY);\n                                }\n                                if (icon.cropW === 33 || child.invSlotObjCount[slot] !== 1) {\n                                    const count = child.invSlotObjCount[slot];\n                                    this.fontPlain11?.drawString(slotX + dx + 1, slotY + 10 + dy, this.formatObjCount(count), _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                                    this.fontPlain11?.drawString(slotX + dx, slotY + 9 + dy, this.formatObjCount(count), _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW);\n                                }\n                            }\n                        }\n                        else if (child.invSlotSprite && slot < 20) {\n                            const image = child.invSlotSprite[slot];\n                            image?.draw(slotX, slotY);\n                        }\n                        slot++;\n                    }\n                }\n            }\n            else if (child.type === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_RECT) {\n                if (child.fill) {\n                    _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fillRect(childX, childY, child.width, child.height, child.colour);\n                }\n                else {\n                    _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawRect(childX, childY, child.width, child.height, child.colour);\n                }\n            }\n            else if (child.type === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_TEXT) {\n                const font = child.font;\n                let color = child.colour;\n                let text = child.text;\n                if ((this.chatHoveredInterfaceIndex === child.id || this.sidebarHoveredInterfaceIndex === child.id || this.viewportHoveredInterfaceIndex === child.id) && child.overColour !== 0) {\n                    color = child.overColour;\n                }\n                if (this.executeInterfaceScript(child)) {\n                    color = child.activeColour;\n                    if (child.activeText && child.activeText.length > 0) {\n                        text = child.activeText;\n                    }\n                }\n                if (child.buttonType === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BUTTON_CONTINUE && this.pressedContinueOption) {\n                    text = 'Please wait...';\n                    color = child.colour;\n                }\n                if (!font || !text) {\n                    continue;\n                }\n                for (let lineY = childY + font.height; text.length > 0; lineY += font.height) {\n                    if (text.indexOf('%') !== -1) {\n                        do {\n                            const index = text.indexOf('%1');\n                            if (index === -1) {\n                                break;\n                            }\n                            text = text.substring(0, index) + this.getIntString(this.executeClientscript1(child, 0)) + text.substring(index + 2);\n                            // eslint-disable-next-line no-constant-condition\n                        } while (true);\n                        do {\n                            const index = text.indexOf('%2');\n                            if (index === -1) {\n                                break;\n                            }\n                            text = text.substring(0, index) + this.getIntString(this.executeClientscript1(child, 1)) + text.substring(index + 2);\n                            // eslint-disable-next-line no-constant-condition\n                        } while (true);\n                        do {\n                            const index = text.indexOf('%3');\n                            if (index === -1) {\n                                break;\n                            }\n                            text = text.substring(0, index) + this.getIntString(this.executeClientscript1(child, 2)) + text.substring(index + 2);\n                            // eslint-disable-next-line no-constant-condition\n                        } while (true);\n                        do {\n                            const index = text.indexOf('%4');\n                            if (index === -1) {\n                                break;\n                            }\n                            text = text.substring(0, index) + this.getIntString(this.executeClientscript1(child, 3)) + text.substring(index + 2);\n                            // eslint-disable-next-line no-constant-condition\n                        } while (true);\n                        do {\n                            const index = text.indexOf('%5');\n                            if (index === -1) {\n                                break;\n                            }\n                            text = text.substring(0, index) + this.getIntString(this.executeClientscript1(child, 4)) + text.substring(index + 2);\n                            // eslint-disable-next-line no-constant-condition\n                        } while (true);\n                    }\n                    const newline = text.indexOf('\\\\n');\n                    let split;\n                    if (newline !== -1) {\n                        split = text.substring(0, newline);\n                        text = text.substring(newline + 2);\n                    }\n                    else {\n                        split = text;\n                        text = '';\n                    }\n                    if (child.center) {\n                        font.drawStringTaggableCenter(childX + ((child.width / 2) | 0), lineY, split, color, child.shadowed);\n                    }\n                    else {\n                        font.drawStringTaggable(childX, lineY, split, color, child.shadowed);\n                    }\n                }\n            }\n            else if (child.type === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_GRAPHIC) {\n                let image;\n                if (this.executeInterfaceScript(child)) {\n                    image = child.activeGraphic;\n                }\n                else {\n                    image = child.graphic;\n                }\n                image?.draw(childX, childY);\n            }\n            else if (child.type === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_MODEL) {\n                const tmpX = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerX;\n                const tmpY = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerY;\n                _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerX = childX + ((child.width / 2) | 0);\n                _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerY = childY + ((child.height / 2) | 0);\n                const eyeY = (_jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].sin[child.xan] * child.zoom) >> 16;\n                const eyeZ = (_jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cos[child.xan] * child.zoom) >> 16;\n                const active = this.executeInterfaceScript(child);\n                let seqId;\n                if (active) {\n                    seqId = child.activeAnim;\n                }\n                else {\n                    seqId = child.anim;\n                }\n                let model = null;\n                if (seqId === -1) {\n                    model = child.getModel(-1, -1, active);\n                }\n                else {\n                    const seq = _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_17__[\"default\"].instances[seqId];\n                    if (seq.frames && seq.iframes) {\n                        model = child.getModel(seq.frames[child.seqFrame], seq.iframes[child.seqFrame], active);\n                    }\n                }\n                if (model) {\n                    model.drawSimple(0, child.yan, 0, child.xan, 0, eyeY, eyeZ);\n                }\n                _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerX = tmpX;\n                _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerY = tmpY;\n            }\n            else if (child.type === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TYPE_INV_TEXT) {\n                const font = child.font;\n                if (!font || !child.invSlotObjId || !child.invSlotObjCount) {\n                    continue;\n                }\n                let slot = 0;\n                for (let row = 0; row < child.height; row++) {\n                    for (let col = 0; col < child.width; col++) {\n                        if (child.invSlotObjId[slot] > 0) {\n                            const obj = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_14__[\"default\"].get(child.invSlotObjId[slot] - 1);\n                            let text = obj.name;\n                            if (obj.stackable || child.invSlotObjCount[slot] !== 1) {\n                                text = text + ' x' + this.formatObjCountTagged(child.invSlotObjCount[slot]);\n                            }\n                            if (!text) {\n                                continue;\n                            }\n                            const textX = childX + col * (child.marginX + 115);\n                            const textY = childY + row * (child.marginY + 12);\n                            if (child.center) {\n                                font.drawStringTaggableCenter(textX + ((child.width / 2) | 0), textY, text, child.colour, child.shadowed);\n                            }\n                            else {\n                                font.drawStringTaggable(textX, textY, text, child.colour, child.shadowed);\n                            }\n                        }\n                        slot++;\n                    }\n                }\n            }\n        }\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_13__[\"default\"].setBounds(left, top, right, bottom);\n    };\n    updateInterfaceContent = (component) => {\n        let clientCode = component.clientCode;\n        if (clientCode >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_FRIENDS_START && clientCode <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_FRIENDS_END) {\n            clientCode--;\n            if (clientCode >= this.friendCount) {\n                component.text = '';\n                component.buttonType = 0;\n            }\n            else {\n                component.text = this.friendName[clientCode];\n                component.buttonType = 1;\n            }\n        }\n        else if (clientCode >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_FRIENDS_UPDATE_START && clientCode <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_FRIENDS_UPDATE_END) {\n            clientCode -= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_FRIENDS_UPDATE_START;\n            if (clientCode >= this.friendCount) {\n                component.text = '';\n                component.buttonType = 0;\n            }\n            else {\n                if (this.friendWorld[clientCode] === 0) {\n                    component.text = '@red@Offline';\n                }\n                else if (this.friendWorld[clientCode] === Client.nodeId) {\n                    component.text = '@gre@World-' + (this.friendWorld[clientCode] - 9);\n                }\n                else {\n                    component.text = '@yel@World-' + (this.friendWorld[clientCode] - 9);\n                }\n                component.buttonType = 1;\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_FRIENDS_SIZE) {\n            component.scroll = this.friendCount * 15 + 20;\n            if (component.scroll <= component.height) {\n                component.scroll = component.height + 1;\n            }\n        }\n        else if (clientCode >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_IGNORES_START && clientCode <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_IGNORES_END) {\n            clientCode -= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_IGNORES_START;\n            if (clientCode >= this.ignoreCount) {\n                component.text = '';\n                component.buttonType = 0;\n            }\n            else {\n                component.text = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_18__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_18__[\"default\"].fromBase37(this.ignoreName37[clientCode]));\n                component.buttonType = 1;\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_IGNORES_SIZE) {\n            component.scroll = this.ignoreCount * 15 + 20;\n            if (component.scroll <= component.height) {\n                component.scroll = component.height + 1;\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_DESIGN_PREVIEW) {\n            component.xan = 150;\n            component.yan = ((Math.sin(this.loopCycle / 40.0) * 256.0) | 0) & 0x7ff;\n            if (this.updateDesignModel) {\n                this.updateDesignModel = false;\n                const models = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_11__.TypedArray1d(7, null);\n                let modelCount = 0;\n                for (let part = 0; part < 7; part++) {\n                    const kit = this.designIdentikits[part];\n                    if (kit >= 0) {\n                        models[modelCount++] = _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_19__[\"default\"].instances[kit].getModel();\n                    }\n                }\n                const model = _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_16__[\"default\"].modelFromModels(models, modelCount);\n                for (let part = 0; part < 5; part++) {\n                    if (this.designColors[part] !== 0) {\n                        model.recolor(_jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_10__[\"default\"].DESIGN_IDK_COLORS[part][0], _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_10__[\"default\"].DESIGN_IDK_COLORS[part][this.designColors[part]]);\n                        if (part === 1) {\n                            model.recolor(_jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_10__[\"default\"].TORSO_RECOLORS[0], _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_10__[\"default\"].TORSO_RECOLORS[this.designColors[part]]);\n                        }\n                    }\n                }\n                if (this.localPlayer) {\n                    const frames = _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_17__[\"default\"].instances[this.localPlayer.seqStandId].frames;\n                    if (frames) {\n                        model.createLabelReferences();\n                        model.applyTransform(frames[0]);\n                        model.calculateNormals(64, 850, -30, -50, -30, true);\n                        component.model = model;\n                    }\n                }\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_SWITCH_TO_MALE) {\n            if (!this.genderButtonImage0) {\n                this.genderButtonImage0 = component.graphic;\n                this.genderButtonImage1 = component.activeGraphic;\n            }\n            if (this.designGenderMale) {\n                component.graphic = this.genderButtonImage1;\n            }\n            else {\n                component.graphic = this.genderButtonImage0;\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_SWITCH_TO_FEMALE) {\n            if (!this.genderButtonImage0) {\n                this.genderButtonImage0 = component.graphic;\n                this.genderButtonImage1 = component.activeGraphic;\n            }\n            if (this.designGenderMale) {\n                component.graphic = this.genderButtonImage0;\n            }\n            else {\n                component.graphic = this.genderButtonImage1;\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_REPORT_INPUT) {\n            component.text = this.reportAbuseInput;\n            if (this.loopCycle % 20 < 10) {\n                component.text = component.text + '|';\n            }\n            else {\n                component.text = component.text + ' ';\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_MOD_MUTE) {\n            if (!this.rights) {\n                component.text = '';\n            }\n            else if (this.reportAbuseMuteOption) {\n                component.colour = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED;\n                component.text = 'Moderator option: Mute player for 48 hours: <ON>';\n            }\n            else {\n                component.colour = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE;\n                component.text = 'Moderator option: Mute player for 48 hours: <OFF>';\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_LAST_LOGIN_INFO || clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_LAST_LOGIN_INFO2) {\n            if (this.lastAddress === 0) {\n                component.text = '';\n            }\n            else {\n                let text;\n                if (this.daysSinceLastLogin === 0) {\n                    text = 'earlier today';\n                }\n                else if (this.daysSinceLastLogin === 1) {\n                    text = 'yesterday';\n                }\n                else {\n                    text = this.daysSinceLastLogin + ' days ago';\n                }\n                component.text = 'You last logged in ' + text + ' from: ' + _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_18__[\"default\"].formatIPv4(this.lastAddress); // TODO dns lookup??\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_UNREAD_MESSAGES) {\n            if (this.unreadMessages === 0) {\n                component.text = '0 unread messages';\n                component.colour = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW;\n            }\n            if (this.unreadMessages === 1) {\n                component.text = '1 unread message';\n                component.colour = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN;\n            }\n            if (this.unreadMessages > 1) {\n                component.text = this.unreadMessages + ' unread messages';\n                component.colour = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN;\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_RECOVERY1) {\n            if (this.daysSinceRecoveriesChanged === 201) {\n                component.text = '';\n            }\n            else if (this.daysSinceRecoveriesChanged === 200) {\n                component.text = 'You have not yet set any password recovery questions.';\n            }\n            else {\n                let text;\n                if (this.daysSinceRecoveriesChanged === 0) {\n                    text = 'Earlier today';\n                }\n                else if (this.daysSinceRecoveriesChanged === 1) {\n                    text = 'Yesterday';\n                }\n                else {\n                    text = this.daysSinceRecoveriesChanged + ' days ago';\n                }\n                component.text = text + ' you changed your recovery questions';\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_RECOVERY2) {\n            if (this.daysSinceRecoveriesChanged === 201) {\n                component.text = '';\n            }\n            else if (this.daysSinceRecoveriesChanged === 200) {\n                component.text = 'We strongly recommend you do so now to secure your account.';\n            }\n            else {\n                component.text = 'If you do not remember making this change then cancel it immediately';\n            }\n        }\n        else if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CC_RECOVERY3) {\n            if (this.daysSinceRecoveriesChanged === 201) {\n                component.text = '';\n            }\n            else if (this.daysSinceRecoveriesChanged === 200) {\n                component.text = \"Do this from the 'account management' area on our front webpage\";\n            }\n            else {\n                component.text = \"Do this from the 'account management' area on our front webpage\";\n            }\n        }\n    };\n    executeClientscript1 = (component, scriptId) => {\n        if (!component.scripts || scriptId >= component.scripts.length) {\n            return -2;\n        }\n        try {\n            const script = component.scripts[scriptId];\n            if (!script) {\n                // -1 is right bcos if an exception happen from array not being initialized in the lower code etc etc\n                return -1;\n            }\n            let register = 0;\n            let pc = 0;\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const opcode = script[pc++];\n                if (opcode === 0) {\n                    return register;\n                }\n                if (opcode === 1) {\n                    // load_skill_level {skill}\n                    register += this.skillLevel[script[pc++]];\n                }\n                else if (opcode === 2) {\n                    // load_skill_base_level {skill}\n                    register += this.skillBaseLevel[script[pc++]];\n                }\n                else if (opcode === 3) {\n                    // load_skill_exp {skill}\n                    register += this.skillExperience[script[pc++]];\n                }\n                else if (opcode === 4) {\n                    // load_inv_count {interface id} {obj id}\n                    const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[script[pc++]];\n                    const obj = script[pc++] + 1;\n                    if (com.invSlotObjId && com.invSlotObjCount) {\n                        for (let i = 0; i < com.invSlotObjId.length; i++) {\n                            if (com.invSlotObjId[i] === obj) {\n                                register += com.invSlotObjCount[i];\n                            }\n                        }\n                    }\n                    else {\n                        register += 0; // TODO this is custom bcos idk if it can fall 'out of sync' if u dont add to register...\n                    }\n                }\n                else if (opcode === 5) {\n                    // load_var {id}\n                    register += this.varps[script[pc++]];\n                }\n                else if (opcode === 6) {\n                    // load_next_level_xp {skill}\n                    register += this.levelExperience[this.skillBaseLevel[script[pc++]] - 1];\n                }\n                else if (opcode === 7) {\n                    register += ((this.varps[script[pc++]] * 100) / 46875) | 0;\n                }\n                else if (opcode === 8) {\n                    // load_combat_level\n                    register += this.localPlayer?.combatLevel || 0;\n                }\n                else if (opcode === 9) {\n                    // load_total_level\n                    for (let i = 0; i < 19; i++) {\n                        if (i === 18) {\n                            // runecrafting\n                            i = 20;\n                        }\n                        register += this.skillBaseLevel[i];\n                    }\n                }\n                else if (opcode === 10) {\n                    // load_inv_contains {interface id} {obj id}\n                    const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[script[pc++]];\n                    const obj = script[pc++] + 1;\n                    for (let i = 0; i < com.invSlotObjId.length; i++) {\n                        if (com.invSlotObjId[i] === obj) {\n                            register += 999999999;\n                            break;\n                        }\n                    }\n                }\n                else if (opcode === 11) {\n                    // load_energy\n                    register += this.energy;\n                }\n                else if (opcode === 12) {\n                    // load_weight\n                    register += this.weightCarried;\n                }\n                else if (opcode === 13) {\n                    // load_bool {varp} {bit: 0..31}\n                    const varp = this.varps[script[pc++]];\n                    const lsb = script[pc++];\n                    register += (varp & (0x1 << lsb)) === 0 ? 0 : 1;\n                }\n            }\n        }\n        catch (e) {\n            return -1;\n        }\n    };\n    // ---- private functions\n    getIntString = (value) => {\n        return value < 999999999 ? String(value) : '*';\n    };\n    formatObjCountTagged = (amount) => {\n        let s = String(amount);\n        for (let i = s.length - 3; i > 0; i -= 3) {\n            s = s.substring(0, i) + ',' + s.substring(i);\n        }\n        if (s.length > 8) {\n            s = '@gre@' + s.substring(0, s.length - 8) + ' million @whi@(' + s + ')';\n        }\n        else if (s.length > 4) {\n            s = '@cya@' + s.substring(0, s.length - 4) + 'K @whi@(' + s + ')';\n        }\n        return ' ' + s;\n    };\n    formatObjCount = (amount) => {\n        if (amount < 100000) {\n            return String(amount);\n        }\n        else if (amount < 10000000) {\n            return ((amount / 1000) | 0) + 'K';\n        }\n        else {\n            return ((amount / 1000000) | 0) + 'M';\n        }\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/client.ts?");

/***/ }),

/***/ "./src/js/configuration.ts":
/*!*********************************!*\
  !*** ./src/js/configuration.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupConfiguration: () => (/* binding */ setupConfiguration)\n/* harmony export */ });\n/* harmony import */ var _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jagex2/client/GameShell */ \"./src/js/jagex2/client/GameShell.ts\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client */ \"./src/js/client.ts\");\n/* harmony import */ var _jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jagex2/util/JsUtil */ \"./src/js/jagex2/util/JsUtil.ts\");\n\n\n\nasync function setupConfiguration() {\n    await world();\n    detail();\n    method();\n    worker();\n}\n// setup the world config.\nasync function world() {\n    if (_jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getParameter('world').length === 0) {\n        _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setParameter('world', '0');\n    }\n    if (window.location.hostname === 'localhost' && _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getParameter('world') === '0') {\n        localConfiguration();\n    }\n    else {\n        await liveConfiguration(window.location.protocol.startsWith('https'));\n    }\n}\n// setup the detail\nfunction detail() {\n    if (_jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getParameter('detail').length === 0) {\n        _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setParameter('detail', 'high');\n    }\n    if (_jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getParameter('detail') === 'low') {\n        _client__WEBPACK_IMPORTED_MODULE_1__.Client.setLowMemory();\n    }\n    else {\n        _client__WEBPACK_IMPORTED_MODULE_1__.Client.setHighMemory();\n    }\n}\n// setup the method\nfunction method() {\n    if (_jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getParameter('method').length === 0) {\n        _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setParameter('method', '0');\n    }\n}\n// setup the clientstream type\nfunction worker() {\n    if (_jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getParameter('worker').length === 0) {\n        _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setParameter('worker', '1');\n    }\n}\n// ---\nfunction localConfiguration() {\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.serverAddress = 'http://localhost';\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.httpAddress = 'http://localhost';\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.portOffset = 0;\n}\nasync function liveConfiguration(secured) {\n    const world = await getWorldInfo(secured, parseInt(_jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getParameter('world'), 10));\n    const url = new URL(world.address);\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.nodeId = 10 + world.id - 1;\n    // this way so we dont keep the port if address has one\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.serverAddress = `${url.protocol}//${url.hostname}`;\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.httpAddress = `${url.protocol}//${url.hostname}:${url.port}`;\n    if (!secured) {\n        _client__WEBPACK_IMPORTED_MODULE_1__.Client.serverAddress = _client__WEBPACK_IMPORTED_MODULE_1__.Client.serverAddress.replace('https:', 'http:');\n        // Client.httpAddress = Client.httpAddress.replace('https:', 'http:'); world 3 and 4 have to use secured\n    }\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.portOffset = world.portOffset;\n    _client__WEBPACK_IMPORTED_MODULE_1__.Client.members = world?.members === true;\n    _jagex2_client_GameShell__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setParameter('world', world.id.toString(10));\n}\nasync function getWorldInfo(secured, id, retries = 0) {\n    if (retries >= 10) {\n        throw new Error('could not find world to connect!');\n    }\n    // github host is secured for example.\n    const protocol = secured ? 'https:' : 'http:';\n    let worldlist;\n    try {\n        worldlist = JSON.parse(await (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_2__.downloadText)(`${protocol}//2004scape.org/api/v1/worldlist`));\n    }\n    catch (e) {\n        await (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_2__.sleep)(1000);\n        return getWorldInfo(secured, id, ++retries);\n    }\n    worldlist.push({\n        id: 0,\n        region: 'Local Development',\n        address: 'http://localhost',\n        portOffset: 0,\n        members: true,\n        players: 0\n    });\n    const world = worldlist.find((x) => x.id === id);\n    if (!world) {\n        return getWorldInfo(secured, id, 10);\n    }\n    return world;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/configuration.ts?");

/***/ }),

/***/ "./src/js/game.ts":
/*!************************!*\
  !*** ./src/js/game.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jagex2/config/SeqType */ \"./src/js/jagex2/config/SeqType.ts\");\n/* harmony import */ var _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jagex2/config/LocType */ \"./src/js/jagex2/config/LocType.ts\");\n/* harmony import */ var _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jagex2/config/ObjType */ \"./src/js/jagex2/config/ObjType.ts\");\n/* harmony import */ var _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jagex2/config/NpcType */ \"./src/js/jagex2/config/NpcType.ts\");\n/* harmony import */ var _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jagex2/config/IdkType */ \"./src/js/jagex2/config/IdkType.ts\");\n/* harmony import */ var _jagex2_config_SpotAnimType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jagex2/config/SpotAnimType */ \"./src/js/jagex2/config/SpotAnimType.ts\");\n/* harmony import */ var _jagex2_config_VarpType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./jagex2/config/VarpType */ \"./src/js/jagex2/config/VarpType.ts\");\n/* harmony import */ var _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./jagex2/config/Component */ \"./src/js/jagex2/config/Component.ts\");\n/* harmony import */ var _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./jagex2/graphics/PixMap */ \"./src/js/jagex2/graphics/PixMap.ts\");\n/* harmony import */ var _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./jagex2/graphics/Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./jagex2/graphics/Draw3D */ \"./src/js/jagex2/graphics/Draw3D.ts\");\n/* harmony import */ var _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./jagex2/graphics/Pix8 */ \"./src/js/jagex2/graphics/Pix8.ts\");\n/* harmony import */ var _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./jagex2/graphics/Pix24 */ \"./src/js/jagex2/graphics/Pix24.ts\");\n/* harmony import */ var _jagex2_graphics_PixFont__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./jagex2/graphics/PixFont */ \"./src/js/jagex2/graphics/PixFont.ts\");\n/* harmony import */ var _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./jagex2/graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./jagex2/graphics/Colors */ \"./src/js/jagex2/graphics/Colors.ts\");\n/* harmony import */ var _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./jagex2/io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _jagex2_io_ClientStream__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./jagex2/io/ClientStream */ \"./src/js/jagex2/io/ClientStream.ts\");\n/* harmony import */ var _jagex2_io_Protocol__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./jagex2/io/Protocol */ \"./src/js/jagex2/io/Protocol.ts\");\n/* harmony import */ var _jagex2_io_Isaac__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./jagex2/io/Isaac */ \"./src/js/jagex2/io/Isaac.ts\");\n/* harmony import */ var _jagex2_io_Database__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./jagex2/io/Database */ \"./src/js/jagex2/io/Database.ts\");\n/* harmony import */ var _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./jagex2/io/ServerProt */ \"./src/js/jagex2/io/ServerProt.ts\");\n/* harmony import */ var _jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./jagex2/io/ClientProt */ \"./src/js/jagex2/io/ClientProt.ts\");\n/* harmony import */ var _jagex2_wordenc_WordFilter__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./jagex2/wordenc/WordFilter */ \"./src/js/jagex2/wordenc/WordFilter.ts\");\n/* harmony import */ var _jagex2_wordenc_WordPack__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./jagex2/wordenc/WordPack */ \"./src/js/jagex2/wordenc/WordPack.ts\");\n/* harmony import */ var _jagex2_sound_Wave__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./jagex2/sound/Wave */ \"./src/js/jagex2/sound/Wave.ts\");\n/* harmony import */ var _vendor_midi_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./vendor/midi.js */ \"./src/js/vendor/midi.js\");\n/* harmony import */ var _vendor_bzip__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./vendor/bzip */ \"./src/js/vendor/bzip.ts\");\n/* harmony import */ var _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./jagex2/datastruct/LinkList */ \"./src/js/jagex2/datastruct/LinkList.ts\");\n/* harmony import */ var _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./jagex2/datastruct/JString */ \"./src/js/jagex2/datastruct/JString.ts\");\n/* harmony import */ var _jagex2_client_InputTracking__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./jagex2/client/InputTracking */ \"./src/js/jagex2/client/InputTracking.ts\");\n/* harmony import */ var _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./jagex2/dash3d/World3D */ \"./src/js/jagex2/dash3d/World3D.ts\");\n/* harmony import */ var _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./jagex2/dash3d/World */ \"./src/js/jagex2/dash3d/World.ts\");\n/* harmony import */ var _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./jagex2/dash3d/LocLayer */ \"./src/js/jagex2/dash3d/LocLayer.ts\");\n/* harmony import */ var _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./jagex2/dash3d/LocShape */ \"./src/js/jagex2/dash3d/LocShape.ts\");\n/* harmony import */ var _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./jagex2/dash3d/LocAngle */ \"./src/js/jagex2/dash3d/LocAngle.ts\");\n/* harmony import */ var _jagex2_dash3d_type_LocTemporary__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./jagex2/dash3d/type/LocTemporary */ \"./src/js/jagex2/dash3d/type/LocTemporary.ts\");\n/* harmony import */ var _jagex2_dash3d_type_LocSpawned__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./jagex2/dash3d/type/LocSpawned */ \"./src/js/jagex2/dash3d/type/LocSpawned.ts\");\n/* harmony import */ var _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./jagex2/dash3d/CollisionMap */ \"./src/js/jagex2/dash3d/CollisionMap.ts\");\n/* harmony import */ var _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./jagex2/dash3d/CollisionFlag */ \"./src/js/jagex2/dash3d/CollisionFlag.ts\");\n/* harmony import */ var _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./jagex2/dash3d/entity/PlayerEntity */ \"./src/js/jagex2/dash3d/entity/PlayerEntity.ts\");\n/* harmony import */ var _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./jagex2/dash3d/entity/NpcEntity */ \"./src/js/jagex2/dash3d/entity/NpcEntity.ts\");\n/* harmony import */ var _jagex2_dash3d_entity_ObjStackEntity__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./jagex2/dash3d/entity/ObjStackEntity */ \"./src/js/jagex2/dash3d/entity/ObjStackEntity.ts\");\n/* harmony import */ var _jagex2_dash3d_entity_LocEntity__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./jagex2/dash3d/entity/LocEntity */ \"./src/js/jagex2/dash3d/entity/LocEntity.ts\");\n/* harmony import */ var _jagex2_dash3d_entity_ProjectileEntity__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./jagex2/dash3d/entity/ProjectileEntity */ \"./src/js/jagex2/dash3d/entity/ProjectileEntity.ts\");\n/* harmony import */ var _jagex2_dash3d_entity_SpotAnimEntity__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./jagex2/dash3d/entity/SpotAnimEntity */ \"./src/js/jagex2/dash3d/entity/SpotAnimEntity.ts\");\n/* harmony import */ var _jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./jagex2/util/AudioUtil.js */ \"./src/js/jagex2/util/AudioUtil.js\");\n/* harmony import */ var _jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./jagex2/util/JsUtil */ \"./src/js/jagex2/util/JsUtil.ts\");\n/* harmony import */ var _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./jagex2/util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./client */ \"./src/js/client.ts\");\n/* harmony import */ var _jagex2_graphics_AnimBase__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./jagex2/graphics/AnimBase */ \"./src/js/jagex2/graphics/AnimBase.ts\");\n/* harmony import */ var _jagex2_graphics_AnimFrame__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./jagex2/graphics/AnimFrame */ \"./src/js/jagex2/graphics/AnimFrame.ts\");\n/* harmony import */ var _jagex2_config_FloType__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./jagex2/config/FloType */ \"./src/js/jagex2/config/FloType.ts\");\n/* harmony import */ var _configuration__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./configuration */ \"./src/js/configuration.ts\");\n/* harmony import */ var _jagex2_dash3d_type_Tile__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./jagex2/dash3d/type/Tile */ \"./src/js/jagex2/dash3d/type/Tile.ts\");\n/* harmony import */ var _jagex2_dash3d_DirectionFlag__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./jagex2/dash3d/DirectionFlag */ \"./src/js/jagex2/dash3d/DirectionFlag.ts\");\n/* harmony import */ var _jagex2_io_ClientWorkerStream__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./jagex2/io/ClientWorkerStream */ \"./src/js/jagex2/io/ClientWorkerStream.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// noinspection JSSuspiciousNameCombination\nclass Game extends _client__WEBPACK_IMPORTED_MODULE_49__.Client {\n    load = async () => {\n        if (this.alreadyStarted) {\n            this.errorStarted = true;\n            return;\n        }\n        this.alreadyStarted = true;\n        try {\n            await this.showProgress(10, 'Connecting to fileserver');\n            await _vendor_bzip__WEBPACK_IMPORTED_MODULE_27__[\"default\"].load(await (await fetch('bz2.wasm')).arrayBuffer());\n            this.db = new _jagex2_io_Database__WEBPACK_IMPORTED_MODULE_20__[\"default\"](await _jagex2_io_Database__WEBPACK_IMPORTED_MODULE_20__[\"default\"].openDatabase());\n            // const checksums: Packet = new Packet(new Uint8Array(await downloadUrl(`${Client.httpAddress}/crc`)));\n            // for (let i: number = 0; i < 9; i++) {\n            //     this.archiveChecksums[i] = checksums.g4;\n            // }\n            const path = '225/archives/';\n            const urls = ['config', 'crc', 'interface', 'media', 'models', 'sounds', 'textures', 'title', 'wordenc'];\n            try {\n                const responses = await Promise.all(urls.map((url) => fetch(`${path}${url}`, { cache: 'no-cache' })));\n                if (responses.some((response) => response.ok === false)) {\n                    throw new Error('One or more fetch requests failed');\n                }\n                const data = await Promise.all(responses.map((response) => response.arrayBuffer()));\n                for (let i = 0; i < data.length; i++) {\n                    await this.db?.cachesave(urls[i], new Int8Array(data[i]));\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n            if (!_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory) {\n                await this.setMidi('scape_main', 12345678, 40000);\n            }\n            const title = await this.loadArchive('title', 'title screen', this.archiveChecksums[1], 10);\n            this.titleArchive = title;\n            this.fontPlain11 = _jagex2_graphics_PixFont__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fromArchive(title, 'p11');\n            this.fontPlain12 = _jagex2_graphics_PixFont__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fromArchive(title, 'p12');\n            this.fontBold12 = _jagex2_graphics_PixFont__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fromArchive(title, 'b12');\n            this.fontQuill8 = _jagex2_graphics_PixFont__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fromArchive(title, 'q8');\n            await this.loadTitleBackground();\n            this.loadTitleImages();\n            const config = await this.loadArchive('config', 'config', this.archiveChecksums[2], 15);\n            const interfaces = await this.loadArchive('interface', 'interface', this.archiveChecksums[3], 20);\n            const media = await this.loadArchive('media', '2d graphics', this.archiveChecksums[4], 30);\n            const models = await this.loadArchive('models', '3d graphics', this.archiveChecksums[5], 40);\n            const textures = await this.loadArchive('textures', 'textures', this.archiveChecksums[6], 60);\n            const wordenc = await this.loadArchive('wordenc', 'chat system', this.archiveChecksums[7], 65);\n            const sounds = await this.loadArchive('sounds', 'sound effects', this.archiveChecksums[8], 70);\n            this.levelTileFlags = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_48__.Uint8Array3d(_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE);\n            this.levelHeightmap = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_48__.Int32Array3d(_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE + 1, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE + 1);\n            if (this.levelHeightmap) {\n                this.scene = new _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"](this.levelHeightmap, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE);\n            }\n            for (let level = 0; level < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS; level++) {\n                this.levelCollisionMap[level] = new _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"]();\n            }\n            this.imageMinimap = new _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"](512, 512);\n            await this.showProgress(75, 'Unpacking media');\n            this.imageInvback = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'invback', 0);\n            this.imageChatback = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'chatback', 0);\n            this.imageMapback = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'mapback', 0);\n            this.imageBackbase1 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'backbase1', 0);\n            this.imageBackbase2 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'backbase2', 0);\n            this.imageBackhmid1 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'backhmid1', 0);\n            for (let i = 0; i < 13; i++) {\n                this.imageSideicons[i] = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'sideicons', i);\n            }\n            this.imageCompass = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'compass', 0);\n            try {\n                for (let i = 0; i < 50; i++) {\n                    if (i === 22) {\n                        // weird debug sprite along water\n                        continue;\n                    }\n                    this.imageMapscene[i] = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'mapscene', i);\n                }\n            }\n            catch (e) {\n                /* empty */\n            }\n            try {\n                for (let i = 0; i < 50; i++) {\n                    this.imageMapfunction[i] = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'mapfunction', i);\n                }\n            }\n            catch (e) {\n                /* empty */\n            }\n            try {\n                for (let i = 0; i < 20; i++) {\n                    this.imageHitmarks[i] = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'hitmarks', i);\n                }\n            }\n            catch (e) {\n                /* empty */\n            }\n            try {\n                for (let i = 0; i < 20; i++) {\n                    this.imageHeadicons[i] = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'headicons', i);\n                }\n            }\n            catch (e) {\n                /* empty */\n            }\n            this.imageMapflag = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'mapflag', 0);\n            for (let i = 0; i < 8; i++) {\n                this.imageCrosses[i] = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'cross', i);\n            }\n            this.imageMapdot0 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'mapdots', 0);\n            this.imageMapdot1 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'mapdots', 1);\n            this.imageMapdot2 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'mapdots', 2);\n            this.imageMapdot3 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'mapdots', 3);\n            this.imageScrollbar0 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'scrollbar', 0);\n            this.imageScrollbar1 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'scrollbar', 1);\n            this.imageRedstone1 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone1', 0);\n            this.imageRedstone2 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone2', 0);\n            this.imageRedstone3 = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone3', 0);\n            this.imageRedstone1h = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone1', 0);\n            this.imageRedstone1h?.flipHorizontally();\n            this.imageRedstone2h = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone2', 0);\n            this.imageRedstone2h?.flipHorizontally();\n            this.imageRedstone1v = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone1', 0);\n            this.imageRedstone1v?.flipVertically();\n            this.imageRedstone2v = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone2', 0);\n            this.imageRedstone2v?.flipVertically();\n            this.imageRedstone3v = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone3', 0);\n            this.imageRedstone3v?.flipVertically();\n            this.imageRedstone1hv = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone1', 0);\n            this.imageRedstone1hv?.flipHorizontally();\n            this.imageRedstone1hv?.flipVertically();\n            this.imageRedstone2hv = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(media, 'redstone2', 0);\n            this.imageRedstone2hv?.flipHorizontally();\n            this.imageRedstone2hv?.flipVertically();\n            const backleft1 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backleft1', 0);\n            this.areaBackleft1 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backleft1.width, backleft1.height);\n            backleft1.blitOpaque(0, 0);\n            const backleft2 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backleft2', 0);\n            this.areaBackleft2 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backleft2.width, backleft2.height);\n            backleft2.blitOpaque(0, 0);\n            const backright1 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backright1', 0);\n            this.areaBackright1 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backright1.width, backright1.height);\n            backright1.blitOpaque(0, 0);\n            const backright2 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backright2', 0);\n            this.areaBackright2 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backright2.width, backright2.height);\n            backright2.blitOpaque(0, 0);\n            const backtop1 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backtop1', 0);\n            this.areaBacktop1 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backtop1.width, backtop1.height);\n            backtop1.blitOpaque(0, 0);\n            const backtop2 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backtop2', 0);\n            this.areaBacktop2 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backtop2.width, backtop2.height);\n            backtop2.blitOpaque(0, 0);\n            const backvmid1 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backvmid1', 0);\n            this.areaBackvmid1 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backvmid1.width, backvmid1.height);\n            backvmid1.blitOpaque(0, 0);\n            const backvmid2 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backvmid2', 0);\n            this.areaBackvmid2 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backvmid2.width, backvmid2.height);\n            backvmid2.blitOpaque(0, 0);\n            const backvmid3 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backvmid3', 0);\n            this.areaBackvmid3 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backvmid3.width, backvmid3.height);\n            backvmid3.blitOpaque(0, 0);\n            const backhmid2 = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(media, 'backhmid2', 0);\n            this.areaBackhmid2 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](backhmid2.width, backhmid2.height);\n            backhmid2.blitOpaque(0, 0);\n            const randR = ((Math.random() * 21.0) | 0) - 10;\n            const randG = ((Math.random() * 21.0) | 0) - 10;\n            const randB = ((Math.random() * 21.0) | 0) - 10;\n            const rand = ((Math.random() * 41.0) | 0) - 20;\n            for (let i = 0; i < 50; i++) {\n                if (this.imageMapfunction[i]) {\n                    this.imageMapfunction[i]?.translate(randR + rand, randG + rand, randB + rand);\n                }\n                if (this.imageMapscene[i]) {\n                    this.imageMapscene[i]?.translate(randR + rand, randG + rand, randB + rand);\n                }\n            }\n            await this.showProgress(80, 'Unpacking textures');\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].unpackTextures(textures);\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].setBrightness(0.8);\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].initPool(20);\n            await this.showProgress(83, 'Unpacking models');\n            _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].unpack(models);\n            _jagex2_graphics_AnimBase__WEBPACK_IMPORTED_MODULE_50__[\"default\"].unpack(models);\n            _jagex2_graphics_AnimFrame__WEBPACK_IMPORTED_MODULE_51__[\"default\"].unpack(models);\n            await this.showProgress(86, 'Unpacking config');\n            _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].unpack(config);\n            _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].unpack(config);\n            _jagex2_config_FloType__WEBPACK_IMPORTED_MODULE_52__[\"default\"].unpack(config);\n            _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].unpack(config, _client__WEBPACK_IMPORTED_MODULE_49__.Client.members);\n            _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].unpack(config);\n            _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].unpack(config);\n            _jagex2_config_SpotAnimType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].unpack(config);\n            _jagex2_config_VarpType__WEBPACK_IMPORTED_MODULE_6__[\"default\"].unpack(config);\n            if (!_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory) {\n                await this.showProgress(90, 'Unpacking sounds');\n                _jagex2_sound_Wave__WEBPACK_IMPORTED_MODULE_25__[\"default\"].unpack(sounds);\n            }\n            await this.showProgress(92, 'Unpacking interfaces');\n            _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].unpack(interfaces, media, [this.fontPlain11, this.fontPlain12, this.fontBold12, this.fontQuill8]);\n            await this.showProgress(97, 'Preparing game engine');\n            for (let y = 0; y < 33; y++) {\n                let left = 999;\n                let right = 0;\n                for (let x = 0; x < 35; x++) {\n                    if (this.imageMapback.pixels[x + y * this.imageMapback.width] === 0) {\n                        if (left === 999) {\n                            left = x;\n                        }\n                    }\n                    else if (left !== 999) {\n                        right = x;\n                        break;\n                    }\n                }\n                this.compassMaskLineOffsets[y] = left;\n                this.compassMaskLineLengths[y] = right - left;\n            }\n            for (let y = 9; y < 160; y++) {\n                let left = 999;\n                let right = 0;\n                for (let x = 10; x < 168; x++) {\n                    if (this.imageMapback.pixels[x + y * this.imageMapback.width] === 0 && (x > 34 || y > 34)) {\n                        if (left === 999) {\n                            left = x;\n                        }\n                    }\n                    else if (left !== 999) {\n                        right = x;\n                        break;\n                    }\n                }\n                this.minimapMaskLineOffsets[y - 9] = left - 21;\n                this.minimapMaskLineLengths[y - 9] = right - left;\n            }\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].init3D(479, 96);\n            this.areaChatbackOffsets = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].lineOffset;\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].init3D(190, 261);\n            this.areaSidebarOffsets = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].lineOffset;\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].init3D(512, 334);\n            this.areaViewportOffsets = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].lineOffset;\n            const distance = new Int32Array(9);\n            for (let x = 0; x < 9; x++) {\n                const angle = x * 32 + 128 + 15;\n                const offset = angle * 3 + 600;\n                const sin = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].sin[angle];\n                distance[x] = (offset * sin) >> 16;\n            }\n            _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].init(512, 334, 500, 800, distance);\n            _jagex2_wordenc_WordFilter__WEBPACK_IMPORTED_MODULE_23__[\"default\"].unpack(wordenc);\n            this.initializeLevelExperience();\n        }\n        catch (err) {\n            console.error(err);\n            this.errorLoading = true;\n        }\n    };\n    update = async () => {\n        if (this.errorStarted || this.errorLoading || this.errorHost) {\n            return;\n        }\n        this.loopCycle++;\n        if (this.ingame) {\n            await this.updateGame();\n        }\n        else {\n            await this.updateTitleScreen();\n        }\n    };\n    draw = async () => {\n        if (this.errorStarted || this.errorLoading || this.errorHost) {\n            this.drawError();\n            return;\n        }\n        if (this.ingame) {\n            this.drawGame();\n        }\n        else {\n            await this.drawTitleScreen();\n        }\n        this.dragCycles = 0;\n    };\n    refresh = () => {\n        this.redrawTitleBackground = true;\n    };\n    showProgress = async (progress, str) => {\n        console.log(`${progress}%: ${str}`);\n        await this.loadTitle();\n        if (!this.titleArchive) {\n            await super.showProgress(progress, str);\n            return;\n        }\n        this.imageTitle4?.bind();\n        const x = 360;\n        const y = 200;\n        const offsetY = 20;\n        this.fontBold12?.drawStringCenter((x / 2) | 0, ((y / 2) | 0) - offsetY - 26, 'RuneScape is loading - please wait...', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n        const midY = ((y / 2) | 0) - 18 - offsetY;\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawRect(((x / 2) | 0) - 152, midY, 304, 34, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].PROGRESS_RED);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawRect(((x / 2) | 0) - 151, midY + 1, 302, 32, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fillRect(((x / 2) | 0) - 150, midY + 2, progress * 3, 30, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].PROGRESS_RED);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fillRect(((x / 2) | 0) - 150 + progress * 3, midY + 2, 300 - progress * 3, 30, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n        this.fontBold12?.drawStringCenter((x / 2) | 0, ((y / 2) | 0) + 5 - offsetY, str, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n        this.imageTitle4?.draw(214, 186);\n        if (this.redrawTitleBackground) {\n            this.redrawTitleBackground = false;\n            if (!this.flameActive) {\n                this.imageTitle0?.draw(0, 0);\n                this.imageTitle1?.draw(661, 0);\n            }\n            this.imageTitle2?.draw(128, 0);\n            this.imageTitle3?.draw(214, 386);\n            this.imageTitle5?.draw(0, 265);\n            this.imageTitle6?.draw(574, 265);\n            this.imageTitle7?.draw(128, 186);\n            this.imageTitle8?.draw(574, 186);\n        }\n        await (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_47__.sleep)(5); // return a slice of time to the main loop so it can update the progress bar\n    };\n    runFlames = () => {\n        if (!this.flameActive) {\n            return;\n        }\n        this.updateFlames();\n        this.updateFlames();\n        this.drawFlames();\n    };\n    loadTitle = async () => {\n        if (!this.imageTitle2) {\n            this.drawArea = null;\n            this.areaChatback = null;\n            this.areaMapback = null;\n            this.areaSidebar = null;\n            this.areaViewport = null;\n            this.areaBackbase1 = null;\n            this.areaBackbase2 = null;\n            this.areaBackhmid1 = null;\n            this.imageTitle0 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](128, 265);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle1 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](128, 265);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle2 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](533, 186);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle3 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](360, 146);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle4 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](360, 200);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle5 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](214, 267);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle6 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](215, 267);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle7 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](86, 79);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageTitle8 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](87, 79);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            if (this.titleArchive) {\n                await this.loadTitleBackground();\n                this.loadTitleImages();\n            }\n            this.redrawTitleBackground = true;\n        }\n    };\n    loadTitleBackground = async () => {\n        if (!this.titleArchive) {\n            return;\n        }\n        const background = await _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromJpeg(this.titleArchive, 'title');\n        this.imageTitle0?.bind();\n        background.blitOpaque(0, 0);\n        this.imageTitle1?.bind();\n        background.blitOpaque(-661, 0);\n        this.imageTitle2?.bind();\n        background.blitOpaque(-128, 0);\n        this.imageTitle3?.bind();\n        background.blitOpaque(-214, -386);\n        this.imageTitle4?.bind();\n        background.blitOpaque(-214, -186);\n        this.imageTitle5?.bind();\n        background.blitOpaque(0, -265);\n        this.imageTitle6?.bind();\n        background.blitOpaque(-128, -186);\n        this.imageTitle7?.bind();\n        background.blitOpaque(-128, -186);\n        this.imageTitle8?.bind();\n        background.blitOpaque(-574, -186);\n        // draw right side (mirror image)\n        background.flipHorizontally();\n        this.imageTitle0?.bind();\n        background.blitOpaque(394, 0);\n        this.imageTitle1?.bind();\n        background.blitOpaque(-267, 0);\n        this.imageTitle2?.bind();\n        background.blitOpaque(266, 0);\n        this.imageTitle3?.bind();\n        background.blitOpaque(180, -386);\n        this.imageTitle4?.bind();\n        background.blitOpaque(180, -186);\n        this.imageTitle5?.bind();\n        background.blitOpaque(394, -265);\n        this.imageTitle6?.bind();\n        background.blitOpaque(-180, -265);\n        this.imageTitle7?.bind();\n        background.blitOpaque(212, -186);\n        this.imageTitle8?.bind();\n        background.blitOpaque(-180, -186);\n        const logo = _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromArchive(this.titleArchive, 'logo');\n        this.imageTitle2?.bind();\n        logo.draw(((this.width / 2) | 0) - ((logo.width / 2) | 0) - 128, 18);\n    };\n    updateFlameBuffer = (image) => {\n        if (!this.flameBuffer0 || !this.flameBuffer1) {\n            return;\n        }\n        const flameHeight = 256;\n        // Clears the initial flame buffer\n        this.flameBuffer0.fill(0);\n        // Blends the fire at random\n        for (let i = 0; i < 5000; i++) {\n            const rand = (Math.random() * 128.0 * flameHeight) | 0;\n            this.flameBuffer0[rand] = (Math.random() * 256.0) | 0;\n        }\n        // changes color between last few flames\n        for (let i = 0; i < 20; i++) {\n            for (let y = 1; y < flameHeight - 1; y++) {\n                for (let x = 1; x < 127; x++) {\n                    const index = x + (y << 7);\n                    this.flameBuffer1[index] = ((this.flameBuffer0[index - 1] + this.flameBuffer0[index + 1] + this.flameBuffer0[index - 128] + this.flameBuffer0[index + 128]) / 4) | 0;\n                }\n            }\n            const last = this.flameBuffer0;\n            this.flameBuffer0 = this.flameBuffer1;\n            this.flameBuffer1 = last;\n        }\n        // Renders the rune images\n        if (image) {\n            let off = 0;\n            for (let y = 0; y < image.height; y++) {\n                for (let x = 0; x < image.width; x++) {\n                    if (image.pixels[off++] !== 0) {\n                        const x0 = x + image.cropX + 16;\n                        const y0 = y + image.cropY + 16;\n                        const index = x0 + (y0 << 7);\n                        this.flameBuffer0[index] = 0;\n                    }\n                }\n            }\n        }\n    };\n    loadTitleImages = () => {\n        if (!this.titleArchive) {\n            return;\n        }\n        this.imageTitlebox = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(this.titleArchive, 'titlebox');\n        this.imageTitlebutton = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(this.titleArchive, 'titlebutton');\n        for (let i = 0; i < 12; i++) {\n            this.imageRunes[i] = _jagex2_graphics_Pix8__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromArchive(this.titleArchive, 'runes', i);\n        }\n        this.imageFlamesLeft = new _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"](128, 265);\n        this.imageFlamesRight = new _jagex2_graphics_Pix24__WEBPACK_IMPORTED_MODULE_12__[\"default\"](128, 265);\n        if (this.imageTitle0)\n            (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_47__.arraycopy)(this.imageTitle0.pixels, 0, this.imageFlamesLeft.pixels, 0, 33920);\n        if (this.imageTitle1)\n            (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_47__.arraycopy)(this.imageTitle1.pixels, 0, this.imageFlamesRight.pixels, 0, 33920);\n        this.flameGradient0 = new Int32Array(256);\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient0[index] = index * 262144;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient0[index + 64] = index * 1024 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient0[index + 128] = index * 4 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient0[index + 192] = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE;\n        }\n        this.flameGradient1 = new Int32Array(256);\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient1[index] = index * 1024;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient1[index + 64] = index * 4 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient1[index + 128] = index * 262144 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].CYAN;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient1[index + 192] = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE;\n        }\n        this.flameGradient2 = new Int32Array(256);\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient2[index] = index * 4;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient2[index + 64] = index * 262144 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLUE;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient2[index + 128] = index * 1024 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].MAGENTA;\n        }\n        for (let index = 0; index < 64; index++) {\n            this.flameGradient2[index + 192] = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE;\n        }\n        this.flameGradient = new Int32Array(256);\n        this.flameBuffer0 = new Int32Array(32768);\n        this.flameBuffer1 = new Int32Array(32768);\n        this.updateFlameBuffer(null);\n        this.flameBuffer3 = new Int32Array(32768);\n        this.flameBuffer2 = new Int32Array(32768);\n        this.showProgress(10, 'Connecting to fileserver').then(() => {\n            if (!this.flameActive) {\n                this.flameActive = true;\n                this.flamesInterval = setInterval(this.runFlames, 35);\n            }\n        });\n    };\n    updateTitleScreen = async () => {\n        if (this.titleScreenState === 0) {\n            let x = ((this.width / 2) | 0) - 80;\n            let y = ((this.height / 2) | 0) + 20;\n            y += 20;\n            if (this.mouseClickButton === 1 && this.mouseClickX >= x - 75 && this.mouseClickX <= x + 75 && this.mouseClickY >= y - 20 && this.mouseClickY <= y + 20) {\n                this.titleScreenState = 3;\n                this.titleLoginField = 0;\n            }\n            x = ((this.width / 2) | 0) + 80;\n            if (this.mouseClickButton === 1 && this.mouseClickX >= x - 75 && this.mouseClickX <= x + 75 && this.mouseClickY >= y - 20 && this.mouseClickY <= y + 20) {\n                this.loginMessage0 = '';\n                this.loginMessage1 = 'Enter your username & password.';\n                this.titleScreenState = 2;\n                this.titleLoginField = 0;\n            }\n        }\n        else if (this.titleScreenState === 2) {\n            let y = ((this.height / 2) | 0) - 40;\n            y += 30;\n            y += 25;\n            if (this.mouseClickButton === 1 && this.mouseClickY >= y - 15 && this.mouseClickY < y) {\n                this.titleLoginField = 0;\n            }\n            y += 15;\n            if (this.mouseClickButton === 1 && this.mouseClickY >= y - 15 && this.mouseClickY < y) {\n                this.titleLoginField = 1;\n            }\n            // y += 15; dead code\n            let buttonX = ((this.width / 2) | 0) - 80;\n            let buttonY = ((this.height / 2) | 0) + 50;\n            buttonY += 20;\n            if (this.mouseClickButton === 1 && this.mouseClickX >= buttonX - 75 && this.mouseClickX <= buttonX + 75 && this.mouseClickY >= buttonY - 20 && this.mouseClickY <= buttonY + 20) {\n                await this.login(this.username, this.password, false);\n            }\n            buttonX = ((this.width / 2) | 0) + 80;\n            if (this.mouseClickButton === 1 && this.mouseClickX >= buttonX - 75 && this.mouseClickX <= buttonX + 75 && this.mouseClickY >= buttonY - 20 && this.mouseClickY <= buttonY + 20) {\n                this.titleScreenState = 0;\n                this.username = '';\n                this.password = '';\n            }\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const key = this.pollKey();\n                if (key === -1) {\n                    return;\n                }\n                let valid = false;\n                for (let i = 0; i < _jagex2_graphics_PixFont__WEBPACK_IMPORTED_MODULE_13__[\"default\"].CHARSET.length; i++) {\n                    if (String.fromCharCode(key) === _jagex2_graphics_PixFont__WEBPACK_IMPORTED_MODULE_13__[\"default\"].CHARSET.charAt(i)) {\n                        valid = true;\n                        break;\n                    }\n                }\n                if (this.titleLoginField === 0) {\n                    if (key === 8 && this.username.length > 0) {\n                        this.username = this.username.substring(0, this.username.length - 1);\n                    }\n                    if (key === 9 || key === 10 || key === 13) {\n                        this.titleLoginField = 1;\n                    }\n                    if (valid) {\n                        this.username = this.username + String.fromCharCode(key);\n                    }\n                    if (this.username.length > 12) {\n                        this.username = this.username.substring(0, 12);\n                    }\n                }\n                else if (this.titleLoginField === 1) {\n                    if (key === 8 && this.password.length > 0) {\n                        this.password = this.password.substring(0, this.password.length - 1);\n                    }\n                    if (key === 9 || key === 10 || key === 13) {\n                        this.titleLoginField = 0;\n                    }\n                    if (valid) {\n                        this.password = this.password + String.fromCharCode(key);\n                    }\n                    if (this.password.length > 20) {\n                        this.password = this.password.substring(0, 20);\n                    }\n                }\n            }\n        }\n        else if (this.titleScreenState === 3) {\n            const x = (this.width / 2) | 0;\n            let y = ((this.height / 2) | 0) + 50;\n            y += 20;\n            if (this.mouseClickButton === 1 && this.mouseClickX >= x - 75 && this.mouseClickX <= x + 75 && this.mouseClickY >= y - 20 && this.mouseClickY <= y + 20) {\n                this.titleScreenState = 0;\n            }\n        }\n    };\n    drawTitleScreen = async () => {\n        await this.loadTitle();\n        this.imageTitle4?.bind();\n        this.imageTitlebox?.draw(0, 0);\n        const w = 360;\n        const h = 200;\n        if (this.titleScreenState === 0) {\n            let x = (w / 2) | 0;\n            let y = ((h / 2) | 0) - 20;\n            this.fontBold12?.drawStringTaggableCenter(x, y, 'Welcome to RuneScape', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            x = ((w / 2) | 0) - 80;\n            y = ((h / 2) | 0) + 20;\n            this.imageTitlebutton?.draw(x - 73, y - 20);\n            this.fontBold12?.drawStringTaggableCenter(x, y + 5, 'New user', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            x = ((w / 2) | 0) + 80;\n            this.imageTitlebutton?.draw(x - 73, y - 20);\n            this.fontBold12?.drawStringTaggableCenter(x, y + 5, 'Existing User', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n        }\n        else if (this.titleScreenState === 2) {\n            let x = ((w / 2) | 0) - 80;\n            let y = ((h / 2) | 0) - 40;\n            if (this.loginMessage0.length > 0) {\n                this.fontBold12?.drawStringTaggableCenter(w / 2, y - 15, this.loginMessage0, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n                this.fontBold12?.drawStringTaggableCenter(w / 2, y, this.loginMessage1, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n                y += 30;\n            }\n            else {\n                this.fontBold12?.drawStringTaggableCenter(w / 2, y - 7, this.loginMessage1, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n                y += 30;\n            }\n            this.fontBold12?.drawStringTaggable(w / 2 - 90, y, `Username: ${this.username}${this.titleLoginField === 0 && this.loopCycle % 40 < 20 ? '@yel@|' : ''}`, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            y += 15;\n            this.fontBold12?.drawStringTaggable(w / 2 - 88, y, `Password: ${_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toAsterisks(this.password)}${this.titleLoginField === 1 && this.loopCycle % 40 < 20 ? '@yel@|' : ''}`, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            // x = w / 2 - 80; dead code\n            y = ((h / 2) | 0) + 50;\n            this.imageTitlebutton?.draw(x - 73, y - 20);\n            this.fontBold12?.drawStringTaggableCenter(x, y + 5, 'Login', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            x = ((w / 2) | 0) + 80;\n            this.imageTitlebutton?.draw(x - 73, y - 20);\n            this.fontBold12?.drawStringTaggableCenter(x, y + 5, 'Cancel', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n        }\n        else if (this.titleScreenState === 3) {\n            this.fontBold12?.drawStringTaggableCenter(w / 2, h / 2 - 60, 'Create a free account', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            const x = (w / 2) | 0;\n            let y = ((h / 2) | 0) - 35;\n            this.fontBold12?.drawStringTaggableCenter((w / 2) | 0, y, 'To create a new account you need to', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            y += 15;\n            this.fontBold12?.drawStringTaggableCenter((w / 2) | 0, y, 'go back to the main RuneScape webpage', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            y += 15;\n            this.fontBold12?.drawStringTaggableCenter((w / 2) | 0, y, \"and choose the red 'create account'\", _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            y += 15;\n            this.fontBold12?.drawStringTaggableCenter((w / 2) | 0, y, 'button at the top right of that page.', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            // y += 15; dead code\n            y = ((h / 2) | 0) + 50;\n            this.imageTitlebutton?.draw(x - 73, y - 20);\n            this.fontBold12?.drawStringTaggableCenter(x, y + 5, 'Cancel', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n        }\n        this.imageTitle4?.draw(214, 186);\n        if (this.redrawTitleBackground) {\n            this.redrawTitleBackground = false;\n            this.imageTitle2?.draw(128, 0);\n            this.imageTitle3?.draw(214, 386);\n            this.imageTitle5?.draw(0, 265);\n            this.imageTitle6?.draw(574, 265);\n            this.imageTitle7?.draw(128, 186);\n            this.imageTitle8?.draw(574, 186);\n        }\n    };\n    login = async (username, password, reconnect) => {\n        try {\n            if (!reconnect) {\n                this.loginMessage0 = '';\n                this.loginMessage1 = 'Connecting to server...';\n                await this.drawTitleScreen();\n            }\n            if (Game.getParameter('worker') === '0') {\n                this.stream = new _jagex2_io_ClientStream__WEBPACK_IMPORTED_MODULE_17__[\"default\"](await _jagex2_io_ClientStream__WEBPACK_IMPORTED_MODULE_17__[\"default\"].openSocket({ host: _client__WEBPACK_IMPORTED_MODULE_49__.Client.serverAddress, port: 43594 + _client__WEBPACK_IMPORTED_MODULE_49__.Client.portOffset }));\n            }\n            else {\n                this.stream = new _jagex2_io_ClientWorkerStream__WEBPACK_IMPORTED_MODULE_56__[\"default\"]();\n            }\n            await this.stream?.readBytes(this.in.data, 0, 8);\n            this.in.pos = 0;\n            this.serverSeed = this.in.g8;\n            const seed = new Int32Array([Math.floor(Math.random() * 99999999), Math.floor(Math.random() * 99999999), Number(this.serverSeed >> 32n), Number(this.serverSeed & BigInt(0xffffffff))]);\n            this.out.pos = 0;\n            this.out.p1(10);\n            this.out.p4(seed[0]);\n            this.out.p4(seed[1]);\n            this.out.p4(seed[2]);\n            this.out.p4(seed[3]);\n            this.out.p4(0); // TODO signlink UUID\n            this.out.pjstr(username);\n            this.out.pjstr(password);\n            this.out.rsaenc(_client__WEBPACK_IMPORTED_MODULE_49__.Client.modulus, _client__WEBPACK_IMPORTED_MODULE_49__.Client.exponent);\n            this.loginout.pos = 0;\n            if (reconnect) {\n                this.loginout.p1(18);\n            }\n            else {\n                this.loginout.p1(16);\n            }\n            this.loginout.p1(this.out.pos + 36 + 1 + 1);\n            this.loginout.p1(_client__WEBPACK_IMPORTED_MODULE_49__.Client.clientversion);\n            this.loginout.p1(_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory ? 1 : 0);\n            for (let i = 0; i < 9; i++) {\n                this.loginout.p4(this.archiveChecksums[i]);\n            }\n            this.loginout.pdata(this.out.data, this.out.pos, 0);\n            this.out.random = new _jagex2_io_Isaac__WEBPACK_IMPORTED_MODULE_19__[\"default\"](seed);\n            for (let i = 0; i < 4; i++) {\n                seed[i] += 50;\n            }\n            this.randomIn = new _jagex2_io_Isaac__WEBPACK_IMPORTED_MODULE_19__[\"default\"](seed);\n            this.stream?.write(this.loginout.data, this.loginout.pos);\n            const reply = await this.stream.read();\n            if (reply === 1) {\n                await (0,_jagex2_util_JsUtil__WEBPACK_IMPORTED_MODULE_47__.sleep)(2000);\n                await this.login(username, password, reconnect);\n                return;\n            }\n            if (reply === 2 || reply === 18) {\n                this.rights = reply === 18;\n                _jagex2_client_InputTracking__WEBPACK_IMPORTED_MODULE_30__[\"default\"].setDisabled();\n                this.ingame = true;\n                this.out.pos = 0;\n                this.in.pos = 0;\n                this.packetType = -1;\n                this.lastPacketType0 = -1;\n                this.lastPacketType1 = -1;\n                this.lastPacketType2 = -1;\n                this.packetSize = 0;\n                this.idleNetCycles = 0;\n                this.systemUpdateTimer = 0;\n                this.idleTimeout = 0;\n                this.hintType = 0;\n                this.menuSize = 0;\n                this.menuVisible = false;\n                this.idleCycles = 0;\n                for (let i = 0; i < 100; i++) {\n                    this.messageText[i] = null;\n                }\n                this.objSelected = 0;\n                this.spellSelected = 0;\n                this.sceneState = 0;\n                this.waveCount = 0;\n                this.cameraAnticheatOffsetX = ((Math.random() * 100.0) | 0) - 50;\n                this.cameraAnticheatOffsetZ = ((Math.random() * 110.0) | 0) - 55;\n                this.cameraAnticheatAngle = ((Math.random() * 80.0) | 0) - 40;\n                this.minimapAnticheatAngle = ((Math.random() * 120.0) | 0) - 60;\n                this.minimapZoom = ((Math.random() * 30.0) | 0) - 20;\n                this.orbitCameraYaw = (((Math.random() * 20.0) | 0) - 10) & 0x7ff;\n                this.minimapLevel = -1;\n                this.flagSceneTileX = 0;\n                this.flagSceneTileZ = 0;\n                this.playerCount = 0;\n                this.npcCount = 0;\n                for (let i = 0; i < this.MAX_PLAYER_COUNT; i++) {\n                    this.players[i] = null;\n                    this.playerAppearanceBuffer[i] = null;\n                }\n                for (let i = 0; i < 8192; i++) {\n                    this.npcs[i] = null;\n                }\n                this.localPlayer = this.players[this.LOCAL_PLAYER_INDEX] = new _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"]();\n                this.projectiles.clear();\n                this.spotanims.clear();\n                this.temporaryLocs.clear();\n                for (let level = 0; level < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS; level++) {\n                    for (let x = 0; x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; x++) {\n                        for (let z = 0; z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; z++) {\n                            this.levelObjStacks[level][x][z] = null;\n                        }\n                    }\n                }\n                this.spawnedLocations = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_28__[\"default\"]();\n                this.friendCount = 0;\n                this.stickyChatInterfaceId = -1;\n                this.chatInterfaceId = -1;\n                this.viewportInterfaceId = -1;\n                this.sidebarInterfaceId = -1;\n                this.pressedContinueOption = false;\n                this.selectedTab = 3;\n                this.chatbackInputOpen = false;\n                this.menuVisible = false;\n                this.showSocialInput = false;\n                this.modalMessage = null;\n                this.inMultizone = 0;\n                this.flashingTab = -1;\n                this.designGenderMale = true;\n                this.validateCharacterDesign();\n                for (let i = 0; i < 5; i++) {\n                    this.designColors[i] = 0;\n                }\n                (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.stopMidi)(); // custom fix :-)\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic1 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic2 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic3 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic4 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic5 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic6 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic7 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic8 = 0;\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic9 = 0;\n                this.prepareGameScreen();\n                return;\n            }\n            if (reply === 3) {\n                this.loginMessage0 = '';\n                this.loginMessage1 = 'Invalid username or password.';\n                return;\n            }\n            if (reply === 4) {\n                this.loginMessage0 = 'Your account has been disabled.';\n                this.loginMessage1 = 'Please check your message-centre for details.';\n                return;\n            }\n            if (reply === 5) {\n                this.loginMessage0 = 'Your account is already logged in.';\n                this.loginMessage1 = 'Try again in 60 secs...';\n                return;\n            }\n            if (reply === 6) {\n                this.loginMessage0 = 'RuneScape has been updated!';\n                this.loginMessage1 = 'Please reload this page.';\n                return;\n            }\n            if (reply === 7) {\n                this.loginMessage0 = 'This world is full.';\n                this.loginMessage1 = 'Please use a different world.';\n                return;\n            }\n            if (reply === 8) {\n                this.loginMessage0 = 'Unable to connect.';\n                this.loginMessage1 = 'Login server offline.';\n                return;\n            }\n            if (reply === 9) {\n                this.loginMessage0 = 'Login limit exceeded.';\n                this.loginMessage1 = 'Too many connections from your address.';\n                return;\n            }\n            if (reply === 10) {\n                this.loginMessage0 = 'Unable to connect.';\n                this.loginMessage1 = 'Bad session id.';\n                return;\n            }\n            if (reply === 11) {\n                this.loginMessage1 = 'Login server rejected session.';\n                this.loginMessage1 = 'Please try again.';\n                return;\n            }\n            if (reply === 12) {\n                this.loginMessage0 = 'You need a members account to login to this world.';\n                this.loginMessage1 = 'Please subscribe, or use a different world.';\n                return;\n            }\n            if (reply === 13) {\n                this.loginMessage0 = 'Could not complete login.';\n                this.loginMessage1 = 'Please try using a different world.';\n                return;\n            }\n            if (reply === 14) {\n                this.loginMessage0 = 'The server is being updated.';\n                this.loginMessage1 = 'Please wait 1 minute and try again.';\n                return;\n            }\n            if (reply === 15) {\n                this.ingame = true;\n                this.out.pos = 0;\n                this.in.pos = 0;\n                this.packetType = -1;\n                this.lastPacketType0 = -1;\n                this.lastPacketType1 = -1;\n                this.lastPacketType2 = -1;\n                this.packetSize = 0;\n                this.idleNetCycles = 0;\n                this.systemUpdateTimer = 0;\n                this.menuSize = 0;\n                this.menuVisible = false;\n                return;\n            }\n            if (reply === 16) {\n                this.loginMessage0 = 'Login attempts exceeded.';\n                this.loginMessage1 = 'Please wait 1 minute and try again.';\n                return;\n            }\n            if (reply === 17) {\n                this.loginMessage0 = 'You are standing in a members-only area.';\n                this.loginMessage1 = 'To play on this world move to a free area first';\n            }\n        }\n        catch (err) {\n            console.log(err);\n            this.loginMessage0 = '';\n            this.loginMessage1 = 'Error connecting to server.';\n        }\n    };\n    updateGame = async () => {\n        if (this.players === null) {\n            // client is unloading asynchronously\n            return;\n        }\n        if (this.systemUpdateTimer > 1) {\n            this.systemUpdateTimer--;\n        }\n        if (this.idleTimeout > 0) {\n            this.idleTimeout--;\n        }\n        for (let i = 0; i < 5 && (await this.read()); i++) {\n            /* empty */\n        }\n        if (this.ingame) {\n            for (let wave = 0; wave < this.waveCount; wave++) {\n                if (this.waveDelay[wave] <= 0) {\n                    try {\n                        // if (this.waveIds[wave] !== this.lastWaveId || this.waveLoops[wave] !== this.lastWaveLoops) {\n                        // todo: reuse buffer?\n                        const buf = _jagex2_sound_Wave__WEBPACK_IMPORTED_MODULE_25__[\"default\"].generate(this.waveIds[wave], this.waveLoops[wave]);\n                        if (!buf) {\n                            throw new Error();\n                        }\n                        if (Date.now() + ((buf.pos / 22) | 0) > this.lastWaveStartTime + ((this.lastWaveLength / 22) | 0)) {\n                            this.lastWaveLength = buf.pos;\n                            this.lastWaveStartTime = Date.now();\n                            this.lastWaveId = this.waveIds[wave];\n                            this.lastWaveLoops = this.waveLoops[wave];\n                            await (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.playWave)(buf.data.slice(0, buf.pos), this.waveVolume);\n                        }\n                        // else if (!this.waveReplay()) { // this logic just re-plays the old buffer\n                    }\n                    catch (e) {\n                        console.error(e);\n                        /* empty */\n                    }\n                    // remove current wave\n                    this.waveCount--;\n                    for (let i = wave; i < this.waveCount; i++) {\n                        this.waveIds[i] = this.waveIds[i + 1];\n                        this.waveLoops[i] = this.waveLoops[i + 1];\n                        this.waveDelay[i] = this.waveDelay[i + 1];\n                    }\n                    wave--;\n                }\n                else {\n                    this.waveDelay[wave]--;\n                }\n            }\n            if (this.nextMusicDelay > 0) {\n                this.nextMusicDelay -= 20;\n                if (this.nextMusicDelay < 0) {\n                    this.nextMusicDelay = 0;\n                }\n                if (this.nextMusicDelay === 0 && this.midiActive && !_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory && this.currentMidi) {\n                    await this.setMidi(this.currentMidi, this.midiCrc, this.midiSize);\n                }\n            }\n            const tracking = _jagex2_client_InputTracking__WEBPACK_IMPORTED_MODULE_30__[\"default\"].flush();\n            if (tracking) {\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].EVENT_TRACKING);\n                this.out.p2(tracking.pos);\n                this.out.pdata(tracking.data, tracking.pos, 0);\n                tracking.release();\n            }\n            this.idleNetCycles++;\n            if (this.idleNetCycles > 750) {\n                await this.tryReconnect();\n            }\n            this.updatePlayers();\n            this.updateNpcs();\n            this.updateEntityChats();\n            this.updateTemporaryLocs();\n            if ((this.actionKey[1] === 1 || this.actionKey[2] === 1 || this.actionKey[3] === 1 || this.actionKey[4] === 1) && this.cameraMovedWrite++ > 5) {\n                this.cameraMovedWrite = 0;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].EVENT_CAMERA_POSITION);\n                this.out.p2(this.orbitCameraPitch);\n                this.out.p2(this.orbitCameraYaw);\n                this.out.p1(this.minimapAnticheatAngle);\n                this.out.p1(this.minimapZoom);\n            }\n            this.sceneDelta++;\n            if (this.crossMode !== 0) {\n                this.crossCycle += 20;\n                if (this.crossCycle >= 400) {\n                    this.crossMode = 0;\n                }\n            }\n            if (this.selectedArea !== 0) {\n                this.selectedCycle++;\n                if (this.selectedCycle >= 15) {\n                    if (this.selectedArea === 2) {\n                        this.redrawSidebar = true;\n                    }\n                    if (this.selectedArea === 3) {\n                        this.redrawChatback = true;\n                    }\n                    this.selectedArea = 0;\n                }\n            }\n            if (this.objDragArea !== 0) {\n                this.objDragCycles++;\n                if (this.mouseX > this.objGrabX + 5 || this.mouseX < this.objGrabX - 5 || this.mouseY > this.objGrabY + 5 || this.mouseY < this.objGrabY - 5) {\n                    this.objGrabThreshold = true;\n                }\n                if (this.mouseButton === 0) {\n                    if (this.objDragArea === 2) {\n                        this.redrawSidebar = true;\n                    }\n                    if (this.objDragArea === 3) {\n                        this.redrawChatback = true;\n                    }\n                    this.objDragArea = 0;\n                    if (this.objGrabThreshold && this.objDragCycles >= 5) {\n                        this.hoveredSlotParentId = -1;\n                        this.handleInput();\n                        if (this.hoveredSlotParentId === this.objDragInterfaceId && this.hoveredSlot !== this.objDragSlot) {\n                            const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.objDragInterfaceId];\n                            if (com.invSlotObjId) {\n                                const obj = com.invSlotObjId[this.hoveredSlot];\n                                com.invSlotObjId[this.hoveredSlot] = com.invSlotObjId[this.objDragSlot];\n                                com.invSlotObjId[this.objDragSlot] = obj;\n                            }\n                            if (com.invSlotObjCount) {\n                                const count = com.invSlotObjCount[this.hoveredSlot];\n                                com.invSlotObjCount[this.hoveredSlot] = com.invSlotObjCount[this.objDragSlot];\n                                com.invSlotObjCount[this.objDragSlot] = count;\n                            }\n                            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].INV_BUTTOND);\n                            this.out.p2(this.objDragInterfaceId);\n                            this.out.p2(this.objDragSlot);\n                            this.out.p2(this.hoveredSlot);\n                        }\n                    }\n                    else if ((this.mouseButtonsOption === 1 || this.isAddFriendOption(this.menuSize - 1)) && this.menuSize > 2) {\n                        this.showContextMenu();\n                    }\n                    else if (this.menuSize > 0) {\n                        await this.useMenuOption(this.menuSize - 1);\n                    }\n                    this.selectedCycle = 10;\n                    this.mouseClickButton = 0;\n                }\n            }\n            _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic3++;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic3 > 127) {\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic3 = 0;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_CYCLELOGIC3);\n                this.out.p3(4991788);\n            }\n            if (_jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileX !== -1) {\n                if (this.localPlayer) {\n                    const x = _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileX;\n                    const z = _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileZ;\n                    const success = this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], x, z, 0, 0, 0, 0, 0, 0, true);\n                    _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileX = -1;\n                    if (success) {\n                        this.crossX = this.mouseClickX;\n                        this.crossY = this.mouseClickY;\n                        this.crossMode = 1;\n                        this.crossCycle = 0;\n                    }\n                }\n            }\n            if (this.mouseClickButton === 1 && this.modalMessage) {\n                this.modalMessage = null;\n                this.redrawChatback = true;\n                this.mouseClickButton = 0;\n            }\n            await this.handleMouseInput(); // this is because of varps that set midi that we have to wait...\n            this.handleMinimapInput();\n            this.handleTabInput();\n            this.handleChatSettingsInput();\n            if (this.mouseButton === 1 || this.mouseClickButton === 1) {\n                this.dragCycles++;\n            }\n            if (this.sceneState === 2) {\n                if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cameraEditor) {\n                    this.updateCameraEditor();\n                }\n                else {\n                    this.updateOrbitCamera();\n                }\n            }\n            if (this.sceneState === 2 && this.cutscene) {\n                this.applyCutscene();\n            }\n            for (let i = 0; i < 5; i++) {\n                this.cameraModifierCycle[i]++;\n            }\n            await this.handleInputKey();\n            this.idleCycles++;\n            if (this.idleCycles > 4500) {\n                this.idleTimeout = 250;\n                this.idleCycles -= 500;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].IDLE_TIMER);\n            }\n            this.cameraOffsetCycle++;\n            if (this.cameraOffsetCycle > 500) {\n                this.cameraOffsetCycle = 0;\n                const rand = (Math.random() * 8.0) | 0;\n                if ((rand & 0x1) === 1) {\n                    this.cameraAnticheatOffsetX += this.cameraOffsetXModifier;\n                }\n                if ((rand & 0x2) === 2) {\n                    this.cameraAnticheatOffsetZ += this.cameraOffsetZModifier;\n                }\n                if ((rand & 0x4) === 4) {\n                    this.cameraAnticheatAngle += this.cameraOffsetYawModifier;\n                }\n            }\n            if (this.cameraAnticheatOffsetX < -50) {\n                this.cameraOffsetXModifier = 2;\n            }\n            if (this.cameraAnticheatOffsetX > 50) {\n                this.cameraOffsetXModifier = -2;\n            }\n            if (this.cameraAnticheatOffsetZ < -55) {\n                this.cameraOffsetZModifier = 2;\n            }\n            if (this.cameraAnticheatOffsetZ > 55) {\n                this.cameraOffsetZModifier = -2;\n            }\n            if (this.cameraAnticheatAngle < -40) {\n                this.cameraOffsetYawModifier = 1;\n            }\n            if (this.cameraAnticheatAngle > 40) {\n                this.cameraOffsetYawModifier = -1;\n            }\n            this.minimapOffsetCycle++;\n            if (this.minimapOffsetCycle > 500) {\n                this.minimapOffsetCycle = 0;\n                const rand = (Math.random() * 8.0) | 0;\n                if ((rand & 0x1) === 1) {\n                    this.minimapAnticheatAngle += this.minimapAngleModifier;\n                }\n                if ((rand & 0x2) === 2) {\n                    this.minimapZoom += this.minimapZoomModifier;\n                }\n            }\n            if (this.minimapAnticheatAngle < -60) {\n                this.minimapAngleModifier = 2;\n            }\n            if (this.minimapAnticheatAngle > 60) {\n                this.minimapAngleModifier = -2;\n            }\n            if (this.minimapZoom < -20) {\n                this.minimapZoomModifier = 1;\n            }\n            if (this.minimapZoom > 10) {\n                this.minimapZoomModifier = -1;\n            }\n            _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic4++;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic4 > 110) {\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic4 = 0;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_CYCLELOGIC4);\n                this.out.p4(0);\n            }\n            this.heartbeatTimer++;\n            if (this.heartbeatTimer > 50) {\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].NO_TIMEOUT);\n            }\n            try {\n                if (this.stream && this.out.pos > 0) {\n                    this.stream.write(this.out.data, this.out.pos);\n                    this.out.pos = 0;\n                    this.heartbeatTimer = 0;\n                }\n            }\n            catch (e) {\n                console.log(e);\n                await this.tryReconnect();\n                // TODO extra logic for logout??\n            }\n        }\n    };\n    drawGame = () => {\n        if (this.players === null) {\n            // client is unloading asynchronously\n            return;\n        }\n        if (this.redrawTitleBackground) {\n            this.redrawTitleBackground = false;\n            this.areaBackleft1?.draw(0, 11);\n            this.areaBackleft2?.draw(0, 375);\n            this.areaBackright1?.draw(729, 5);\n            this.areaBackright2?.draw(752, 231);\n            this.areaBacktop1?.draw(0, 0);\n            this.areaBacktop2?.draw(561, 0);\n            this.areaBackvmid1?.draw(520, 11);\n            this.areaBackvmid2?.draw(520, 231);\n            this.areaBackvmid3?.draw(501, 375);\n            this.areaBackhmid2?.draw(0, 345);\n            this.redrawSidebar = true;\n            this.redrawChatback = true;\n            this.redrawSideicons = true;\n            this.redrawPrivacySettings = true;\n            if (this.sceneState !== 2) {\n                this.areaViewport?.draw(8, 11);\n                this.areaMapback?.draw(561, 5);\n            }\n        }\n        if (this.sceneState === 2) {\n            this.drawScene();\n        }\n        if (this.menuVisible && this.menuArea === 1) {\n            this.redrawSidebar = true;\n        }\n        let redraw = false;\n        if (this.sidebarInterfaceId !== -1) {\n            redraw = this.updateInterfaceAnimation(this.sidebarInterfaceId, this.sceneDelta);\n            if (redraw) {\n                this.redrawSidebar = true;\n            }\n        }\n        if (this.selectedArea === 2) {\n            this.redrawSidebar = true;\n        }\n        if (this.objDragArea === 2) {\n            this.redrawSidebar = true;\n        }\n        if (this.redrawSidebar) {\n            this.drawSidebar();\n            this.redrawSidebar = false;\n        }\n        if (this.chatInterfaceId === -1) {\n            this.chatInterface.scrollPosition = this.chatScrollHeight - this.chatScrollOffset - 77;\n            if (this.mouseX > 453 && this.mouseX < 565 && this.mouseY > 350) {\n                this.handleScrollInput(this.mouseX - 22, this.mouseY - 375, this.chatScrollHeight, 77, false, 463, 0, this.chatInterface);\n            }\n            let offset = this.chatScrollHeight - this.chatInterface.scrollPosition - 77;\n            if (offset < 0) {\n                offset = 0;\n            }\n            if (offset > this.chatScrollHeight - 77) {\n                offset = this.chatScrollHeight - 77;\n            }\n            if (this.chatScrollOffset !== offset) {\n                this.chatScrollOffset = offset;\n                this.redrawChatback = true;\n            }\n        }\n        if (this.chatInterfaceId !== -1) {\n            redraw = this.updateInterfaceAnimation(this.chatInterfaceId, this.sceneDelta);\n            if (redraw) {\n                this.redrawChatback = true;\n            }\n        }\n        if (this.selectedArea === 3) {\n            this.redrawChatback = true;\n        }\n        if (this.objDragArea === 3) {\n            this.redrawChatback = true;\n        }\n        if (this.modalMessage) {\n            this.redrawChatback = true;\n        }\n        if (this.menuVisible && this.menuArea === 2) {\n            this.redrawChatback = true;\n        }\n        if (this.redrawChatback) {\n            this.drawChatback();\n            this.redrawChatback = false;\n        }\n        if (this.sceneState === 2) {\n            this.drawMinimap();\n            this.areaMapback?.draw(561, 5);\n        }\n        if (this.flashingTab !== -1) {\n            this.redrawSideicons = true;\n        }\n        if (this.redrawSideicons) {\n            if (this.flashingTab !== -1 && this.flashingTab === this.selectedTab) {\n                this.flashingTab = -1;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].TUTORIAL_CLICKSIDE);\n                this.out.p1(this.selectedTab);\n            }\n            this.redrawSideicons = false;\n            this.areaBackhmid1?.bind();\n            this.imageBackhmid1?.draw(0, 0);\n            if (this.sidebarInterfaceId === -1) {\n                if (this.tabInterfaceId[this.selectedTab] !== -1) {\n                    if (this.selectedTab === 0) {\n                        this.imageRedstone1?.draw(29, 30);\n                    }\n                    else if (this.selectedTab === 1) {\n                        this.imageRedstone2?.draw(59, 29);\n                    }\n                    else if (this.selectedTab === 2) {\n                        this.imageRedstone2?.draw(87, 29);\n                    }\n                    else if (this.selectedTab === 3) {\n                        this.imageRedstone3?.draw(115, 29);\n                    }\n                    else if (this.selectedTab === 4) {\n                        this.imageRedstone2h?.draw(156, 29);\n                    }\n                    else if (this.selectedTab === 5) {\n                        this.imageRedstone2h?.draw(184, 29);\n                    }\n                    else if (this.selectedTab === 6) {\n                        this.imageRedstone1h?.draw(212, 30);\n                    }\n                }\n                if (this.tabInterfaceId[0] !== -1 && (this.flashingTab !== 0 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[0]?.draw(35, 34);\n                }\n                if (this.tabInterfaceId[1] !== -1 && (this.flashingTab !== 1 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[1]?.draw(59, 32);\n                }\n                if (this.tabInterfaceId[2] !== -1 && (this.flashingTab !== 2 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[2]?.draw(86, 32);\n                }\n                if (this.tabInterfaceId[3] !== -1 && (this.flashingTab !== 3 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[3]?.draw(121, 33);\n                }\n                if (this.tabInterfaceId[4] !== -1 && (this.flashingTab !== 4 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[4]?.draw(157, 34);\n                }\n                if (this.tabInterfaceId[5] !== -1 && (this.flashingTab !== 5 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[5]?.draw(185, 32);\n                }\n                if (this.tabInterfaceId[6] !== -1 && (this.flashingTab !== 6 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[6]?.draw(212, 34);\n                }\n            }\n            this.areaBackhmid1?.draw(520, 165);\n            this.areaBackbase2?.bind();\n            this.imageBackbase2?.draw(0, 0);\n            if (this.sidebarInterfaceId === -1) {\n                if (this.tabInterfaceId[this.selectedTab] !== -1) {\n                    if (this.selectedTab === 7) {\n                        this.imageRedstone1v?.draw(49, 0);\n                    }\n                    else if (this.selectedTab === 8) {\n                        this.imageRedstone2v?.draw(81, 0);\n                    }\n                    else if (this.selectedTab === 9) {\n                        this.imageRedstone2v?.draw(108, 0);\n                    }\n                    else if (this.selectedTab === 10) {\n                        this.imageRedstone3v?.draw(136, 1);\n                    }\n                    else if (this.selectedTab === 11) {\n                        this.imageRedstone2hv?.draw(178, 0);\n                    }\n                    else if (this.selectedTab === 12) {\n                        this.imageRedstone2hv?.draw(205, 0);\n                    }\n                    else if (this.selectedTab === 13) {\n                        this.imageRedstone1hv?.draw(233, 0);\n                    }\n                }\n                if (this.tabInterfaceId[8] !== -1 && (this.flashingTab !== 8 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[7]?.draw(80, 2);\n                }\n                if (this.tabInterfaceId[9] !== -1 && (this.flashingTab !== 9 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[8]?.draw(107, 3);\n                }\n                if (this.tabInterfaceId[10] !== -1 && (this.flashingTab !== 10 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[9]?.draw(142, 4);\n                }\n                if (this.tabInterfaceId[11] !== -1 && (this.flashingTab !== 11 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[10]?.draw(179, 2);\n                }\n                if (this.tabInterfaceId[12] !== -1 && (this.flashingTab !== 12 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[11]?.draw(206, 2);\n                }\n                if (this.tabInterfaceId[13] !== -1 && (this.flashingTab !== 13 || this.loopCycle % 20 < 10)) {\n                    this.imageSideicons[12]?.draw(230, 2);\n                }\n            }\n            this.areaBackbase2?.draw(501, 492);\n            this.areaViewport?.bind();\n        }\n        if (this.redrawPrivacySettings) {\n            this.redrawPrivacySettings = false;\n            this.areaBackbase1?.bind();\n            this.imageBackbase1?.draw(0, 0);\n            this.fontPlain12?.drawStringTaggableCenter(57, 33, 'Public chat', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            if (this.publicChatSetting === 0) {\n                this.fontPlain12?.drawStringTaggableCenter(57, 46, 'On', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN, true);\n            }\n            if (this.publicChatSetting === 1) {\n                this.fontPlain12?.drawStringTaggableCenter(57, 46, 'Friends', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            }\n            if (this.publicChatSetting === 2) {\n                this.fontPlain12?.drawStringTaggableCenter(57, 46, 'Off', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED, true);\n            }\n            if (this.publicChatSetting === 3) {\n                this.fontPlain12?.drawStringTaggableCenter(57, 46, 'Hide', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].CYAN, true);\n            }\n            this.fontPlain12?.drawStringTaggableCenter(186, 33, 'Private chat', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            if (this.privateChatSetting === 0) {\n                this.fontPlain12?.drawStringTaggableCenter(186, 46, 'On', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN, true);\n            }\n            if (this.privateChatSetting === 1) {\n                this.fontPlain12?.drawStringTaggableCenter(186, 46, 'Friends', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            }\n            if (this.privateChatSetting === 2) {\n                this.fontPlain12?.drawStringTaggableCenter(186, 46, 'Off', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED, true);\n            }\n            this.fontPlain12?.drawStringTaggableCenter(326, 33, 'Trade/duel', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            if (this.tradeChatSetting === 0) {\n                this.fontPlain12?.drawStringTaggableCenter(326, 46, 'On', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN, true);\n            }\n            if (this.tradeChatSetting === 1) {\n                this.fontPlain12?.drawStringTaggableCenter(326, 46, 'Friends', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            }\n            if (this.tradeChatSetting === 2) {\n                this.fontPlain12?.drawStringTaggableCenter(326, 46, 'Off', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED, true);\n            }\n            this.fontPlain12?.drawStringTaggableCenter(462, 38, 'Report abuse', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true);\n            this.areaBackbase1?.draw(0, 471);\n            this.areaViewport?.bind();\n        }\n        this.sceneDelta = 0;\n    };\n    drawScene = () => {\n        this.sceneCycle++;\n        this.pushPlayers();\n        this.pushNpcs();\n        this.pushProjectiles();\n        this.pushSpotanims();\n        this.pushLocs();\n        if (!this.cutscene) {\n            let pitch = this.orbitCameraPitch;\n            if (((this.cameraPitchClamp / 256) | 0) > pitch) {\n                pitch = (this.cameraPitchClamp / 256) | 0;\n            }\n            if (this.cameraModifierEnabled[4] && this.cameraModifierWobbleScale[4] + 128 > pitch) {\n                pitch = this.cameraModifierWobbleScale[4] + 128;\n            }\n            const yaw = (this.orbitCameraYaw + this.cameraAnticheatAngle) & 0x7ff;\n            if (this.localPlayer) {\n                this.orbitCamera(this.orbitCameraX, this.getHeightmapY(this.currentLevel, this.localPlayer.x, this.localPlayer.z) - 50, this.orbitCameraZ, yaw, pitch, pitch * 3 + 600);\n            }\n            _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic2++;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic2 > 1802) {\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic2 = 0;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_CYCLELOGIC2);\n                this.out.p1(0);\n                const start = this.out.pos;\n                this.out.p2(29711);\n                this.out.p1(70);\n                this.out.p1((Math.random() * 256.0) | 0);\n                this.out.p1(242);\n                this.out.p1(186);\n                this.out.p1(39);\n                this.out.p1(61);\n                if (((Math.random() * 2.0) | 0) === 0) {\n                    this.out.p1(13);\n                }\n                if (((Math.random() * 2.0) | 0) === 0) {\n                    this.out.p2(57856);\n                }\n                this.out.p2((Math.random() * 65536.0) | 0);\n                this.out.psize1(this.out.pos - start);\n            }\n        }\n        let level;\n        if (this.cutscene) {\n            level = this.getTopLevelCutscene();\n        }\n        else {\n            level = this.getTopLevel();\n        }\n        const cameraX = this.cameraX;\n        const cameraY = this.cameraY;\n        const cameraZ = this.cameraZ;\n        const cameraPitch = this.cameraPitch;\n        const cameraYaw = this.cameraYaw;\n        let jitter;\n        for (let type = 0; type < 5; type++) {\n            if (this.cameraModifierEnabled[type]) {\n                jitter =\n                    (Math.random() * (this.cameraModifierJitter[type] * 2 + 1) - this.cameraModifierJitter[type] + Math.sin(this.cameraModifierCycle[type] * (this.cameraModifierWobbleSpeed[type] / 100.0)) * this.cameraModifierWobbleScale[type]) | 0;\n                if (type === 0) {\n                    this.cameraX += jitter;\n                }\n                if (type === 1) {\n                    this.cameraY += jitter;\n                }\n                if (type === 2) {\n                    this.cameraZ += jitter;\n                }\n                if (type === 3) {\n                    this.cameraYaw = (this.cameraYaw + jitter) & 0x7ff;\n                }\n                if (type === 4) {\n                    this.cameraPitch += jitter;\n                    if (this.cameraPitch < 128) {\n                        this.cameraPitch = 128;\n                    }\n                    if (this.cameraPitch > 383) {\n                        this.cameraPitch = 383;\n                    }\n                }\n            }\n        }\n        jitter = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].cycle;\n        _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].checkHover = true;\n        _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].pickedCount = 0;\n        _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].mouseX = this.mouseX - 8;\n        _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].mouseY = this.mouseY - 11;\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n        this.scene?.draw(this.cameraX, this.cameraY, this.cameraZ, level, this.cameraYaw, this.cameraPitch, this.loopCycle);\n        this.scene?.clearTemporaryLocs();\n        this.draw2DEntityElements();\n        this.drawTileHint();\n        if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug) {\n            this.drawDebug();\n        }\n        this.updateTextures(jitter);\n        this.draw3DEntityElements();\n        this.areaViewport?.draw(8, 11);\n        this.cameraX = cameraX;\n        this.cameraY = cameraY;\n        this.cameraZ = cameraZ;\n        this.cameraPitch = cameraPitch;\n        this.cameraYaw = cameraYaw;\n    };\n    clearCaches = () => {\n        _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelCacheStatic?.clear();\n        _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelCacheDynamic?.clear();\n        _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].modelCache?.clear();\n        _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].modelCache?.clear();\n        _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].iconCache?.clear();\n        _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].modelCache?.clear();\n        _jagex2_config_SpotAnimType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].modelCache?.clear();\n    };\n    projectFromEntity = (entity, height) => {\n        this.projectFromGround(entity.x, height, entity.z);\n    };\n    projectFromGround = (x, height, z) => {\n        if (x < 128 || z < 128 || x > 13056 || z > 13056) {\n            this.projectX = -1;\n            this.projectY = -1;\n            return;\n        }\n        const y = this.getHeightmapY(this.currentLevel, x, z) - height;\n        this.project(x, y, z);\n    };\n    project = (x, y, z) => {\n        let dx = x - this.cameraX;\n        let dy = y - this.cameraY;\n        let dz = z - this.cameraZ;\n        const sinPitch = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].sin[this.cameraPitch];\n        const cosPitch = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].cos[this.cameraPitch];\n        const sinYaw = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].sin[this.cameraYaw];\n        const cosYaw = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].cos[this.cameraYaw];\n        let tmp = (dz * sinYaw + dx * cosYaw) >> 16;\n        dz = (dz * cosYaw - dx * sinYaw) >> 16;\n        dx = tmp;\n        tmp = (dy * cosPitch - dz * sinPitch) >> 16;\n        dz = (dy * sinPitch + dz * cosPitch) >> 16;\n        dy = tmp;\n        if (dz >= 50) {\n            this.projectX = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].centerX + (((dx << 9) / dz) | 0);\n            this.projectY = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].centerY + (((dy << 9) / dz) | 0);\n        }\n        else {\n            this.projectX = -1;\n            this.projectY = -1;\n        }\n    };\n    draw2DEntityElements = () => {\n        this.chatCount = 0;\n        for (let index = -1; index < this.playerCount + this.npcCount; index++) {\n            let entity = null;\n            if (index === -1) {\n                entity = this.localPlayer;\n            }\n            else if (index < this.playerCount) {\n                entity = this.players[this.playerIds[index]];\n            }\n            else {\n                entity = this.npcs[this.npcIds[index - this.playerCount]];\n            }\n            if (!entity || !entity.isVisible()) {\n                continue;\n            }\n            if (index < this.playerCount) {\n                let y = 30;\n                const player = entity;\n                if (player.headicons !== 0) {\n                    this.projectFromEntity(entity, entity.height + 15);\n                    if (this.projectX > -1) {\n                        for (let icon = 0; icon < 8; icon++) {\n                            if ((player.headicons & (0x1 << icon)) !== 0) {\n                                this.imageHeadicons[icon]?.draw(this.projectX - 12, this.projectY - y);\n                                y -= 25;\n                            }\n                        }\n                    }\n                }\n                if (index >= 0 && this.hintType === 10 && this.hintPlayer === this.playerIds[index]) {\n                    this.projectFromEntity(entity, entity.height + 15);\n                    if (this.projectX > -1) {\n                        this.imageHeadicons[7]?.draw(this.projectX - 12, this.projectY - y);\n                    }\n                }\n            }\n            else if (this.hintType === 1 && this.hintNpc === this.npcIds[index - this.playerCount] && this.loopCycle % 20 < 10) {\n                this.projectFromEntity(entity, entity.height + 15);\n                if (this.projectX > -1) {\n                    this.imageHeadicons[2]?.draw(this.projectX - 12, this.projectY - 28);\n                }\n            }\n            if (entity.chat && (index >= this.playerCount || this.publicChatSetting === 0 || this.publicChatSetting === 3 || (this.publicChatSetting === 1 && this.isFriend(entity.name)))) {\n                this.projectFromEntity(entity, entity.height);\n                if (this.projectX > -1 && this.chatCount < _client__WEBPACK_IMPORTED_MODULE_49__.Client.MAX_CHATS && this.fontBold12) {\n                    this.chatWidth[this.chatCount] = (this.fontBold12.stringWidth(entity.chat) / 2) | 0;\n                    this.chatHeight[this.chatCount] = this.fontBold12.height;\n                    this.chatX[this.chatCount] = this.projectX;\n                    this.chatY[this.chatCount] = this.projectY;\n                    this.chatColors[this.chatCount] = entity.chatColor;\n                    this.chatStyles[this.chatCount] = entity.chatStyle;\n                    this.chatTimers[this.chatCount] = entity.chatTimer;\n                    this.chats[this.chatCount++] = entity.chat;\n                    if (this.chatEffects === 0 && entity.chatStyle === 1) {\n                        this.chatHeight[this.chatCount] += 10;\n                        this.chatY[this.chatCount] += 5;\n                    }\n                    if (this.chatEffects === 0 && entity.chatStyle === 2) {\n                        this.chatWidth[this.chatCount] = 60;\n                    }\n                }\n            }\n            if (entity.combatCycle > this.loopCycle + 100) {\n                this.projectFromEntity(entity, entity.height + 15);\n                if (this.projectX > -1) {\n                    let w = ((entity.health * 30) / entity.totalHealth) | 0;\n                    if (w > 30) {\n                        w = 30;\n                    }\n                    _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fillRect(this.projectX - 15, this.projectY - 3, w, 5, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN);\n                    _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fillRect(this.projectX - 15 + w, this.projectY - 3, 30 - w, 5, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED);\n                }\n            }\n            if (entity.combatCycle > this.loopCycle + 330) {\n                this.projectFromEntity(entity, (entity.height / 2) | 0);\n                if (this.projectX > -1) {\n                    this.imageHitmarks[entity.damageType]?.draw(this.projectX - 12, this.projectY - 12);\n                    this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + 4, entity.damage.toString(), _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                    this.fontPlain11?.drawStringCenter(this.projectX - 1, this.projectY + 3, entity.damage.toString(), _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                }\n            }\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug) {\n                // true tile overlay\n                if (entity.pathLength > 0 || entity.forceMoveEndCycle >= this.loopCycle || entity.forceMoveStartCycle > this.loopCycle) {\n                    const halfUnit = 64 * entity.size;\n                    this.debugDrawTileOverlay(entity.pathTileX[0] * 128 + halfUnit, entity.pathTileZ[0] * 128 + halfUnit, this.currentLevel, entity.size, 0x00ffff, false);\n                }\n                // local tile overlay\n                this.debugDrawTileOverlay(entity.x, entity.z, this.currentLevel, entity.size, 0x666666, false);\n                let offsetY = 0;\n                this.projectFromEntity(entity, entity.height + 30);\n                if (index < this.playerCount) {\n                    const player = entity;\n                    this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, player.name, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                    offsetY -= 15;\n                    if (player.lastMask !== -1 && this.loopCycle - player.lastMaskCycle < 30) {\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].APPEARANCE) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].APPEARANCE) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Appearance Update', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].ANIM) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].ANIM) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Play Seq: ' + player.primarySeqId, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_ENTITY) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_ENTITY) {\n                            let target = player.targetId;\n                            if (target > 32767) {\n                                target -= 32768;\n                            }\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Face Entity: ' + target, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SAY) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SAY) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Say', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].DAMAGE) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].DAMAGE) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Hit: Type ' + player.damageType + ' Amount ' + player.damage + ' HP ' + player.health + '/' + player.totalHealth, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_COORD) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_COORD) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Face Coord: ' + player.lastFaceX / 2 + ' ' + player.lastFaceZ / 2, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].CHAT) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].CHAT) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Chat', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SPOTANIM) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SPOTANIM) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Play Spotanim: ' + player.spotanimId, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((player.lastMask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].EXACT_MOVE) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].EXACT_MOVE) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Exact Move', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                    }\n                }\n                else {\n                    // npc\n                    const npc = entity;\n                    let offsetY = 0;\n                    this.projectFromEntity(entity, entity.height + 30);\n                    this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, npc.type?.name ?? null, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                    offsetY -= 15;\n                    if (npc.lastMask !== -1 && this.loopCycle - npc.lastMaskCycle < 30) {\n                        if ((npc.lastMask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].ANIM) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].ANIM) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Play Seq: ' + npc.primarySeqId, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((npc.lastMask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_ENTITY) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_ENTITY) {\n                            let target = npc.targetId;\n                            if (target > 32767) {\n                                target -= 32768;\n                            }\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Face Entity: ' + target, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((npc.lastMask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SAY) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SAY) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Say', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((npc.lastMask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].DAMAGE) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].DAMAGE) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Hit: Type ' + npc.damageType + ' Amount ' + npc.damage + ' HP ' + npc.health + '/' + npc.totalHealth, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((npc.lastMask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].CHANGE_TYPE) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].CHANGE_TYPE) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Change Type: ' + npc.type?.id ?? null, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((npc.lastMask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SPOTANIM) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SPOTANIM) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Play Spotanim: ' + npc.spotanimId, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                        if ((npc.lastMask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_COORD) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_COORD) {\n                            this.fontPlain11?.drawStringCenter(this.projectX, this.projectY + offsetY, 'Face Coord: ' + npc.lastFaceX / 2 + ' ' + npc.lastFaceZ / 2, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                            offsetY -= 15;\n                        }\n                    }\n                }\n            }\n        }\n        if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug) {\n            for (let i = 0; i < this.userTileMarkers.length; i++) {\n                const marker = this.userTileMarkers[i];\n                if (!marker || marker.level !== this.currentLevel || marker.x < 0 || marker.z < 0 || marker.x >= 104 || marker.z >= 104) {\n                    continue;\n                }\n                this.debugDrawTileOverlay(marker.x * 128 + 64, marker.z * 128 + 64, marker.level, 1, 0xffff00, false);\n            }\n        }\n        for (let i = 0; i < this.chatCount; i++) {\n            const x = this.chatX[i];\n            let y = this.chatY[i];\n            const padding = this.chatWidth[i];\n            const height = this.chatHeight[i];\n            let sorting = true;\n            while (sorting) {\n                sorting = false;\n                for (let j = 0; j < i; j++) {\n                    if (y + 2 > this.chatY[j] - this.chatHeight[j] && y - height < this.chatY[j] + 2 && x - padding < this.chatX[j] + this.chatWidth[j] && x + padding > this.chatX[j] - this.chatWidth[j] && this.chatY[j] - this.chatHeight[j] < y) {\n                        y = this.chatY[j] - this.chatHeight[j];\n                        sorting = true;\n                    }\n                }\n            }\n            this.projectX = this.chatX[i];\n            this.projectY = this.chatY[i] = y;\n            const message = this.chats[i];\n            if (this.chatEffects === 0) {\n                let color = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW;\n                if (this.chatColors[i] < 6) {\n                    color = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].CHAT_COLORS[this.chatColors[i]];\n                }\n                if (this.chatColors[i] === 6) {\n                    color = this.sceneCycle % 20 < 10 ? _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED : _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW;\n                }\n                if (this.chatColors[i] === 7) {\n                    color = this.sceneCycle % 20 < 10 ? _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLUE : _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].CYAN;\n                }\n                if (this.chatColors[i] === 8) {\n                    color = this.sceneCycle % 20 < 10 ? 0xb000 : 0x80ff80;\n                }\n                if (this.chatColors[i] === 9) {\n                    const delta = 150 - this.chatTimers[i];\n                    if (delta < 50) {\n                        color = delta * 1280 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED;\n                    }\n                    else if (delta < 100) {\n                        color = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW - (delta - 50) * 327680;\n                    }\n                    else if (delta < 150) {\n                        color = (delta - 100) * 5 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN;\n                    }\n                }\n                if (this.chatColors[i] === 10) {\n                    const delta = 150 - this.chatTimers[i];\n                    if (delta < 50) {\n                        color = delta * 5 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].RED;\n                    }\n                    else if (delta < 100) {\n                        color = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].MAGENTA - (delta - 50) * 327680;\n                    }\n                    else if (delta < 150) {\n                        color = (delta - 100) * 327680 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLUE - (delta - 100) * 5;\n                    }\n                }\n                if (this.chatColors[i] === 11) {\n                    const delta = 150 - this.chatTimers[i];\n                    if (delta < 50) {\n                        color = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE - delta * 327685;\n                    }\n                    else if (delta < 100) {\n                        color = (delta - 50) * 327685 + _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].GREEN;\n                    }\n                    else if (delta < 150) {\n                        color = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE - (delta - 100) * 327680;\n                    }\n                }\n                if (this.chatStyles[i] === 0) {\n                    this.fontBold12?.drawStringCenter(this.projectX, this.projectY + 1, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                    this.fontBold12?.drawStringCenter(this.projectX, this.projectY, message, color);\n                }\n                if (this.chatStyles[i] === 1) {\n                    this.fontBold12?.drawCenteredWave(this.projectX, this.projectY + 1, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK, this.sceneCycle);\n                    this.fontBold12?.drawCenteredWave(this.projectX, this.projectY, message, color, this.sceneCycle);\n                }\n                if (this.chatStyles[i] === 2) {\n                    const w = this.fontBold12?.stringWidth(message) ?? 0;\n                    const offsetX = ((150 - this.chatTimers[i]) * (w + 100)) / 150;\n                    _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].setBounds(334, this.projectX + 50, 0, this.projectX - 50);\n                    this.fontBold12?.drawString(this.projectX + 50 - offsetX, this.projectY + 1, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                    this.fontBold12?.drawString(this.projectX + 50 - offsetX, this.projectY, message, color);\n                    _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].resetBounds();\n                }\n            }\n            else {\n                this.fontBold12?.drawStringCenter(this.projectX, this.projectY + 1, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                this.fontBold12?.drawStringCenter(this.projectX, this.projectY, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW);\n            }\n        }\n    };\n    drawTileHint = () => {\n        if (this.hintType !== 2 || !this.imageHeadicons[2]) {\n            return;\n        }\n        this.projectFromGround(((this.hintTileX - this.sceneBaseTileX) << 7) + this.hintOffsetX, this.hintHeight * 2, ((this.hintTileZ - this.sceneBaseTileZ) << 7) + this.hintOffsetZ);\n        if (this.projectX > -1 && this.loopCycle % 20 < 10) {\n            this.imageHeadicons[2].draw(this.projectX - 12, this.projectY - 28);\n        }\n    };\n    drawDebug = () => {\n        // all of this is basically custom code\n        const x = 507;\n        let y = 13;\n        if (this.lastTickFlag) {\n            this.fontPlain11?.drawStringRight(x, y, 'tock', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        }\n        else {\n            this.fontBold12?.drawStringRight(x, y, 'tick', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        }\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, `Fps: ${this.fps}, ${this.deltime} ms`, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, `Draw: ${this.ms.toFixed(1)}, Avg: ${this.msAvg.toFixed(1)}, Slow: ${this.slowestMS.toFixed(1)} ms`, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, `Occluders: ${_jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].levelOccluderCount[_jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].topLevel]} Active: ${_jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].activeOccluderCount}`, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, 'Local Pos: ' + (this.localPlayer?.x ?? -1) + ', ' + (this.localPlayer?.z ?? -1) + ', ' + (this.localPlayer?.y ?? -1), _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, 'Camera Pos: ' + this.cameraX + ', ' + this.cameraZ + ', ' + this.cameraY, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, 'Camera Angle: ' + this.cameraYaw + ', ' + this.cameraPitch, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, 'Cutscene Source: ' + this.cutsceneSrcLocalTileX + ', ' + this.cutsceneSrcLocalTileZ + ' ' + this.cutsceneSrcHeight + '; ' + this.cutsceneMoveSpeed + ', ' + this.cutsceneMoveAcceleration, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        y += 13;\n        this.fontPlain11?.drawStringRight(x, y, 'Cutscene Destination: ' + this.cutsceneDstLocalTileX + ', ' + this.cutsceneDstLocalTileZ + ' ' + this.cutsceneDstHeight + '; ' + this.cutsceneRotateSpeed + ', ' + this.cutsceneRotateAcceleration, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cameraEditor) {\n            y += 13;\n            this.fontPlain11?.drawStringRight(x, y, 'Instructions:', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            y += 13;\n            this.fontPlain11?.drawStringRight(x, y, '- Arrows to move Camera', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            y += 13;\n            this.fontPlain11?.drawStringRight(x, y, '- Shift to control Source or Dest', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            y += 13;\n            this.fontPlain11?.drawStringRight(x, y, '- Alt to control Height', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n            y += 13;\n            this.fontPlain11?.drawStringRight(x, y, '- Ctrl to control Modifier', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW, true);\n        }\n    };\n    debugDrawTileOverlay = (x, z, level, size, color, crossed) => {\n        const height = this.getHeightmapY(level, x, z);\n        // x/z should be the center of a tile which is 128 client-units large, so +/- 64 puts us at the edges\n        const halfUnit = 64 * size;\n        this.project(x - halfUnit, height, z - halfUnit);\n        const x0 = this.projectX;\n        const y0 = this.projectY;\n        this.project(x + halfUnit, height, z - halfUnit);\n        const x1 = this.projectX;\n        const y1 = this.projectY;\n        this.project(x - halfUnit, height, z + halfUnit);\n        const x2 = this.projectX;\n        const y2 = this.projectY;\n        this.project(x + halfUnit, height, z + halfUnit);\n        const x3 = this.projectX;\n        const y3 = this.projectY;\n        // one of our points failed to project\n        if (x0 === -1 || x1 === -1 || x2 === -1 || x3 === -1) {\n            return;\n        }\n        if (crossed) {\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawLine(x0, y0, x3, y3, (color & 0xfefefe) >> 1);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawLine(x1, y1, x2, y2, (color & 0xfefefe) >> 1);\n        }\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawLine(x0, y0, x1, y1, color);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawLine(x0, y0, x2, y2, color);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawLine(x1, y1, x3, y3, color);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawLine(x2, y2, x3, y3, color);\n    };\n    updateCameraEditor() {\n        // holding ctrl\n        const modifier = this.actionKey[5] == 1 ? 2 : 1;\n        if (this.actionKey[6] == 1) {\n            // holding shift\n            if (this.actionKey[1] == 1) {\n                // left\n                this.cutsceneDstLocalTileX -= modifier;\n                if (this.cutsceneDstLocalTileX < 1) {\n                    this.cutsceneDstLocalTileX = 1;\n                }\n            }\n            else if (this.actionKey[2] == 1) {\n                // right\n                this.cutsceneDstLocalTileX += modifier;\n                if (this.cutsceneDstLocalTileX > 102) {\n                    this.cutsceneDstLocalTileX = 102;\n                }\n            }\n            if (this.actionKey[3] == 1) {\n                // up\n                if (this.actionKey[7] == 1) {\n                    // holding alt\n                    this.cutsceneDstHeight += 2 * modifier;\n                }\n                else {\n                    this.cutsceneDstLocalTileZ += 1;\n                    if (this.cutsceneDstLocalTileZ > 102) {\n                        this.cutsceneDstLocalTileZ = 102;\n                    }\n                }\n            }\n            else if (this.actionKey[4] == 1) {\n                // down\n                if (this.actionKey[7] == 1) {\n                    // holding alt\n                    this.cutsceneDstHeight -= 2 * modifier;\n                }\n                else {\n                    this.cutsceneDstLocalTileZ -= 1;\n                    if (this.cutsceneDstLocalTileZ < 1) {\n                        this.cutsceneDstLocalTileZ = 1;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.actionKey[1] == 1) {\n                // left\n                this.cutsceneSrcLocalTileX -= modifier;\n                if (this.cutsceneSrcLocalTileX < 1) {\n                    this.cutsceneSrcLocalTileX = 1;\n                }\n            }\n            else if (this.actionKey[2] == 1) {\n                // right\n                this.cutsceneSrcLocalTileX += modifier;\n                if (this.cutsceneSrcLocalTileX > 102) {\n                    this.cutsceneSrcLocalTileX = 102;\n                }\n            }\n            if (this.actionKey[3] == 1) {\n                // up\n                if (this.actionKey[7] == 1) {\n                    // holding alt\n                    this.cutsceneSrcHeight += 2 * modifier;\n                }\n                else {\n                    this.cutsceneSrcLocalTileZ += modifier;\n                    if (this.cutsceneSrcLocalTileZ > 102) {\n                        this.cutsceneSrcLocalTileZ = 102;\n                    }\n                }\n            }\n            else if (this.actionKey[4] == 1) {\n                // down\n                if (this.actionKey[7] == 1) {\n                    // holding alt\n                    this.cutsceneSrcHeight -= 2 * modifier;\n                }\n                else {\n                    this.cutsceneSrcLocalTileZ -= modifier;\n                    if (this.cutsceneSrcLocalTileZ < 1) {\n                        this.cutsceneSrcLocalTileZ = 1;\n                    }\n                }\n            }\n        }\n        this.cameraX = this.cutsceneSrcLocalTileX * 128 + 64;\n        this.cameraZ = this.cutsceneSrcLocalTileZ * 128 + 64;\n        this.cameraY = this.getHeightmapY(this.currentLevel, this.cutsceneSrcLocalTileX, this.cutsceneSrcLocalTileZ) - this.cutsceneSrcHeight;\n        const sceneX = this.cutsceneDstLocalTileX * 128 + 64;\n        const sceneZ = this.cutsceneDstLocalTileZ * 128 + 64;\n        const sceneY = this.getHeightmapY(this.currentLevel, this.cutsceneDstLocalTileX, this.cutsceneDstLocalTileZ) - this.cutsceneDstHeight;\n        const deltaX = sceneX - this.cameraX;\n        const deltaY = sceneY - this.cameraY;\n        const deltaZ = sceneZ - this.cameraZ;\n        const distance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ) | 0;\n        this.cameraPitch = ((Math.atan2(deltaY, distance) * 325.949) | 0) & 0x7ff;\n        this.cameraYaw = ((Math.atan2(deltaX, deltaZ) * -325.949) | 0) & 0x7ff;\n        if (this.cameraPitch < 128) {\n            this.cameraPitch = 128;\n        }\n        if (this.cameraPitch > 383) {\n            this.cameraPitch = 383;\n        }\n    }\n    draw3DEntityElements = () => {\n        this.drawPrivateMessages();\n        if (this.crossMode === 1) {\n            this.imageCrosses[(this.crossCycle / 100) | 0]?.draw(this.crossX - 8 - 8, this.crossY - 8 - 11);\n        }\n        if (this.crossMode === 2) {\n            this.imageCrosses[((this.crossCycle / 100) | 0) + 4]?.draw(this.crossX - 8 - 8, this.crossY - 8 - 11);\n        }\n        if (this.viewportInterfaceId !== -1) {\n            this.updateInterfaceAnimation(this.viewportInterfaceId, this.sceneDelta);\n            this.drawInterface(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.viewportInterfaceId], 0, 0, 0);\n        }\n        this.drawWildyLevel();\n        if (!this.menuVisible) {\n            this.handleInput();\n            this.drawTooltip();\n        }\n        else if (this.menuArea === 0) {\n            this.drawMenu();\n        }\n        if (this.inMultizone === 1) {\n            if (this.wildernessLevel > 0 || this.worldLocationState === 1) {\n                this.imageHeadicons[1]?.draw(472, 258);\n            }\n            else {\n                this.imageHeadicons[1]?.draw(472, 296);\n            }\n        }\n        if (this.wildernessLevel > 0) {\n            this.imageHeadicons[0]?.draw(472, 296);\n            this.fontPlain12?.drawStringCenter(484, 329, 'Level: ' + this.wildernessLevel, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW);\n        }\n        if (this.worldLocationState === 1) {\n            this.imageHeadicons[6]?.draw(472, 296);\n            this.fontPlain12?.drawStringCenter(484, 329, 'Arena', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW);\n        }\n        if (this.systemUpdateTimer !== 0) {\n            let seconds = (this.systemUpdateTimer / 50) | 0;\n            const minutes = (seconds / 60) | 0;\n            seconds %= 60;\n            if (seconds < 10) {\n                this.fontPlain12?.drawString(4, 329, 'System update in: ' + minutes + ':0' + seconds, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW);\n            }\n            else {\n                this.fontPlain12?.drawString(4, 329, 'System update in: ' + minutes + ':' + seconds, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW);\n            }\n        }\n    };\n    drawPrivateMessages = () => {\n        if (this.splitPrivateChat === 0) {\n            return;\n        }\n        const font = this.fontPlain12;\n        let lineOffset = 0;\n        if (this.systemUpdateTimer !== 0) {\n            lineOffset = 1;\n        }\n        for (let i = 0; i < 100; i++) {\n            if (!this.messageText[i]) {\n                continue;\n            }\n            const type = this.messageType[i];\n            let y;\n            if ((type === 3 || type === 7) && (type === 7 || this.privateChatSetting === 0 || (this.privateChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                y = 329 - lineOffset * 13;\n                font?.drawString(4, y, 'From ' + this.messageSender[i] + ': ' + this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                font?.drawString(4, y - 1, 'From ' + this.messageSender[i] + ': ' + this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].CYAN);\n                lineOffset++;\n                if (lineOffset >= 5) {\n                    return;\n                }\n            }\n            if (type === 5 && this.privateChatSetting < 2) {\n                y = 329 - lineOffset * 13;\n                font?.drawString(4, y, this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                font?.drawString(4, y - 1, this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].CYAN);\n                lineOffset++;\n                if (lineOffset >= 5) {\n                    return;\n                }\n            }\n            if (type === 6 && this.privateChatSetting < 2) {\n                y = 329 - lineOffset * 13;\n                font?.drawString(4, y, 'To ' + this.messageSender[i] + ': ' + this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                font?.drawString(4, y - 1, 'To ' + this.messageSender[i] + ': ' + this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].CYAN);\n                lineOffset++;\n                if (lineOffset >= 5) {\n                    return;\n                }\n            }\n        }\n    };\n    drawWildyLevel = () => {\n        if (!this.localPlayer) {\n            return;\n        }\n        const x = (this.localPlayer.x >> 7) + this.sceneBaseTileX;\n        const z = (this.localPlayer.z >> 7) + this.sceneBaseTileZ;\n        if (x >= 2944 && x < 3392 && z >= 3520 && z < 6400) {\n            this.wildernessLevel = (((z - 3520) / 8) | 0) + 1;\n        }\n        else if (x >= 2944 && x < 3392 && z >= 9920 && z < 12800) {\n            this.wildernessLevel = (((z - 9920) / 8) | 0) + 1;\n        }\n        else {\n            this.wildernessLevel = 0;\n        }\n        this.worldLocationState = 0;\n        if (x >= 3328 && x < 3392 && z >= 3200 && z < 3264) {\n            const localX = x & 63;\n            const localZ = z & 63;\n            if (localX >= 4 && localX <= 29 && localZ >= 44 && localZ <= 58) {\n                this.worldLocationState = 1;\n            }\n            else if (localX >= 36 && localX <= 61 && localZ >= 44 && localZ <= 58) {\n                this.worldLocationState = 1;\n            }\n            else if (localX >= 4 && localX <= 29 && localZ >= 25 && localZ <= 39) {\n                this.worldLocationState = 1;\n            }\n            else if (localX >= 36 && localX <= 61 && localZ >= 25 && localZ <= 39) {\n                this.worldLocationState = 1;\n            }\n            else if (localX >= 4 && localX <= 29 && localZ >= 6 && localZ <= 20) {\n                this.worldLocationState = 1;\n            }\n            else if (localX >= 36 && localX <= 61 && localZ >= 6 && localZ <= 20) {\n                this.worldLocationState = 1;\n            }\n        }\n        if (this.worldLocationState === 0 && x >= 3328 && x <= 3393 && z >= 3203 && z <= 3325) {\n            this.worldLocationState = 2;\n        }\n        this.overrideChat = 0;\n        if (x >= 3053 && x <= 3156 && z >= 3056 && z <= 3136) {\n            this.overrideChat = 1;\n        }\n        else if (x >= 3072 && x <= 3118 && z >= 9492 && z <= 9535) {\n            this.overrideChat = 1;\n        }\n        if (this.overrideChat === 1 && x >= 3139 && x <= 3199 && z >= 3008 && z <= 3062) {\n            this.overrideChat = 0;\n        }\n    };\n    drawSidebar = () => {\n        this.areaSidebar?.bind();\n        if (this.areaSidebarOffsets) {\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].lineOffset = this.areaSidebarOffsets;\n        }\n        this.imageInvback?.draw(0, 0);\n        if (this.sidebarInterfaceId !== -1) {\n            this.drawInterface(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.sidebarInterfaceId], 0, 0, 0);\n        }\n        else if (this.tabInterfaceId[this.selectedTab] !== -1) {\n            this.drawInterface(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.tabInterfaceId[this.selectedTab]], 0, 0, 0);\n        }\n        if (this.menuVisible && this.menuArea === 1) {\n            this.drawMenu();\n        }\n        this.areaSidebar?.draw(562, 231);\n        this.areaViewport?.bind();\n        if (this.areaViewportOffsets) {\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].lineOffset = this.areaViewportOffsets;\n        }\n    };\n    drawChatback = () => {\n        this.areaChatback?.bind();\n        if (this.areaChatbackOffsets) {\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].lineOffset = this.areaChatbackOffsets;\n        }\n        this.imageChatback?.draw(0, 0);\n        if (this.showSocialInput) {\n            this.fontBold12?.drawStringCenter(239, 40, this.socialMessage, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n            this.fontBold12?.drawStringCenter(239, 60, this.socialInput + '*', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].DARKBLUE);\n        }\n        else if (this.chatbackInputOpen) {\n            this.fontBold12?.drawStringCenter(239, 40, 'Enter amount:', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n            this.fontBold12?.drawStringCenter(239, 60, this.chatbackInput + '*', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].DARKBLUE);\n        }\n        else if (this.modalMessage) {\n            this.fontBold12?.drawStringCenter(239, 40, this.modalMessage, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n            this.fontBold12?.drawStringCenter(239, 60, 'Click to continue', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].DARKBLUE);\n        }\n        else if (this.chatInterfaceId !== -1) {\n            this.drawInterface(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.chatInterfaceId], 0, 0, 0);\n        }\n        else if (this.stickyChatInterfaceId === -1) {\n            let font = this.fontPlain12;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.chatEra === 0) {\n                font = this.fontQuill8;\n            }\n            let line = 0;\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].setBounds(0, 0, 463, 77);\n            for (let i = 0; i < 100; i++) {\n                const message = this.messageText[i];\n                if (!message) {\n                    continue;\n                }\n                const type = this.messageType[i];\n                const offset = this.chatScrollOffset + 70 - line * 14;\n                if (type === 0) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                    }\n                    line++;\n                }\n                if (type === 1) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, this.messageSender[i] + ':', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                        font?.drawString(font.stringWidth(this.messageSender[i]) + 12, offset, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLUE);\n                    }\n                    line++;\n                }\n                if (type === 2 && (this.publicChatSetting === 0 || (this.publicChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, this.messageSender[i] + ':', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                        font?.drawString(font.stringWidth(this.messageSender[i]) + 12, offset, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLUE);\n                    }\n                    line++;\n                }\n                if ((type === 3 || type === 7) && this.splitPrivateChat === 0 && (type === 7 || this.privateChatSetting === 0 || (this.privateChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, 'From ' + this.messageSender[i] + ':', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                        font?.drawString(font.stringWidth('From ' + this.messageSender[i]) + 12, offset, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].DARKRED);\n                    }\n                    line++;\n                }\n                if (type === 4 && (this.tradeChatSetting === 0 || (this.tradeChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, this.messageSender[i] + ' ' + this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].TRADE_MESSAGE);\n                    }\n                    line++;\n                }\n                if (type === 5 && this.splitPrivateChat === 0 && this.privateChatSetting < 2) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].DARKRED);\n                    }\n                    line++;\n                }\n                if (type === 6 && this.splitPrivateChat === 0 && this.privateChatSetting < 2) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, 'To ' + this.messageSender[i] + ':', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                        font?.drawString(font.stringWidth('To ' + this.messageSender[i]) + 12, offset, message, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].DARKRED);\n                    }\n                    line++;\n                }\n                if (type === 8 && (this.tradeChatSetting === 0 || (this.tradeChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                    if (offset > 0 && offset < 110) {\n                        font?.drawString(4, offset, this.messageSender[i] + ' ' + this.messageText[i], _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].DUEL_MESSAGE);\n                    }\n                    line++;\n                }\n            }\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].resetBounds();\n            this.chatScrollHeight = line * 14 + 7;\n            if (this.chatScrollHeight < 78) {\n                this.chatScrollHeight = 78;\n            }\n            this.drawScrollbar(463, 0, this.chatScrollHeight - this.chatScrollOffset - 77, this.chatScrollHeight, 77);\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.chatEra == 0) {\n                // 186-194?\n                font?.drawString(3, 90, this.chatTyped + '*', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n            }\n            else if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.chatEra == 1) {\n                // <204\n                font?.drawString(3, 90, this.chatTyped + '*', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLUE);\n            }\n            else {\n                // 204+\n                font?.drawString(4, 90, _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(this.username) + ':', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                font?.drawString(font.stringWidth(this.username + ': ') + 6, 90, this.chatTyped + '*', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLUE);\n            }\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawHorizontalLine(0, 77, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK, 479);\n        }\n        else {\n            this.drawInterface(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.stickyChatInterfaceId], 0, 0, 0);\n        }\n        if (this.menuVisible && this.menuArea === 2) {\n            this.drawMenu();\n        }\n        this.areaChatback?.draw(22, 375);\n        this.areaViewport?.bind();\n        if (this.areaViewportOffsets) {\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].lineOffset = this.areaViewportOffsets;\n        }\n    };\n    drawMinimap = () => {\n        this.areaMapback?.bind();\n        if (!this.localPlayer) {\n            return;\n        }\n        const angle = (this.orbitCameraYaw + this.minimapAnticheatAngle) & 0x7ff;\n        let anchorX = ((this.localPlayer.x / 32) | 0) + 48;\n        let anchorY = 464 - ((this.localPlayer.z / 32) | 0);\n        this.imageMinimap?.drawRotatedMasked(21, 9, 146, 151, this.minimapMaskLineOffsets, this.minimapMaskLineLengths, anchorX, anchorY, angle, this.minimapZoom + 256);\n        this.imageCompass?.drawRotatedMasked(0, 0, 33, 33, this.compassMaskLineOffsets, this.compassMaskLineLengths, 25, 25, this.orbitCameraYaw, 256);\n        for (let i = 0; i < this.activeMapFunctionCount; i++) {\n            anchorX = this.activeMapFunctionX[i] * 4 + 2 - ((this.localPlayer.x / 32) | 0);\n            anchorY = this.activeMapFunctionZ[i] * 4 + 2 - ((this.localPlayer.z / 32) | 0);\n            this.drawOnMinimap(anchorY, this.activeMapFunctions[i], anchorX);\n        }\n        for (let ltx = 0; ltx < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; ltx++) {\n            for (let ltz = 0; ltz < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; ltz++) {\n                const stack = this.levelObjStacks[this.currentLevel][ltx][ltz];\n                if (stack) {\n                    anchorX = ltx * 4 + 2 - ((this.localPlayer.x / 32) | 0);\n                    anchorY = ltz * 4 + 2 - ((this.localPlayer.z / 32) | 0);\n                    this.drawOnMinimap(anchorY, this.imageMapdot0, anchorX);\n                }\n            }\n        }\n        for (let i = 0; i < this.npcCount; i++) {\n            const npc = this.npcs[this.npcIds[i]];\n            if (npc && npc.isVisible() && npc.type && npc.type.minimap) {\n                anchorX = ((npc.x / 32) | 0) - ((this.localPlayer.x / 32) | 0);\n                anchorY = ((npc.z / 32) | 0) - ((this.localPlayer.z / 32) | 0);\n                this.drawOnMinimap(anchorY, this.imageMapdot1, anchorX);\n            }\n        }\n        for (let i = 0; i < this.playerCount; i++) {\n            const player = this.players[this.playerIds[i]];\n            if (player && player.isVisible() && player.name) {\n                anchorX = ((player.x / 32) | 0) - ((this.localPlayer.x / 32) | 0);\n                anchorY = ((player.z / 32) | 0) - ((this.localPlayer.z / 32) | 0);\n                let friend = false;\n                const name37 = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(player.name);\n                for (let j = 0; j < this.friendCount; j++) {\n                    if (name37 === this.friendName37[j] && this.friendWorld[j] !== 0) {\n                        friend = true;\n                        break;\n                    }\n                }\n                if (friend) {\n                    this.drawOnMinimap(anchorY, this.imageMapdot3, anchorX);\n                }\n                else {\n                    this.drawOnMinimap(anchorY, this.imageMapdot2, anchorX);\n                }\n            }\n        }\n        if (this.flagSceneTileX !== 0) {\n            anchorX = this.flagSceneTileX * 4 + 2 - ((this.localPlayer.x / 32) | 0);\n            anchorY = this.flagSceneTileZ * 4 + 2 - ((this.localPlayer.z / 32) | 0);\n            this.drawOnMinimap(anchorY, this.imageMapflag, anchorX);\n        }\n        // the white square local player position in the center of the minimap.\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fillRect(93, 82, 3, 3, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n        this.areaViewport?.bind();\n    };\n    drawOnMinimap = (dy, image, dx) => {\n        if (!image) {\n            return;\n        }\n        const angle = (this.orbitCameraYaw + this.minimapAnticheatAngle) & 0x7ff;\n        const distance = dx * dx + dy * dy;\n        if (distance > 6400) {\n            return;\n        }\n        let sinAngle = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].sin[angle];\n        let cosAngle = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].cos[angle];\n        sinAngle = ((sinAngle * 256) / (this.minimapZoom + 256)) | 0;\n        cosAngle = ((cosAngle * 256) / (this.minimapZoom + 256)) | 0;\n        const x = (dy * sinAngle + dx * cosAngle) >> 16;\n        const y = (dy * cosAngle - dx * sinAngle) >> 16;\n        if (distance > 2500 && this.imageMapback) {\n            image.drawMasked(x + 94 - ((image.cropW / 2) | 0), 83 - y - ((image.cropH / 2) | 0), this.imageMapback);\n        }\n        else {\n            image.draw(x + 94 - ((image.cropW / 2) | 0), 83 - y - ((image.cropH / 2) | 0));\n        }\n    };\n    createMinimap = (level) => {\n        if (!this.imageMinimap) {\n            return;\n        }\n        const pixels = this.imageMinimap.pixels;\n        const length = pixels.length;\n        for (let i = 0; i < length; i++) {\n            pixels[i] = 0;\n        }\n        for (let z = 1; z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1; z++) {\n            let offset = (_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1 - z) * 512 * 4 + 24628;\n            for (let x = 1; x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1; x++) {\n                if (this.levelTileFlags && (this.levelTileFlags[level][x][z] & 0x18) === 0) {\n                    this.scene?.drawMinimapTile(level, x, z, pixels, offset, 512);\n                }\n                if (level < 3 && this.levelTileFlags && (this.levelTileFlags[level + 1][x][z] & 0x8) !== 0) {\n                    this.scene?.drawMinimapTile(level + 1, x, z, pixels, offset, 512);\n                }\n                offset += 4;\n            }\n        }\n        const wallRgb = ((((Math.random() * 20.0) | 0) + 238 - 10) << 16) + ((((Math.random() * 20.0) | 0) + 238 - 10) << 8) + ((Math.random() * 20.0) | 0) + 238 - 10;\n        const doorRgb = (((Math.random() * 20.0) | 0) + 238 - 10) << 16;\n        this.imageMinimap.bind();\n        for (let z = 1; z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1; z++) {\n            for (let x = 1; x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1; x++) {\n                if (this.levelTileFlags && (this.levelTileFlags[level][x][z] & 0x18) === 0) {\n                    this.drawMinimapLoc(x, z, level, wallRgb, doorRgb);\n                }\n                if (level < 3 && this.levelTileFlags && (this.levelTileFlags[level + 1][x][z] & 0x8) !== 0) {\n                    this.drawMinimapLoc(x, z, level + 1, wallRgb, doorRgb);\n                }\n            }\n        }\n        this.areaViewport?.bind();\n        this.activeMapFunctionCount = 0;\n        for (let x = 0; x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; x++) {\n            for (let z = 0; z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; z++) {\n                let bitset = this.scene?.getGroundDecorationBitset(this.currentLevel, x, z) ?? 0;\n                if (bitset === 0) {\n                    continue;\n                }\n                bitset = (bitset >> 14) & 0x7fff;\n                const func = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(bitset).mapfunction;\n                if (func < 0) {\n                    continue;\n                }\n                let stx = x;\n                let stz = z;\n                if (func !== 22 && func !== 29 && func !== 34 && func !== 36 && func !== 46 && func !== 47 && func !== 48) {\n                    const maxX = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE;\n                    const maxZ = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE;\n                    const collisionmap = this.levelCollisionMap[this.currentLevel];\n                    if (collisionmap) {\n                        const flags = collisionmap.flags;\n                        for (let i = 0; i < 10; i++) {\n                            const rand = (Math.random() * 4.0) | 0;\n                            if (rand === 0 && stx > 0 && stx > x - 3 && (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(stx - 1, stz)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_WEST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                                stx--;\n                            }\n                            if (rand === 1 && stx < maxX - 1 && stx < x + 3 && (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(stx + 1, stz)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_EAST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                                stx++;\n                            }\n                            if (rand === 2 && stz > 0 && stz > z - 3 && (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(stx, stz - 1)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_SOUTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                                stz--;\n                            }\n                            if (rand === 3 && stz < maxZ - 1 && stz < z + 3 && (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(stx, stz + 1)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_NORTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                                stz++;\n                            }\n                        }\n                    }\n                }\n                this.activeMapFunctions[this.activeMapFunctionCount] = this.imageMapfunction[func];\n                this.activeMapFunctionX[this.activeMapFunctionCount] = stx;\n                this.activeMapFunctionZ[this.activeMapFunctionCount] = stz;\n                this.activeMapFunctionCount++;\n            }\n        }\n    };\n    drawMinimapLoc = (tileX, tileZ, level, wallRgb, doorRgb) => {\n        if (!this.scene || !this.imageMinimap) {\n            return;\n        }\n        let bitset = this.scene.getWallBitset(level, tileX, tileZ);\n        if (bitset !== 0) {\n            const info = this.scene.getInfo(level, tileX, tileZ, bitset);\n            const angle = (info >> 6) & 0x3;\n            const shape = info & 0x1f;\n            let rgb = wallRgb;\n            if (bitset > 0) {\n                rgb = doorRgb;\n            }\n            const dst = this.imageMinimap.pixels;\n            const offset = tileX * 4 + (103 - tileZ) * 512 * 4 + 24624;\n            const locId = (bitset >> 14) & 0x7fff;\n            const loc = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(locId);\n            if (loc.mapscene === -1) {\n                if (shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_STRAIGHT.id || shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_L.id) {\n                    if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].WEST) {\n                        dst[offset] = rgb;\n                        dst[offset + 512] = rgb;\n                        dst[offset + 1024] = rgb;\n                        dst[offset + 1536] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].NORTH) {\n                        dst[offset] = rgb;\n                        dst[offset + 1] = rgb;\n                        dst[offset + 2] = rgb;\n                        dst[offset + 3] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].EAST) {\n                        dst[offset + 3] = rgb;\n                        dst[offset + 3 + 512] = rgb;\n                        dst[offset + 3 + 1024] = rgb;\n                        dst[offset + 3 + 1536] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].SOUTH) {\n                        dst[offset + 1536] = rgb;\n                        dst[offset + 1536 + 1] = rgb;\n                        dst[offset + 1536 + 2] = rgb;\n                        dst[offset + 1536 + 3] = rgb;\n                    }\n                }\n                if (shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_SQUARE_CORNER.id) {\n                    if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].WEST) {\n                        dst[offset] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].NORTH) {\n                        dst[offset + 3] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].EAST) {\n                        dst[offset + 3 + 1536] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].SOUTH) {\n                        dst[offset + 1536] = rgb;\n                    }\n                }\n                if (shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_L.id) {\n                    if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].SOUTH) {\n                        dst[offset] = rgb;\n                        dst[offset + 512] = rgb;\n                        dst[offset + 1024] = rgb;\n                        dst[offset + 1536] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].WEST) {\n                        dst[offset] = rgb;\n                        dst[offset + 1] = rgb;\n                        dst[offset + 2] = rgb;\n                        dst[offset + 3] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].NORTH) {\n                        dst[offset + 3] = rgb;\n                        dst[offset + 3 + 512] = rgb;\n                        dst[offset + 3 + 1024] = rgb;\n                        dst[offset + 3 + 1536] = rgb;\n                    }\n                    else if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].EAST) {\n                        dst[offset + 1536] = rgb;\n                        dst[offset + 1536 + 1] = rgb;\n                        dst[offset + 1536 + 2] = rgb;\n                        dst[offset + 1536 + 3] = rgb;\n                    }\n                }\n            }\n            else {\n                const scene = this.imageMapscene[loc.mapscene];\n                if (scene) {\n                    const offsetX = ((loc.width * 4 - scene.width) / 2) | 0;\n                    const offsetY = ((loc.length * 4 - scene.height) / 2) | 0;\n                    scene.draw(tileX * 4 + 48 + offsetX, (_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - tileZ - loc.length) * 4 + offsetY + 48);\n                }\n            }\n        }\n        bitset = this.scene.getLocBitset(level, tileX, tileZ);\n        if (bitset !== 0) {\n            const info = this.scene.getInfo(level, tileX, tileZ, bitset);\n            const angle = (info >> 6) & 0x3;\n            const shape = info & 0x1f;\n            const locId = (bitset >> 14) & 0x7fff;\n            const loc = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(locId);\n            if (loc.mapscene !== -1) {\n                const scene = this.imageMapscene[loc.mapscene];\n                if (scene) {\n                    const offsetX = ((loc.width * 4 - scene.width) / 2) | 0;\n                    const offsetY = ((loc.length * 4 - scene.height) / 2) | 0;\n                    scene.draw(tileX * 4 + 48 + offsetX, (_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - tileZ - loc.length) * 4 + offsetY + 48);\n                }\n            }\n            else if (shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_DIAGONAL.id) {\n                let rgb = 0xeeeeee;\n                if (bitset > 0) {\n                    rgb = 0xee0000;\n                }\n                const dst = this.imageMinimap.pixels;\n                const offset = tileX * 4 + (_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1 - tileZ) * 512 * 4 + 24624;\n                if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].WEST || angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].EAST) {\n                    dst[offset + 1536] = rgb;\n                    dst[offset + 1024 + 1] = rgb;\n                    dst[offset + 512 + 2] = rgb;\n                    dst[offset + 3] = rgb;\n                }\n                else {\n                    dst[offset] = rgb;\n                    dst[offset + 512 + 1] = rgb;\n                    dst[offset + 1024 + 2] = rgb;\n                    dst[offset + 1536 + 3] = rgb;\n                }\n            }\n        }\n        bitset = this.scene.getGroundDecorationBitset(level, tileX, tileZ);\n        if (bitset !== 0) {\n            const loc = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get((bitset >> 14) & 0x7fff);\n            if (loc.mapscene !== -1) {\n                const scene = this.imageMapscene[loc.mapscene];\n                if (scene) {\n                    const offsetX = ((loc.width * 4 - scene.width) / 2) | 0;\n                    const offsetY = ((loc.length * 4 - scene.height) / 2) | 0;\n                    scene.draw(tileX * 4 + 48 + offsetX, (_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - tileZ - loc.length) * 4 + offsetY + 48);\n                }\n            }\n        }\n    };\n    drawTooltip = () => {\n        if (this.menuSize < 2 && this.objSelected === 0 && this.spellSelected === 0) {\n            return;\n        }\n        let tooltip;\n        if (this.objSelected === 1 && this.menuSize < 2) {\n            tooltip = 'Use ' + this.objSelectedName + ' with...';\n        }\n        else if (this.spellSelected === 1 && this.menuSize < 2) {\n            tooltip = this.spellCaption + '...';\n        }\n        else {\n            tooltip = this.menuOption[this.menuSize - 1];\n        }\n        if (this.menuSize > 2) {\n            tooltip = tooltip + '@whi@ / ' + (this.menuSize - 2) + ' more options';\n        }\n        this.fontBold12?.drawStringTooltip(4, 15, tooltip, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE, true, (this.loopCycle / 1000) | 0);\n    };\n    drawMenu = () => {\n        const x = this.menuX;\n        const y = this.menuY;\n        const w = this.menuWidth;\n        const h = this.menuHeight;\n        const background = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].OPTIONS_MENU;\n        // the menu area square.\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fillRect(x, y, w, h, background);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].fillRect(x + 1, y + 1, w - 2, 16, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n        _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawRect(x + 1, y + 18, w - 2, h - 19, _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n        // the menu title header at the top.\n        this.fontBold12?.drawString(x + 3, y + 14, 'Choose Option', background);\n        let mouseX = this.mouseX;\n        let mouseY = this.mouseY;\n        if (this.menuArea === 0) {\n            mouseX -= 8;\n            mouseY -= 11;\n        }\n        if (this.menuArea === 1) {\n            mouseX -= 562;\n            mouseY -= 231;\n        }\n        if (this.menuArea === 2) {\n            mouseX -= 22;\n            mouseY -= 375;\n        }\n        for (let i = 0; i < this.menuSize; i++) {\n            const optionY = y + (this.menuSize - 1 - i) * 15 + 31;\n            let rgb = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE;\n            if (mouseX > x && mouseX < x + w && mouseY > optionY - 13 && mouseY < optionY + 3) {\n                rgb = _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].YELLOW;\n            }\n            this.fontBold12?.drawStringTaggable(x + 3, optionY, this.menuOption[i], rgb, true);\n        }\n    };\n    handleMouseInput = async () => {\n        if (this.objDragArea !== 0) {\n            return;\n        }\n        let button = this.mouseClickButton;\n        if (this.spellSelected === 1 && this.mouseClickX >= 520 && this.mouseClickY >= 165 && this.mouseClickX <= 788 && this.mouseClickY <= 230) {\n            button = 0;\n        }\n        if (this.menuVisible) {\n            if (button !== 1) {\n                let x = this.mouseX;\n                let y = this.mouseY;\n                if (this.menuArea === 0) {\n                    x -= 8;\n                    y -= 11;\n                }\n                else if (this.menuArea === 1) {\n                    x -= 562;\n                    y -= 231;\n                }\n                else if (this.menuArea === 2) {\n                    x -= 22;\n                    y -= 375;\n                }\n                if (x < this.menuX - 10 || x > this.menuX + this.menuWidth + 10 || y < this.menuY - 10 || y > this.menuY + this.menuHeight + 10) {\n                    this.menuVisible = false;\n                    if (this.menuArea === 1) {\n                        this.redrawSidebar = true;\n                    }\n                    if (this.menuArea === 2) {\n                        this.redrawChatback = true;\n                    }\n                }\n            }\n            if (button === 1) {\n                const menuX = this.menuX;\n                const menuY = this.menuY;\n                const menuWidth = this.menuWidth;\n                let clickX = this.mouseClickX;\n                let clickY = this.mouseClickY;\n                if (this.menuArea === 0) {\n                    clickX -= 8;\n                    clickY -= 11;\n                }\n                else if (this.menuArea === 1) {\n                    clickX -= 562;\n                    clickY -= 231;\n                }\n                else if (this.menuArea === 2) {\n                    clickX -= 22;\n                    clickY -= 375;\n                }\n                let option = -1;\n                for (let i = 0; i < this.menuSize; i++) {\n                    const optionY = menuY + (this.menuSize - 1 - i) * 15 + 31;\n                    if (clickX > menuX && clickX < menuX + menuWidth && clickY > optionY - 13 && clickY < optionY + 3) {\n                        option = i;\n                    }\n                }\n                if (option !== -1) {\n                    await this.useMenuOption(option);\n                }\n                this.menuVisible = false;\n                if (this.menuArea === 1) {\n                    this.redrawSidebar = true;\n                }\n                else if (this.menuArea === 2) {\n                    this.redrawChatback = true;\n                }\n            }\n        }\n        else {\n            if (button === 1 && this.menuSize > 0) {\n                const action = this.menuAction[this.menuSize - 1];\n                if (action === 602 || action === 596 || action === 22 || action === 892 || action === 415 || action === 405 || action === 38 || action === 422 || action === 478 || action === 347 || action === 188) {\n                    const slot = this.menuParamB[this.menuSize - 1];\n                    const comId = this.menuParamC[this.menuSize - 1];\n                    const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[comId];\n                    if (com.draggable) {\n                        this.objGrabThreshold = false;\n                        this.objDragCycles = 0;\n                        this.objDragInterfaceId = comId;\n                        this.objDragSlot = slot;\n                        this.objDragArea = 2;\n                        this.objGrabX = this.mouseClickX;\n                        this.objGrabY = this.mouseClickY;\n                        if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[comId].layer === this.viewportInterfaceId) {\n                            this.objDragArea = 1;\n                        }\n                        if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[comId].layer === this.chatInterfaceId) {\n                            this.objDragArea = 3;\n                        }\n                        return;\n                    }\n                }\n            }\n            if (button === 1 && (this.mouseButtonsOption === 1 || this.isAddFriendOption(this.menuSize - 1)) && this.menuSize > 2) {\n                button = 2;\n            }\n            if (button === 1 && this.menuSize > 0) {\n                await this.useMenuOption(this.menuSize - 1);\n            }\n            if (button !== 2 || this.menuSize <= 0) {\n                return;\n            }\n            this.showContextMenu();\n        }\n    };\n    handleMinimapInput = () => {\n        if (this.mouseClickButton === 1 && this.localPlayer) {\n            let x = this.mouseClickX - 21 - 561;\n            let y = this.mouseClickY - 9 - 5;\n            if (x >= 0 && y >= 0 && x < 146 && y < 151) {\n                x -= 73;\n                y -= 75;\n                const yaw = (this.orbitCameraYaw + this.minimapAnticheatAngle) & 0x7ff;\n                let sinYaw = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].sin[yaw];\n                let cosYaw = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].cos[yaw];\n                sinYaw = (sinYaw * (this.minimapZoom + 256)) >> 8;\n                cosYaw = (cosYaw * (this.minimapZoom + 256)) >> 8;\n                const relX = (y * sinYaw + x * cosYaw) >> 11;\n                const relY = (y * cosYaw - x * sinYaw) >> 11;\n                const tileX = (this.localPlayer.x + relX) >> 7;\n                const tileZ = (this.localPlayer.z - relY) >> 7;\n                if (this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], tileX, tileZ, 1, 0, 0, 0, 0, 0, true)) {\n                    // the additional 14-bytes in MOVE_MINIMAPCLICK\n                    this.out.p1(x);\n                    this.out.p1(y);\n                    this.out.p2(this.orbitCameraYaw);\n                    this.out.p1(57);\n                    this.out.p1(this.minimapAnticheatAngle);\n                    this.out.p1(this.minimapZoom);\n                    this.out.p1(89);\n                    this.out.p2(this.localPlayer.x);\n                    this.out.p2(this.localPlayer.z);\n                    this.out.p1(this.tryMoveNearest);\n                    this.out.p1(63);\n                }\n            }\n        }\n    };\n    isAddFriendOption = (option) => {\n        if (option < 0) {\n            return false;\n        }\n        let action = this.menuAction[option];\n        if (action >= 2000) {\n            action -= 2000;\n        }\n        return action === 406;\n    };\n    useMenuOption = async (optionId) => {\n        if (optionId < 0) {\n            return;\n        }\n        if (this.chatbackInputOpen) {\n            this.chatbackInputOpen = false;\n            this.redrawChatback = true;\n        }\n        let action = this.menuAction[optionId];\n        const a = this.menuParamA[optionId];\n        const b = this.menuParamB[optionId];\n        const c = this.menuParamC[optionId];\n        if (action >= 2000) {\n            action -= 2000;\n        }\n        if (action === 903 || action === 363) {\n            let option = this.menuOption[optionId];\n            const tag = option.indexOf('@whi@');\n            if (tag !== -1) {\n                option = option.substring(tag + 5).trim();\n                const name = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].fromBase37(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(option)));\n                let found = false;\n                for (let i = 0; i < this.playerCount; i++) {\n                    const player = this.players[this.playerIds[i]];\n                    if (player && player.name && player.name.toLowerCase() === name.toLowerCase() && this.localPlayer) {\n                        this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], player.pathTileX[0], player.pathTileZ[0], 2, 1, 1, 0, 0, 0, false);\n                        if (action === 903) {\n                            // OPPLAYER4\n                            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYER4);\n                        }\n                        else if (action === 363) {\n                            // OPPLAYER1\n                            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYER1);\n                        }\n                        this.out.p2(this.playerIds[i]);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    this.addMessage(0, 'Unable to find ' + name, '');\n                }\n            }\n        }\n        else if (action === 450 && this.interactWithLoc(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPLOCU, b, c, a)) {\n            // OPLOCU\n            this.out.p2(this.objInterface);\n            this.out.p2(this.objSelectedSlot);\n            this.out.p2(this.objSelectedInterface);\n        }\n        else if (action === 405 || action === 38 || action === 422 || action === 478 || action === 347) {\n            if (action === 478) {\n                if ((b & 0x3) === 0) {\n                    _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic5++;\n                }\n                if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic5 >= 90) {\n                    // ANTICHEAT_OPLOGIC5\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC5);\n                }\n                // OPHELD4\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPHELD4);\n            }\n            else if (action === 347) {\n                // OPHELD5\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPHELD5);\n            }\n            else if (action === 422) {\n                // OPHELD3\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPHELD3);\n            }\n            else if (action === 405) {\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic3 += a;\n                if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic3 >= 97) {\n                    // ANTICHEAT_OPLOGIC3\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC3);\n                    this.out.p3(14953816);\n                }\n                // OPHELD1\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPHELD1);\n            }\n            else if (action === 38) {\n                // OPHELD2\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPHELD2);\n            }\n            this.out.p2(a);\n            this.out.p2(b);\n            this.out.p2(c);\n            this.selectedCycle = 0;\n            this.selectedInterface = c;\n            this.selectedItem = b;\n            this.selectedArea = 2;\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.viewportInterfaceId) {\n                this.selectedArea = 1;\n            }\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.chatInterfaceId) {\n                this.selectedArea = 3;\n            }\n        }\n        else if (action === 728 || action === 542 || action === 6 || action === 963 || action === 245) {\n            const npc = this.npcs[a];\n            if (npc && this.localPlayer) {\n                this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], npc.pathTileX[0], npc.pathTileZ[0], 2, 1, 1, 0, 0, 0, false);\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                if (action === 542) {\n                    // OPNPC2\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPNPC2);\n                }\n                else if (action === 6) {\n                    if ((a & 0x3) === 0) {\n                        _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic2++;\n                    }\n                    if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic2 >= 124) {\n                        // ANTICHEAT_OPLOGIC2\n                        this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC2);\n                        this.out.p4(0);\n                    }\n                    // OPNPC3\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPNPC3);\n                }\n                else if (action === 963) {\n                    // OPNPC4\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPNPC4);\n                }\n                else if (action === 728) {\n                    // OPNPC1\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPNPC1);\n                }\n                else if (action === 245) {\n                    if ((a & 0x3) === 0) {\n                        _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic4++;\n                    }\n                    if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic4 >= 85) {\n                        // ANTICHEAT_OPLOGIC4\n                        this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC4);\n                        this.out.p2(39596);\n                    }\n                    // OPNPC5\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPNPC5);\n                }\n                this.out.p2(a);\n            }\n        }\n        else if (action === 217) {\n            if (this.localPlayer) {\n                const success = this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], b, c, 2, 0, 0, 0, 0, 0, false);\n                if (!success) {\n                    this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], b, c, 2, 1, 1, 0, 0, 0, false);\n                }\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                // OPOBJU\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPOBJU);\n                this.out.p2(b + this.sceneBaseTileX);\n                this.out.p2(c + this.sceneBaseTileZ);\n                this.out.p2(a);\n                this.out.p2(this.objInterface);\n                this.out.p2(this.objSelectedSlot);\n                this.out.p2(this.objSelectedInterface);\n            }\n        }\n        else if (action === 1175) {\n            // loc examine\n            const locId = (a >> 14) & 0x7fff;\n            const loc = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(locId);\n            let examine;\n            if (!loc.desc) {\n                examine = \"It's a \" + loc.name + '.';\n            }\n            else {\n                examine = loc.desc;\n            }\n            this.addMessage(0, examine, '');\n        }\n        else if (action === 285) {\n            // OPLOC1\n            this.interactWithLoc(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPLOC1, b, c, a);\n        }\n        else if (action === 881) {\n            // OPHELDU\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPHELDU);\n            this.out.p2(a);\n            this.out.p2(b);\n            this.out.p2(c);\n            this.out.p2(this.objInterface);\n            this.out.p2(this.objSelectedSlot);\n            this.out.p2(this.objSelectedInterface);\n            this.selectedCycle = 0;\n            this.selectedInterface = c;\n            this.selectedItem = b;\n            this.selectedArea = 2;\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.viewportInterfaceId) {\n                this.selectedArea = 1;\n            }\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.chatInterfaceId) {\n                this.selectedArea = 3;\n            }\n        }\n        else if (action === 391) {\n            // OPHELDT\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPHELDT);\n            this.out.p2(a);\n            this.out.p2(b);\n            this.out.p2(c);\n            this.out.p2(this.activeSpellId);\n            this.selectedCycle = 0;\n            this.selectedInterface = c;\n            this.selectedItem = b;\n            this.selectedArea = 2;\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.viewportInterfaceId) {\n                this.selectedArea = 1;\n            }\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.chatInterfaceId) {\n                this.selectedArea = 3;\n            }\n        }\n        else if (action === 660) {\n            if (this.menuVisible) {\n                this.scene?.click(b - 8, c - 11);\n            }\n            else {\n                this.scene?.click(this.mouseClickX - 8, this.mouseClickY - 11);\n            }\n        }\n        else if (action === 188) {\n            // select obj interface\n            this.objSelected = 1;\n            this.objSelectedSlot = b;\n            this.objSelectedInterface = c;\n            this.objInterface = a;\n            this.objSelectedName = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(a).name;\n            this.spellSelected = 0;\n            return;\n        }\n        else if (action === 44) {\n            // RESUME_PAUSEBUTTON\n            if (!this.pressedContinueOption) {\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].RESUME_PAUSEBUTTON);\n                this.out.p2(c);\n                this.pressedContinueOption = true;\n            }\n        }\n        else if (action === 1773) {\n            // loc examine\n            const obj = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(a);\n            let examine;\n            if (c >= 100000) {\n                examine = c + ' x ' + obj.name;\n            }\n            else if (!obj.desc) {\n                examine = \"It's a \" + obj.name + '.';\n            }\n            else {\n                examine = obj.desc;\n            }\n            this.addMessage(0, examine, '');\n        }\n        else if (action === 900) {\n            const npc = this.npcs[a];\n            if (npc && this.localPlayer) {\n                this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], npc.pathTileX[0], npc.pathTileZ[0], 2, 1, 1, 0, 0, 0, false);\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                // OPNPCU\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPNPCU);\n                this.out.p2(a);\n                this.out.p2(this.objInterface);\n                this.out.p2(this.objSelectedSlot);\n                this.out.p2(this.objSelectedInterface);\n            }\n        }\n        else if (action === 1373 || action === 1544 || action === 151 || action === 1101) {\n            const player = this.players[a];\n            if (player && this.localPlayer) {\n                this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], player.pathTileX[0], player.pathTileZ[0], 2, 1, 1, 0, 0, 0, false);\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                if (action === 1101) {\n                    // OPPLAYER1\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYER1);\n                }\n                else if (action === 151) {\n                    _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic8++;\n                    if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic8 >= 90) {\n                        // ANTICHEAT_OPLOGIC8\n                        this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC8);\n                        this.out.p2(31114);\n                    }\n                    // OPPLAYER2\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYER2);\n                }\n                else if (action === 1373) {\n                    // OPPLAYER4\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYER4);\n                }\n                else if (action === 1544) {\n                    // OPPLAYER3\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYER3);\n                }\n                this.out.p2(a);\n            }\n        }\n        else if (action === 265) {\n            const npc = this.npcs[a];\n            if (npc && this.localPlayer) {\n                this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], npc.pathTileX[0], npc.pathTileZ[0], 2, 1, 1, 0, 0, 0, false);\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                // OPNPCT\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPNPCT);\n                this.out.p2(a);\n                this.out.p2(this.activeSpellId);\n            }\n        }\n        else if (action === 679) {\n            const option = this.menuOption[optionId];\n            const tag = option.indexOf('@whi@');\n            if (tag !== -1) {\n                const name37 = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(option.substring(tag + 5).trim());\n                let friend = -1;\n                for (let i = 0; i < this.friendCount; i++) {\n                    if (this.friendName37[i] === name37) {\n                        friend = i;\n                        break;\n                    }\n                }\n                if (friend !== -1 && this.friendWorld[friend] > 0) {\n                    this.redrawChatback = true;\n                    this.chatbackInputOpen = false;\n                    this.showSocialInput = true;\n                    this.socialInput = '';\n                    this.socialAction = 3;\n                    this.socialName37 = this.friendName37[friend];\n                    this.socialMessage = 'Enter message to send to ' + this.friendName[friend];\n                }\n            }\n        }\n        else if (action === 55) {\n            // OPLOCT\n            if (this.interactWithLoc(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPLOCT, b, c, a)) {\n                this.out.p2(this.activeSpellId);\n            }\n        }\n        else if (action === 224 || action === 993 || action === 99 || action === 746 || action === 877) {\n            if (this.localPlayer) {\n                const success = this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], b, c, 2, 0, 0, 0, 0, 0, false);\n                if (!success) {\n                    this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], b, c, 2, 1, 1, 0, 0, 0, false);\n                }\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                if (action === 224) {\n                    // OPOBJ1\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPOBJ1);\n                }\n                else if (action === 746) {\n                    // OPOBJ4\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPOBJ4);\n                }\n                else if (action === 877) {\n                    // OPOBJ5\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPOBJ5);\n                }\n                else if (action === 99) {\n                    // OPOBJ3\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPOBJ3);\n                }\n                else if (action === 993) {\n                    // OPOBJ2\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPOBJ2);\n                }\n                this.out.p2(b + this.sceneBaseTileX);\n                this.out.p2(c + this.sceneBaseTileZ);\n                this.out.p2(a);\n            }\n        }\n        else if (action === 1607) {\n            // npc examine\n            const npc = this.npcs[a];\n            if (npc && npc.type) {\n                let examine;\n                if (!npc.type.desc) {\n                    examine = \"It's a \" + npc.type.name + '.';\n                }\n                else {\n                    examine = npc.type.desc;\n                }\n                this.addMessage(0, examine, '');\n            }\n        }\n        else if (action === 504) {\n            // OPLOC2\n            this.interactWithLoc(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPLOC2, b, c, a);\n        }\n        else if (action === 930) {\n            const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c];\n            this.spellSelected = 1;\n            this.activeSpellId = c;\n            this.activeSpellFlags = com.actionTarget;\n            this.objSelected = 0;\n            let prefix = com.actionVerb;\n            if (prefix && prefix.indexOf(' ') !== -1) {\n                prefix = prefix.substring(0, prefix.indexOf(' '));\n            }\n            let suffix = com.actionVerb;\n            if (suffix && suffix.indexOf(' ') !== -1) {\n                suffix = suffix.substring(suffix.indexOf(' ') + 1);\n            }\n            this.spellCaption = prefix + ' ' + com.action + ' ' + suffix;\n            if (this.activeSpellFlags === 16) {\n                this.redrawSidebar = true;\n                this.selectedTab = 3;\n                this.redrawSideicons = true;\n            }\n            return;\n        }\n        else if (action === 951) {\n            const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c];\n            let notify = true;\n            if (com.clientCode > 0) {\n                notify = this.handleInterfaceAction(com);\n            }\n            if (notify) {\n                // IF_BUTTON\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].IF_BUTTON);\n                this.out.p2(c);\n            }\n        }\n        else if (action === 602 || action === 596 || action === 22 || action === 892 || action === 415) {\n            if (action === 22) {\n                // INV_BUTTON3\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].INV_BUTTON3);\n            }\n            else if (action === 415) {\n                if ((c & 0x3) === 0) {\n                    _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic7++;\n                }\n                if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic7 >= 55) {\n                    // ANTICHEAT_OPLOGIC7\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC7);\n                    this.out.p4(0);\n                }\n                // INV_BUTTON5\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].INV_BUTTON5);\n            }\n            else if (action === 602) {\n                // INV_BUTTON1\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].INV_BUTTON1);\n            }\n            else if (action === 892) {\n                if ((b & 0x3) === 0) {\n                    _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic9++;\n                }\n                if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic9 >= 130) {\n                    // ANTICHEAT_OPLOGIC9\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC9);\n                    this.out.p1(177);\n                }\n                // INV_BUTTON4\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].INV_BUTTON4);\n            }\n            else if (action === 596) {\n                // INV_BUTTON2\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].INV_BUTTON2);\n            }\n            this.out.p2(a);\n            this.out.p2(b);\n            this.out.p2(c);\n            this.selectedCycle = 0;\n            this.selectedInterface = c;\n            this.selectedItem = b;\n            this.selectedArea = 2;\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.viewportInterfaceId) {\n                this.selectedArea = 1;\n            }\n            if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c].layer === this.chatInterfaceId) {\n                this.selectedArea = 3;\n            }\n        }\n        else if (action === 581) {\n            if ((a & 0x3) === 0) {\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic1++;\n            }\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic1 >= 99) {\n                // ANTICHEAT_OPLOGIC1\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC1);\n                this.out.p4(0);\n            }\n            // OPLOC4\n            this.interactWithLoc(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPLOC4, b, c, a);\n        }\n        else if (action === 965) {\n            if (this.localPlayer) {\n                const success = this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], b, c, 2, 0, 0, 0, 0, 0, false);\n                if (!success) {\n                    this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], b, c, 2, 1, 1, 0, 0, 0, false);\n                }\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                // OPOBJT\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPOBJT);\n                this.out.p2(b + this.sceneBaseTileX);\n                this.out.p2(c + this.sceneBaseTileZ);\n                this.out.p2(a);\n                this.out.p2(this.activeSpellId);\n            }\n        }\n        else if (action === 1501) {\n            _client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic6 += this.sceneBaseTileZ;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.oplogic6 >= 92) {\n                // ANTICHEAT_OPLOGIC6\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_OPLOGIC6);\n                this.out.p4(0);\n            }\n            // OPLOC5\n            this.interactWithLoc(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPLOC5, b, c, a);\n        }\n        else if (action === 364) {\n            // OPLOC3\n            this.interactWithLoc(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPLOC3, b, c, a);\n        }\n        else if (action === 1102) {\n            // obj examine\n            const obj = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(a);\n            let examine;\n            if (!obj.desc) {\n                examine = \"It's a \" + obj.name + '.';\n            }\n            else {\n                examine = obj.desc;\n            }\n            this.addMessage(0, examine, '');\n        }\n        else if (action === 960) {\n            // IF_BUTTON\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].IF_BUTTON);\n            this.out.p2(c);\n            const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c];\n            if (com.scripts && com.scripts[0] && com.scripts[0][0] === 5) {\n                const varp = com.scripts[0][1];\n                if (com.scriptOperand && this.varps[varp] !== com.scriptOperand[0]) {\n                    this.varps[varp] = com.scriptOperand[0];\n                    await this.updateVarp(varp);\n                    this.redrawSidebar = true;\n                }\n            }\n        }\n        else if (action === 34) {\n            // reportabuse input\n            const option = this.menuOption[optionId];\n            const tag = option.indexOf('@whi@');\n            if (tag !== -1) {\n                this.closeInterfaces();\n                this.reportAbuseInput = option.substring(tag + 5).trim();\n                this.reportAbuseMuteOption = false;\n                for (let i = 0; i < _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances.length; i++) {\n                    if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i] && _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i].clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_REPORT_INPUT) {\n                        this.reportAbuseInterfaceID = this.viewportInterfaceId = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i].layer;\n                        break;\n                    }\n                }\n            }\n        }\n        else if (action === 947) {\n            // close interfaces\n            this.closeInterfaces();\n        }\n        else if (action === 367) {\n            const player = this.players[a];\n            if (player && this.localPlayer) {\n                this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], player.pathTileX[0], player.pathTileZ[0], 2, 1, 1, 0, 0, 0, false);\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                // OPPLAYERU\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYERU);\n                this.out.p2(a);\n                this.out.p2(this.objInterface);\n                this.out.p2(this.objSelectedSlot);\n                this.out.p2(this.objSelectedInterface);\n            }\n        }\n        else if (action === 465) {\n            // IF_BUTTON\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].IF_BUTTON);\n            this.out.p2(c);\n            const com = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[c];\n            if (com.scripts && com.scripts[0] && com.scripts[0][0] === 5) {\n                const varp = com.scripts[0][1];\n                this.varps[varp] = 1 - this.varps[varp];\n                await this.updateVarp(varp);\n                this.redrawSidebar = true;\n            }\n        }\n        else if (action === 406 || action === 436 || action === 557 || action === 556) {\n            const option = this.menuOption[optionId];\n            const tag = option.indexOf('@whi@');\n            if (tag !== -1) {\n                const username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(option.substring(tag + 5).trim());\n                if (action === 406) {\n                    this.addFriend(username);\n                }\n                else if (action === 436) {\n                    this.addIgnore(username);\n                }\n                else if (action === 557) {\n                    this.removeFriend(username);\n                }\n                else if (action === 556) {\n                    this.removeIgnore(username);\n                }\n            }\n        }\n        else if (action === 651) {\n            const player = this.players[a];\n            if (player && this.localPlayer) {\n                this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], player.pathTileX[0], player.pathTileZ[0], 2, 1, 1, 0, 0, 0, false);\n                this.crossX = this.mouseClickX;\n                this.crossY = this.mouseClickY;\n                this.crossMode = 2;\n                this.crossCycle = 0;\n                // OPPLAYERT\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].OPPLAYERT);\n                this.out.p2(a);\n                this.out.p2(this.activeSpellId);\n            }\n        }\n        this.objSelected = 0;\n        this.spellSelected = 0;\n    };\n    handleInterfaceAction = (com) => {\n        const clientCode = com.clientCode;\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_ADD_FRIEND) {\n            this.redrawChatback = true;\n            this.chatbackInputOpen = false;\n            this.showSocialInput = true;\n            this.socialInput = '';\n            this.socialAction = 1;\n            this.socialMessage = 'Enter name of friend to add to list';\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_DEL_FRIEND) {\n            this.redrawChatback = true;\n            this.chatbackInputOpen = false;\n            this.showSocialInput = true;\n            this.socialInput = '';\n            this.socialAction = 2;\n            this.socialMessage = 'Enter name of friend to delete from list';\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_LOGOUT) {\n            this.idleTimeout = 250;\n            return true;\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_ADD_IGNORE) {\n            this.redrawChatback = true;\n            this.chatbackInputOpen = false;\n            this.showSocialInput = true;\n            this.socialInput = '';\n            this.socialAction = 4;\n            this.socialMessage = 'Enter name of player to add to list';\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_DEL_IGNORE) {\n            this.redrawChatback = true;\n            this.chatbackInputOpen = false;\n            this.showSocialInput = true;\n            this.socialInput = '';\n            this.socialAction = 5;\n            this.socialMessage = 'Enter name of player to delete from list';\n        }\n        // physical parts\n        if (clientCode >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_CHANGE_HEAD_L && clientCode <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_CHANGE_FEET_R) {\n            const part = ((clientCode - 300) / 2) | 0;\n            const direction = clientCode & 0x1;\n            let kit = this.designIdentikits[part];\n            if (kit !== -1) {\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    if (direction === 0) {\n                        kit--;\n                        if (kit < 0) {\n                            kit = _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].count - 1;\n                        }\n                    }\n                    if (direction === 1) {\n                        kit++;\n                        if (kit >= _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].count) {\n                            kit = 0;\n                        }\n                    }\n                    if (!_jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[kit].disable && _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[kit].type === part + (this.designGenderMale ? 0 : 7)) {\n                        this.designIdentikits[part] = kit;\n                        this.updateDesignModel = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // recoloring parts\n        if (clientCode >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_RECOLOUR_HAIR_L && clientCode <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_RECOLOUR_SKIN_R) {\n            const part = ((clientCode - 314) / 2) | 0;\n            const direction = clientCode & 0x1;\n            let color = this.designColors[part];\n            if (direction === 0) {\n                color--;\n                if (color < 0) {\n                    color = _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].DESIGN_IDK_COLORS[part].length - 1;\n                }\n            }\n            if (direction === 1) {\n                color++;\n                if (color >= _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].DESIGN_IDK_COLORS[part].length) {\n                    color = 0;\n                }\n            }\n            this.designColors[part] = color;\n            this.updateDesignModel = true;\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_SWITCH_TO_MALE && !this.designGenderMale) {\n            this.designGenderMale = true;\n            this.validateCharacterDesign();\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_SWITCH_TO_FEMALE && this.designGenderMale) {\n            this.designGenderMale = false;\n            this.validateCharacterDesign();\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_ACCEPT_DESIGN) {\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].IF_PLAYERDESIGN);\n            this.out.p1(this.designGenderMale ? 0 : 1);\n            for (let i = 0; i < 7; i++) {\n                this.out.p1(this.designIdentikits[i]);\n            }\n            for (let i = 0; i < 5; i++) {\n                this.out.p1(this.designColors[i]);\n            }\n            return true;\n        }\n        if (clientCode === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_MOD_MUTE) {\n            this.reportAbuseMuteOption = !this.reportAbuseMuteOption;\n        }\n        // reportabuse rules options\n        if (clientCode >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_REPORT_RULE1 && clientCode <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_REPORT_RULE12) {\n            this.closeInterfaces();\n            if (this.reportAbuseInput.length > 0) {\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].BUG_REPORT);\n                this.out.p8(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(this.reportAbuseInput));\n                this.out.p1(clientCode - 601);\n                this.out.p1(this.reportAbuseMuteOption ? 1 : 0);\n            }\n        }\n        return false;\n    };\n    validateCharacterDesign = () => {\n        this.updateDesignModel = true;\n        for (let i = 0; i < 7; i++) {\n            this.designIdentikits[i] = -1;\n            for (let j = 0; j < _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].count; j++) {\n                if (!_jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[j].disable && _jagex2_config_IdkType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[j].type === i + (this.designGenderMale ? 0 : 7)) {\n                    this.designIdentikits[i] = j;\n                    break;\n                }\n            }\n        }\n    };\n    interactWithLoc = (opcode, x, z, bitset) => {\n        if (!this.localPlayer || !this.scene) {\n            return false;\n        }\n        const locId = (bitset >> 14) & 0x7fff;\n        const info = this.scene.getInfo(this.currentLevel, x, z, bitset);\n        if (info === -1) {\n            return false;\n        }\n        const shape = info & 0x1f;\n        const angle = (info >> 6) & 0x3;\n        if (shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].CENTREPIECE_STRAIGHT.id || shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].CENTREPIECE_DIAGONAL.id || shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].GROUND_DECOR.id) {\n            const loc = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(locId);\n            let width;\n            let height;\n            if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].WEST || angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].EAST) {\n                width = loc.width;\n                height = loc.length;\n            }\n            else {\n                width = loc.length;\n                height = loc.width;\n            }\n            let forceapproach = loc.forceapproach;\n            if (angle !== 0) {\n                forceapproach = ((forceapproach << angle) & 0xf) + (forceapproach >> (4 - angle));\n            }\n            this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], x, z, 2, width, height, 0, 0, forceapproach, false);\n        }\n        else {\n            this.tryMove(this.localPlayer.pathTileX[0], this.localPlayer.pathTileZ[0], x, z, 2, 0, 0, angle, shape + 1, 0, false);\n        }\n        this.crossX = this.mouseClickX;\n        this.crossY = this.mouseClickY;\n        this.crossMode = 2;\n        this.crossCycle = 0;\n        this.out.p1isaac(opcode);\n        this.out.p2(x + this.sceneBaseTileX);\n        this.out.p2(z + this.sceneBaseTileZ);\n        this.out.p2(locId);\n        return true;\n    };\n    handleTabInput = () => {\n        if (this.mouseClickButton === 1) {\n            if (this.mouseClickX >= 549 && this.mouseClickX <= 583 && this.mouseClickY >= 195 && this.mouseClickY < 231 && this.tabInterfaceId[0] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 0;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 579 && this.mouseClickX <= 609 && this.mouseClickY >= 194 && this.mouseClickY < 231 && this.tabInterfaceId[1] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 1;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 607 && this.mouseClickX <= 637 && this.mouseClickY >= 194 && this.mouseClickY < 231 && this.tabInterfaceId[2] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 2;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 635 && this.mouseClickX <= 679 && this.mouseClickY >= 194 && this.mouseClickY < 229 && this.tabInterfaceId[3] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 3;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 676 && this.mouseClickX <= 706 && this.mouseClickY >= 194 && this.mouseClickY < 231 && this.tabInterfaceId[4] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 4;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 704 && this.mouseClickX <= 734 && this.mouseClickY >= 194 && this.mouseClickY < 231 && this.tabInterfaceId[5] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 5;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 732 && this.mouseClickX <= 766 && this.mouseClickY >= 195 && this.mouseClickY < 231 && this.tabInterfaceId[6] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 6;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 550 && this.mouseClickX <= 584 && this.mouseClickY >= 492 && this.mouseClickY < 528 && this.tabInterfaceId[7] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 7;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 582 && this.mouseClickX <= 612 && this.mouseClickY >= 492 && this.mouseClickY < 529 && this.tabInterfaceId[8] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 8;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 609 && this.mouseClickX <= 639 && this.mouseClickY >= 492 && this.mouseClickY < 529 && this.tabInterfaceId[9] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 9;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 637 && this.mouseClickX <= 681 && this.mouseClickY >= 493 && this.mouseClickY < 528 && this.tabInterfaceId[10] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 10;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 679 && this.mouseClickX <= 709 && this.mouseClickY >= 492 && this.mouseClickY < 529 && this.tabInterfaceId[11] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 11;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 706 && this.mouseClickX <= 736 && this.mouseClickY >= 492 && this.mouseClickY < 529 && this.tabInterfaceId[12] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 12;\n                this.redrawSideicons = true;\n            }\n            else if (this.mouseClickX >= 734 && this.mouseClickX <= 768 && this.mouseClickY >= 492 && this.mouseClickY < 528 && this.tabInterfaceId[13] !== -1) {\n                this.redrawSidebar = true;\n                this.selectedTab = 13;\n                this.redrawSideicons = true;\n            }\n            _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic1++;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic1 > 150) {\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic1 = 0;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_CYCLELOGIC1);\n                this.out.p1(43);\n            }\n        }\n    };\n    handleInputKey = async () => {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let key;\n            do {\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    key = this.pollKey();\n                    if (key === -1) {\n                        return;\n                    }\n                    if (this.viewportInterfaceId !== -1 && this.viewportInterfaceId === this.reportAbuseInterfaceID) {\n                        if (key === 8 && this.reportAbuseInput.length > 0) {\n                            this.reportAbuseInput = this.reportAbuseInput.substring(0, this.reportAbuseInput.length - 1);\n                        }\n                        break;\n                    }\n                    if (this.showSocialInput) {\n                        if (key >= 32 && key <= 122 && this.socialInput.length < 80) {\n                            this.socialInput = this.socialInput + String.fromCharCode(key);\n                            this.redrawChatback = true;\n                        }\n                        if (key === 8 && this.socialInput.length > 0) {\n                            this.socialInput = this.socialInput.substring(0, this.socialInput.length - 1);\n                            this.redrawChatback = true;\n                        }\n                        if (key === 13 || key === 10) {\n                            this.showSocialInput = false;\n                            this.redrawChatback = true;\n                            let username;\n                            if (this.socialAction === 1) {\n                                username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(this.socialInput);\n                                this.addFriend(username);\n                            }\n                            if (this.socialAction === 2 && this.friendCount > 0) {\n                                username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(this.socialInput);\n                                this.removeFriend(username);\n                            }\n                            if (this.socialAction === 3 && this.socialInput.length > 0 && this.socialName37) {\n                                // MESSAGE_PRIVATE\n                                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].MESSAGE_PRIVATE);\n                                this.out.p1(0);\n                                const start = this.out.pos;\n                                this.out.p8(this.socialName37);\n                                _jagex2_wordenc_WordPack__WEBPACK_IMPORTED_MODULE_24__[\"default\"].pack(this.out, this.socialInput);\n                                this.out.psize1(this.out.pos - start);\n                                this.socialInput = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toSentenceCase(this.socialInput);\n                                this.socialInput = _jagex2_wordenc_WordFilter__WEBPACK_IMPORTED_MODULE_23__[\"default\"].filter(this.socialInput);\n                                this.addMessage(6, this.socialInput, _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].fromBase37(this.socialName37)));\n                                if (this.privateChatSetting === 2) {\n                                    this.privateChatSetting = 1;\n                                    this.redrawPrivacySettings = true;\n                                    // CHAT_SETMODE\n                                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].CHAT_SETMODE);\n                                    this.out.p1(this.publicChatSetting);\n                                    this.out.p1(this.privateChatSetting);\n                                    this.out.p1(this.tradeChatSetting);\n                                }\n                            }\n                            if (this.socialAction === 4 && this.ignoreCount < 100) {\n                                username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(this.socialInput);\n                                this.addIgnore(username);\n                            }\n                            if (this.socialAction === 5 && this.ignoreCount > 0) {\n                                username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(this.socialInput);\n                                this.removeIgnore(username);\n                            }\n                        }\n                    }\n                    else if (this.chatbackInputOpen) {\n                        if (key >= 48 && key <= 57 && this.chatbackInput.length < 10) {\n                            this.chatbackInput = this.chatbackInput + String.fromCharCode(key);\n                            this.redrawChatback = true;\n                        }\n                        if (key === 8 && this.chatbackInput.length > 0) {\n                            this.chatbackInput = this.chatbackInput.substring(0, this.chatbackInput.length - 1);\n                            this.redrawChatback = true;\n                        }\n                        if (key === 13 || key === 10) {\n                            if (this.chatbackInput.length > 0) {\n                                let value = 0;\n                                try {\n                                    value = parseInt(this.chatbackInput, 10);\n                                }\n                                catch (e) {\n                                    /* empty */\n                                }\n                                // RESUME_P_COUNTDIALOG\n                                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].RESUME_P_COUNTDIALOG);\n                                this.out.p4(value);\n                            }\n                            this.chatbackInputOpen = false;\n                            this.redrawChatback = true;\n                        }\n                    }\n                    else if (this.chatInterfaceId === -1) {\n                        if (key >= 32 && key <= 122 && this.chatTyped.length < 80) {\n                            this.chatTyped = this.chatTyped + String.fromCharCode(key);\n                            this.redrawChatback = true;\n                        }\n                        if (key === 8 && this.chatTyped.length > 0) {\n                            this.chatTyped = this.chatTyped.substring(0, this.chatTyped.length - 1);\n                            this.redrawChatback = true;\n                        }\n                        if ((key === 13 || key === 10) && this.chatTyped.length > 0) {\n                            if (this.chatTyped === '::clientdrop' /* && super.frame*/) {\n                                await this.tryReconnect();\n                            }\n                            else if (this.rights && this.chatTyped === '::noclip') {\n                                for (let level = 0; level < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS; level++) {\n                                    for (let x = 1; x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1; x++) {\n                                        for (let z = 1; z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1; z++) {\n                                            const collisionMap = this.levelCollisionMap[level];\n                                            if (collisionMap) {\n                                                collisionMap.flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z)] = 0;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            else if (this.chatTyped === '::debug') {\n                                _client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug = !_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug;\n                            }\n                            else if (this.chatTyped === '::chat') {\n                                _client__WEBPACK_IMPORTED_MODULE_49__.Client.chatEra = (_client__WEBPACK_IMPORTED_MODULE_49__.Client.chatEra + 1) % 3;\n                            }\n                            else if (this.chatTyped.startsWith('::fps ')) {\n                                try {\n                                    this.setTargetedFramerate(parseInt(this.chatTyped.substring(6), 10));\n                                }\n                                catch (e) {\n                                    /* empty */\n                                }\n                            }\n                            else if (this.chatTyped.startsWith('::camera')) {\n                                _client__WEBPACK_IMPORTED_MODULE_49__.Client.cameraEditor = !_client__WEBPACK_IMPORTED_MODULE_49__.Client.cameraEditor;\n                                this.cutscene = _client__WEBPACK_IMPORTED_MODULE_49__.Client.cameraEditor;\n                                this.cutsceneDstLocalTileX = 52;\n                                this.cutsceneDstLocalTileZ = 52;\n                                this.cutsceneSrcLocalTileX = 52;\n                                this.cutsceneSrcLocalTileZ = 52;\n                                this.cutsceneSrcHeight = 1000;\n                                this.cutsceneDstHeight = 1000;\n                            }\n                            else if (this.chatTyped.startsWith('::camsrc ')) {\n                                const args = this.chatTyped.split(' ');\n                                if (args.length === 3) {\n                                    this.cutsceneSrcLocalTileX = parseInt(args[1], 10);\n                                    this.cutsceneSrcLocalTileZ = parseInt(args[2], 10);\n                                }\n                                else if (args.length === 4) {\n                                    this.cutsceneSrcLocalTileX = parseInt(args[1], 10);\n                                    this.cutsceneSrcLocalTileZ = parseInt(args[2], 10);\n                                    this.cutsceneSrcHeight = parseInt(args[3], 10);\n                                }\n                            }\n                            else if (this.chatTyped.startsWith('::camdst ')) {\n                                const args = this.chatTyped.split(' ');\n                                if (args.length === 3) {\n                                    this.cutsceneDstLocalTileX = parseInt(args[1], 10);\n                                    this.cutsceneDstLocalTileZ = parseInt(args[2], 10);\n                                }\n                                else if (args.length === 4) {\n                                    this.cutsceneDstLocalTileX = parseInt(args[1], 10);\n                                    this.cutsceneDstLocalTileZ = parseInt(args[2], 10);\n                                    this.cutsceneDstHeight = parseInt(args[3], 10);\n                                }\n                            }\n                            if (this.chatTyped.startsWith('::')) {\n                                // CLIENT_CHEAT\n                                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].CLIENT_CHEAT);\n                                this.out.p1(this.chatTyped.length - 1);\n                                this.out.pjstr(this.chatTyped.substring(2));\n                            }\n                            else {\n                                let color = 0;\n                                if (this.chatTyped.startsWith('yellow:')) {\n                                    color = 0;\n                                    this.chatTyped = this.chatTyped.substring(7);\n                                }\n                                else if (this.chatTyped.startsWith('red:')) {\n                                    color = 1;\n                                    this.chatTyped = this.chatTyped.substring(4);\n                                }\n                                else if (this.chatTyped.startsWith('green:')) {\n                                    color = 2;\n                                    this.chatTyped = this.chatTyped.substring(6);\n                                }\n                                else if (this.chatTyped.startsWith('cyan:')) {\n                                    color = 3;\n                                    this.chatTyped = this.chatTyped.substring(5);\n                                }\n                                else if (this.chatTyped.startsWith('purple:')) {\n                                    color = 4;\n                                    this.chatTyped = this.chatTyped.substring(7);\n                                }\n                                else if (this.chatTyped.startsWith('white:')) {\n                                    color = 5;\n                                    this.chatTyped = this.chatTyped.substring(6);\n                                }\n                                else if (this.chatTyped.startsWith('flash1:')) {\n                                    color = 6;\n                                    this.chatTyped = this.chatTyped.substring(7);\n                                }\n                                else if (this.chatTyped.startsWith('flash2:')) {\n                                    color = 7;\n                                    this.chatTyped = this.chatTyped.substring(7);\n                                }\n                                else if (this.chatTyped.startsWith('flash3:')) {\n                                    color = 8;\n                                    this.chatTyped = this.chatTyped.substring(7);\n                                }\n                                else if (this.chatTyped.startsWith('glow1:')) {\n                                    color = 9;\n                                    this.chatTyped = this.chatTyped.substring(6);\n                                }\n                                else if (this.chatTyped.startsWith('glow2:')) {\n                                    color = 10;\n                                    this.chatTyped = this.chatTyped.substring(6);\n                                }\n                                else if (this.chatTyped.startsWith('glow3:')) {\n                                    color = 11;\n                                    this.chatTyped = this.chatTyped.substring(6);\n                                }\n                                let effect = 0;\n                                if (this.chatTyped.startsWith('wave:')) {\n                                    effect = 1;\n                                    this.chatTyped = this.chatTyped.substring(5);\n                                }\n                                if (this.chatTyped.startsWith('scroll:')) {\n                                    effect = 2;\n                                    this.chatTyped = this.chatTyped.substring(7);\n                                }\n                                // MESSAGE_PUBLIC\n                                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].MESSAGE_PUBLIC);\n                                this.out.p1(0);\n                                const start = this.out.pos;\n                                this.out.p1(color);\n                                this.out.p1(effect);\n                                _jagex2_wordenc_WordPack__WEBPACK_IMPORTED_MODULE_24__[\"default\"].pack(this.out, this.chatTyped);\n                                this.out.psize1(this.out.pos - start);\n                                this.chatTyped = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toSentenceCase(this.chatTyped);\n                                this.chatTyped = _jagex2_wordenc_WordFilter__WEBPACK_IMPORTED_MODULE_23__[\"default\"].filter(this.chatTyped);\n                                if (this.localPlayer && this.localPlayer.name) {\n                                    this.localPlayer.chat = this.chatTyped;\n                                    this.localPlayer.chatColor = color;\n                                    this.localPlayer.chatStyle = effect;\n                                    this.localPlayer.chatTimer = 150;\n                                    this.addMessage(2, this.localPlayer.chat, this.localPlayer.name);\n                                }\n                                if (this.publicChatSetting === 2) {\n                                    this.publicChatSetting = 3;\n                                    this.redrawPrivacySettings = true;\n                                    // CHAT_SETMODE\n                                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].CHAT_SETMODE);\n                                    this.out.p1(this.publicChatSetting);\n                                    this.out.p1(this.privateChatSetting);\n                                    this.out.p1(this.tradeChatSetting);\n                                }\n                            }\n                            this.chatTyped = '';\n                            this.redrawChatback = true;\n                        }\n                    }\n                }\n            } while ((key < 97 || key > 122) && (key < 65 || key > 90) && (key < 48 || key > 57) && key !== 32);\n            if (this.reportAbuseInput.length < 12) {\n                this.reportAbuseInput = this.reportAbuseInput + String.fromCharCode(key);\n            }\n        }\n    };\n    handleChatSettingsInput = () => {\n        if (this.mouseClickButton === 1) {\n            if (this.mouseClickX >= 8 && this.mouseClickX <= 108 && this.mouseClickY >= 490 && this.mouseClickY <= 522) {\n                this.publicChatSetting = (this.publicChatSetting + 1) % 4;\n                this.redrawPrivacySettings = true;\n                this.redrawChatback = true;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].CHAT_SETMODE);\n                this.out.p1(this.publicChatSetting);\n                this.out.p1(this.privateChatSetting);\n                this.out.p1(this.tradeChatSetting);\n            }\n            else if (this.mouseClickX >= 137 && this.mouseClickX <= 237 && this.mouseClickY >= 490 && this.mouseClickY <= 522) {\n                this.privateChatSetting = (this.privateChatSetting + 1) % 3;\n                this.redrawPrivacySettings = true;\n                this.redrawChatback = true;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].CHAT_SETMODE);\n                this.out.p1(this.publicChatSetting);\n                this.out.p1(this.privateChatSetting);\n                this.out.p1(this.tradeChatSetting);\n            }\n            else if (this.mouseClickX >= 275 && this.mouseClickX <= 375 && this.mouseClickY >= 490 && this.mouseClickY <= 522) {\n                this.tradeChatSetting = (this.tradeChatSetting + 1) % 3;\n                this.redrawPrivacySettings = true;\n                this.redrawChatback = true;\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].CHAT_SETMODE);\n                this.out.p1(this.publicChatSetting);\n                this.out.p1(this.privateChatSetting);\n                this.out.p1(this.tradeChatSetting);\n            }\n            else if (this.mouseClickX >= 416 && this.mouseClickX <= 516 && this.mouseClickY >= 490 && this.mouseClickY <= 522) {\n                this.closeInterfaces();\n                this.reportAbuseInput = '';\n                this.reportAbuseMuteOption = false;\n                for (let i = 0; i < _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances.length; i++) {\n                    if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i] && _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i].clientCode === 600) {\n                        this.reportAbuseInterfaceID = this.viewportInterfaceId = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i].layer;\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    handleScrollInput = (mouseX, mouseY, scrollableHeight, height, redraw, left, top, component) => {\n        if (this.scrollGrabbed) {\n            this.scrollInputPadding = 32;\n        }\n        else {\n            this.scrollInputPadding = 0;\n        }\n        this.scrollGrabbed = false;\n        if (mouseX >= left && mouseX < left + 16 && mouseY >= top && mouseY < top + 16) {\n            component.scrollPosition -= this.dragCycles * 4;\n            if (redraw) {\n                this.redrawSidebar = true;\n            }\n        }\n        else if (mouseX >= left && mouseX < left + 16 && mouseY >= top + height - 16 && mouseY < top + height) {\n            component.scrollPosition += this.dragCycles * 4;\n            if (redraw) {\n                this.redrawSidebar = true;\n            }\n        }\n        else if (mouseX >= left - this.scrollInputPadding && mouseX < left + this.scrollInputPadding + 16 && mouseY >= top + 16 && mouseY < top + height - 16 && this.dragCycles > 0) {\n            let gripSize = (((height - 32) * height) / scrollableHeight) | 0;\n            if (gripSize < 8) {\n                gripSize = 8;\n            }\n            const gripY = mouseY - top - ((gripSize / 2) | 0) - 16;\n            const maxY = height - gripSize - 32;\n            component.scrollPosition = (((scrollableHeight - height) * gripY) / maxY) | 0;\n            if (redraw) {\n                this.redrawSidebar = true;\n            }\n            this.scrollGrabbed = true;\n        }\n    };\n    prepareGameScreen = () => {\n        if (!this.areaChatback) {\n            this.unloadTitle();\n            this.drawArea = null;\n            this.imageTitle2 = null;\n            this.imageTitle3 = null;\n            this.imageTitle4 = null;\n            this.imageTitle0 = null;\n            this.imageTitle1 = null;\n            this.imageTitle5 = null;\n            this.imageTitle6 = null;\n            this.imageTitle7 = null;\n            this.imageTitle8 = null;\n            this.areaChatback = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](479, 96);\n            this.areaMapback = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](168, 160);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.imageMapback?.draw(0, 0);\n            this.areaSidebar = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](190, 261);\n            this.areaViewport = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](512, 334);\n            _jagex2_graphics_Draw2D__WEBPACK_IMPORTED_MODULE_9__[\"default\"].clear();\n            this.areaBackbase1 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](501, 61);\n            this.areaBackbase2 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](288, 40);\n            this.areaBackhmid1 = new _jagex2_graphics_PixMap__WEBPACK_IMPORTED_MODULE_8__[\"default\"](269, 66);\n            this.redrawTitleBackground = true;\n        }\n    };\n    isFriend = (username) => {\n        if (!username) {\n            return false;\n        }\n        for (let i = 0; i < this.friendCount; i++) {\n            if (username.toLowerCase() === this.friendName[i]?.toLowerCase()) {\n                return true;\n            }\n        }\n        if (!this.localPlayer) {\n            return false;\n        }\n        return username.toLowerCase() === this.localPlayer.name?.toLowerCase();\n    };\n    addFriend = (username) => {\n        if (username === 0n) {\n            return;\n        }\n        if (this.friendCount >= 100) {\n            this.addMessage(0, 'Your friends list is full. Max of 100 hit', '');\n            return;\n        }\n        const displayName = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].fromBase37(username));\n        for (let i = 0; i < this.friendCount; i++) {\n            if (this.friendName37[i] === username) {\n                this.addMessage(0, displayName + ' is already on your friend list', '');\n                return;\n            }\n        }\n        for (let i = 0; i < this.ignoreCount; i++) {\n            if (this.ignoreName37[i] === username) {\n                this.addMessage(0, 'Please remove ' + displayName + ' from your ignore list first', '');\n                return;\n            }\n        }\n        if (!this.localPlayer || !this.localPlayer.name) {\n            return;\n        }\n        if (displayName !== this.localPlayer.name) {\n            this.friendName[this.friendCount] = displayName;\n            this.friendName37[this.friendCount] = username;\n            this.friendWorld[this.friendCount] = 0;\n            this.friendCount++;\n            this.redrawSidebar = true;\n            // FRIENDLIST_ADD\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].FRIENDLIST_ADD);\n            this.out.p8(username);\n        }\n    };\n    removeFriend = (username) => {\n        if (username === 0n) {\n            return;\n        }\n        for (let i = 0; i < this.friendCount; i++) {\n            if (this.friendName37[i] === username) {\n                this.friendCount--;\n                this.redrawSidebar = true;\n                for (let j = i; j < this.friendCount; j++) {\n                    this.friendName[j] = this.friendName[j + 1];\n                    this.friendWorld[j] = this.friendWorld[j + 1];\n                    this.friendName37[j] = this.friendName37[j + 1];\n                }\n                // FRIENDLIST_DEL\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].FRIENDLIST_DEL);\n                this.out.p8(username);\n                return;\n            }\n        }\n    };\n    addIgnore = (username) => {\n        if (username === 0n) {\n            return;\n        }\n        if (this.ignoreCount >= 100) {\n            this.addMessage(0, 'Your ignore list is full. Max of 100 hit', '');\n            return;\n        }\n        const displayName = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].fromBase37(username));\n        for (let i = 0; i < this.ignoreCount; i++) {\n            if (this.ignoreName37[i] === username) {\n                this.addMessage(0, displayName + ' is already on your ignore list', '');\n                return;\n            }\n        }\n        for (let i = 0; i < this.friendCount; i++) {\n            if (this.friendName37[i] === username) {\n                this.addMessage(0, 'Please remove ' + displayName + ' from your friend list first', '');\n                return;\n            }\n        }\n        this.ignoreName37[this.ignoreCount++] = username;\n        this.redrawSidebar = true;\n        // IGNORELIST_ADD\n        this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].IGNORELIST_ADD);\n        this.out.p8(username);\n    };\n    removeIgnore = (username) => {\n        if (username === 0n) {\n            return;\n        }\n        for (let i = 0; i < this.ignoreCount; i++) {\n            if (this.ignoreName37[i] === username) {\n                this.ignoreCount--;\n                this.redrawSidebar = true;\n                for (let j = i; j < this.ignoreCount; j++) {\n                    this.ignoreName37[j] = this.ignoreName37[j + 1];\n                }\n                // IGNORELIST_DEL\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].IGNORELIST_DEL);\n                this.out.p8(username);\n                return;\n            }\n        }\n    };\n    sortObjStacks = (x, z) => {\n        const objStacks = this.levelObjStacks[this.currentLevel][x][z];\n        if (!objStacks) {\n            this.scene?.removeObjStack(this.currentLevel, x, z);\n            return;\n        }\n        let topCost = -99999999;\n        let topObj = null;\n        for (let obj = objStacks.head(); obj; obj = objStacks.next()) {\n            const type = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(obj.index);\n            let cost = type.cost;\n            if (type.stackable) {\n                cost *= obj.count + 1;\n            }\n            if (cost > topCost) {\n                topCost = cost;\n                topObj = obj;\n            }\n        }\n        if (!topObj) {\n            return; // custom\n        }\n        objStacks.addHead(topObj);\n        let bottomObjId = -1;\n        let middleObjId = -1;\n        let bottomObjCount = 0;\n        let middleObjCount = 0;\n        for (let obj = objStacks.head(); obj; obj = objStacks.next()) {\n            if (obj.index !== topObj.index && bottomObjId === -1) {\n                bottomObjId = obj.index;\n                bottomObjCount = obj.count;\n            }\n            if (obj.index !== topObj.index && obj.index !== bottomObjId && middleObjId === -1) {\n                middleObjId = obj.index;\n                middleObjCount = obj.count;\n            }\n        }\n        let bottomObj = null;\n        if (bottomObjId !== -1) {\n            bottomObj = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(bottomObjId).getInterfaceModel(bottomObjCount);\n        }\n        let middleObj = null;\n        if (middleObjId !== -1) {\n            middleObj = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(middleObjId).getInterfaceModel(middleObjCount);\n        }\n        const bitset = (x + (z << 7) + 0x60000000) | 0;\n        const type = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(topObj.index);\n        this.scene?.addObjStack(x, z, this.getHeightmapY(this.currentLevel, x * 128 + 64, z * 128 + 64), this.currentLevel, bitset, type.getInterfaceModel(topObj.count), middleObj, bottomObj);\n    };\n    addLoc = (level, x, z, id, angle, shape, layer) => {\n        if (x < 1 || z < 1 || x > 102 || z > 102) {\n            return;\n        }\n        if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory && level !== this.currentLevel) {\n            return;\n        }\n        if (!this.scene) {\n            return;\n        }\n        let bitset = 0;\n        if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL) {\n            bitset = this.scene.getWallBitset(level, x, z);\n        }\n        if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL_DECOR) {\n            bitset = this.scene.getWallDecorationBitset(level, z, x);\n        }\n        if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND) {\n            bitset = this.scene.getLocBitset(level, x, z);\n        }\n        if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND_DECOR) {\n            bitset = this.scene.getGroundDecorationBitset(level, x, z);\n        }\n        if (bitset !== 0) {\n            const otherInfo = this.scene.getInfo(level, x, z, bitset);\n            const otherId = (bitset >> 14) & 0x7fff;\n            const otherShape = otherInfo & 0x1f;\n            const otherRotation = otherInfo >> 6;\n            if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL) {\n                this.scene?.removeWall(level, x, z, 1);\n                const type = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(otherId);\n                if (type.blockwalk) {\n                    this.levelCollisionMap[level]?.removeWall(x, z, otherShape, otherRotation, type.blockrange);\n                }\n            }\n            if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL_DECOR) {\n                this.scene?.removeWallDecoration(level, x, z);\n            }\n            if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND) {\n                this.scene.removeLoc(level, x, z);\n                const type = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(otherId);\n                if (x + type.width > _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1 || z + type.width > _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1 || x + type.length > _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1 || z + type.length > _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1) {\n                    return;\n                }\n                if (type.blockwalk) {\n                    this.levelCollisionMap[level]?.removeLoc(x, z, type.width, type.length, otherRotation, type.blockrange);\n                }\n            }\n            if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND_DECOR) {\n                this.scene?.removeGroundDecoration(level, x, z);\n                const type = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(otherId);\n                if (type.blockwalk && type.active) {\n                    this.levelCollisionMap[level]?.removeFloor(x, z);\n                }\n            }\n        }\n        if (id >= 0) {\n            let tileLevel = level;\n            if (this.levelTileFlags && level < 3 && (this.levelTileFlags[1][x][z] & 0x2) === 2) {\n                tileLevel = level + 1;\n            }\n            if (this.levelHeightmap) {\n                _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__[\"default\"].addLoc(level, x, z, this.scene, this.levelHeightmap, this.locList, this.levelCollisionMap[level], id, shape, angle, tileLevel);\n            }\n        }\n    };\n    closeInterfaces = () => {\n        this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].CLOSE_MODAL);\n        if (this.sidebarInterfaceId !== -1) {\n            this.sidebarInterfaceId = -1;\n            this.redrawSidebar = true;\n            this.pressedContinueOption = false;\n            this.redrawSideicons = true;\n        }\n        if (this.chatInterfaceId !== -1) {\n            this.chatInterfaceId = -1;\n            this.redrawChatback = true;\n            this.pressedContinueOption = false;\n        }\n        this.viewportInterfaceId = -1;\n    };\n    tryReconnect = async () => {\n        if (this.idleTimeout > 0) {\n            await this.logout();\n        }\n        else {\n            this.areaViewport?.bind();\n            this.fontPlain12?.drawStringCenter(257, 144, 'Connection lost', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n            this.fontPlain12?.drawStringCenter(256, 143, 'Connection lost', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n            this.fontPlain12?.drawStringCenter(257, 159, 'Please wait - attempting to reestablish', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n            this.fontPlain12?.drawStringCenter(256, 158, 'Please wait - attempting to reestablish', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n            this.areaViewport?.draw(8, 11);\n            this.flagSceneTileX = 0;\n            this.stream?.close();\n            this.ingame = false;\n            await this.login(this.username, this.password, true);\n            if (!this.ingame) {\n                await this.logout();\n            }\n        }\n    };\n    logout = async () => {\n        if (this.stream) {\n            this.stream.close();\n        }\n        this.stream = null;\n        this.ingame = false;\n        this.titleScreenState = 0;\n        this.username = '';\n        this.password = '';\n        _jagex2_client_InputTracking__WEBPACK_IMPORTED_MODULE_30__[\"default\"].setDisabled();\n        this.clearCaches();\n        this.scene?.reset();\n        for (let level = 0; level < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS; level++) {\n            this.levelCollisionMap[level]?.reset();\n        }\n        (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.stopMidi)();\n        this.currentMidi = null;\n        this.nextMusicDelay = 0;\n        if (!_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory) {\n            await this.setMidi('scape_main', 12345678, 40000);\n        }\n    };\n    read = async () => {\n        if (!this.stream) {\n            return false;\n        }\n        try {\n            let available = this.stream.available;\n            if (available === 0) {\n                return false;\n            }\n            if (this.packetType === -1) {\n                await this.stream.readBytes(this.in.data, 0, 1);\n                this.packetType = this.in.data[0] & 0xff;\n                if (this.randomIn) {\n                    this.packetType = (this.packetType - this.randomIn.nextInt) & 0xff;\n                }\n                this.packetSize = _jagex2_io_Protocol__WEBPACK_IMPORTED_MODULE_18__[\"default\"].SERVERPROT_SIZES[this.packetType];\n                available--;\n            }\n            if (this.packetSize === -1) {\n                if (available <= 0) {\n                    return false;\n                }\n                await this.stream.readBytes(this.in.data, 0, 1);\n                this.packetSize = this.in.data[0] & 0xff;\n                available--;\n            }\n            if (this.packetSize === -2) {\n                if (available <= 1) {\n                    return false;\n                }\n                await this.stream.readBytes(this.in.data, 0, 2);\n                this.in.pos = 0;\n                this.packetSize = this.in.g2;\n                available -= 2;\n            }\n            if (available < this.packetSize) {\n                return false;\n            }\n            this.in.pos = 0;\n            await this.stream.readBytes(this.in.data, 0, this.packetSize);\n            this.idleNetCycles = 0;\n            this.lastPacketType2 = this.lastPacketType1;\n            this.lastPacketType1 = this.lastPacketType0;\n            this.lastPacketType0 = this.packetType;\n            // console.log(`Incoming packet: ${this.packetType}`);\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].VARP_SMALL) {\n                // VARP_SMALL\n                const varp = this.in.g2;\n                const value = this.in.g1b;\n                this.varCache[varp] = value;\n                if (this.varps[varp] !== value) {\n                    this.varps[varp] = value;\n                    await this.updateVarp(varp);\n                    this.redrawSidebar = true;\n                    if (this.stickyChatInterfaceId !== -1) {\n                        this.redrawChatback = true;\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_FRIENDLIST) {\n                // UPDATE_FRIENDLIST\n                const username = this.in.g8;\n                const world = this.in.g1;\n                let displayName = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].fromBase37(username));\n                for (let i = 0; i < this.friendCount; i++) {\n                    if (username === this.friendName37[i]) {\n                        if (this.friendWorld[i] !== world) {\n                            this.friendWorld[i] = world;\n                            this.redrawSidebar = true;\n                            if (world > 0) {\n                                this.addMessage(5, displayName + ' has logged in.', '');\n                            }\n                            if (world === 0) {\n                                this.addMessage(5, displayName + ' has logged out.', '');\n                            }\n                        }\n                        displayName = null;\n                        break;\n                    }\n                }\n                if (displayName && this.friendCount < 100) {\n                    this.friendName37[this.friendCount] = username;\n                    this.friendName[this.friendCount] = displayName;\n                    this.friendWorld[this.friendCount] = world;\n                    this.friendCount++;\n                    this.redrawSidebar = true;\n                }\n                let sorted = false;\n                while (!sorted) {\n                    sorted = true;\n                    for (let i = 0; i < this.friendCount - 1; i++) {\n                        if ((this.friendWorld[i] !== _client__WEBPACK_IMPORTED_MODULE_49__.Client.nodeId && this.friendWorld[i + 1] === _client__WEBPACK_IMPORTED_MODULE_49__.Client.nodeId) || (this.friendWorld[i] === 0 && this.friendWorld[i + 1] !== 0)) {\n                            const oldWorld = this.friendWorld[i];\n                            this.friendWorld[i] = this.friendWorld[i + 1];\n                            this.friendWorld[i + 1] = oldWorld;\n                            const oldName = this.friendName[i];\n                            this.friendName[i] = this.friendName[i + 1];\n                            this.friendName[i + 1] = oldName;\n                            const oldName37 = this.friendName37[i];\n                            this.friendName37[i] = this.friendName37[i + 1];\n                            this.friendName37[i + 1] = oldName37;\n                            this.redrawSidebar = true;\n                            sorted = false;\n                        }\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_REBOOT_TIMER) {\n                // UPDATE_REBOOT_TIMER\n                this.systemUpdateTimer = this.in.g2 * 30;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].DATA_LAND_DONE) {\n                // DATA_LAND_DONE\n                const x = this.in.g1;\n                const z = this.in.g1;\n                let index = -1;\n                if (this.sceneMapIndex) {\n                    for (let i = 0; i < this.sceneMapIndex.length; i++) {\n                        if (this.sceneMapIndex[i] === (x << 8) + z) {\n                            index = i;\n                        }\n                    }\n                }\n                if (index !== -1) {\n                    const mapdata = this.sceneMapLandData;\n                    if (mapdata) {\n                        const data = mapdata[index];\n                        if (index !== -1 && data) {\n                            this.db?.cachesave(`m${x}_${z}`, data);\n                            this.sceneState = 1;\n                        }\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].NPC_INFO) {\n                // NPC_INFO\n                this.readNpcInfo(this.in, this.packetSize);\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].REBUILD_NORMAL) {\n                // LOAD_AREA\n                const zoneX = this.in.g2;\n                const zoneZ = this.in.g2;\n                if (this.sceneCenterZoneX === zoneX && this.sceneCenterZoneZ === zoneZ && this.sceneState !== 0) {\n                    this.packetType = -1;\n                    return true;\n                }\n                this.sceneCenterZoneX = zoneX;\n                this.sceneCenterZoneZ = zoneZ;\n                this.sceneBaseTileX = (this.sceneCenterZoneX - 6) * 8;\n                this.sceneBaseTileZ = (this.sceneCenterZoneZ - 6) * 8;\n                this.sceneState = 1;\n                this.areaViewport?.bind();\n                this.fontPlain12?.drawStringCenter(257, 151, 'Loading - please wait.', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                this.fontPlain12?.drawStringCenter(256, 150, 'Loading - please wait.', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                this.areaViewport?.draw(8, 11);\n                // signlink.looprate(5);\n                const regions = ((this.packetSize - 2) / 10) | 0;\n                this.sceneMapLandData = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_48__.TypedArray1d(regions, null);\n                this.sceneMapLocData = new _jagex2_util_Arrays__WEBPACK_IMPORTED_MODULE_48__.TypedArray1d(regions, null);\n                this.sceneMapIndex = new Int32Array(regions);\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].REBUILD_GETMAPS);\n                this.out.p1(0);\n                let mapCount = 0;\n                for (let i = 0; i < regions; i++) {\n                    const mapsquareX = this.in.g1;\n                    const mapsquareZ = this.in.g1;\n                    const landCrc = this.in.g4;\n                    const locCrc = this.in.g4;\n                    this.sceneMapIndex[i] = (mapsquareX << 8) + mapsquareZ;\n                    let data;\n                    if (landCrc !== 0) {\n                        data = await this.db?.cacheload(`m${mapsquareX}_${mapsquareZ}`);\n                        // if (data && Packet.crc32(data) !== landCrc) {\n                        //     data = undefined;\n                        // }\n                        if (!data) {\n                            this.sceneState = 0;\n                            this.out.p1(0); // map request\n                            this.out.p1(mapsquareX);\n                            this.out.p1(mapsquareZ);\n                            mapCount += 3;\n                        }\n                        else {\n                            this.sceneMapLandData[i] = data;\n                        }\n                    }\n                    if (locCrc !== 0) {\n                        data = await this.db?.cacheload(`l${mapsquareX}_${mapsquareZ}`);\n                        // if (data && Packet.crc32(data) !== locCrc) {\n                        //     data = undefined;\n                        // }\n                        if (!data) {\n                            this.sceneState = 0;\n                            this.out.p1(1); // loc request\n                            this.out.p1(mapsquareX);\n                            this.out.p1(mapsquareZ);\n                            mapCount += 3;\n                        }\n                        else {\n                            this.sceneMapLocData[i] = data;\n                        }\n                    }\n                }\n                this.out.psize1(mapCount);\n                // signlink.looprate(50);\n                this.areaViewport?.bind();\n                if (this.sceneState === 0) {\n                    this.fontPlain12?.drawStringCenter(257, 166, 'Map area updated since last visit, so load will take longer this time only', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                    this.fontPlain12?.drawStringCenter(256, 165, 'Map area updated since last visit, so load will take longer this time only', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                }\n                this.areaViewport?.draw(8, 11);\n                const dx = this.sceneBaseTileX - this.mapLastBaseX;\n                const dz = this.sceneBaseTileZ - this.mapLastBaseZ;\n                this.mapLastBaseX = this.sceneBaseTileX;\n                this.mapLastBaseZ = this.sceneBaseTileZ;\n                for (let i = 0; i < 8192; i++) {\n                    const npc = this.npcs[i];\n                    if (npc) {\n                        for (let j = 0; j < 10; j++) {\n                            npc.pathTileX[j] -= dx;\n                            npc.pathTileZ[j] -= dz;\n                        }\n                        npc.x -= dx * 128;\n                        npc.z -= dz * 128;\n                    }\n                }\n                for (let i = 0; i < this.MAX_PLAYER_COUNT; i++) {\n                    const player = this.players[i];\n                    if (player) {\n                        for (let j = 0; j < 10; j++) {\n                            player.pathTileX[j] -= dx;\n                            player.pathTileZ[j] -= dz;\n                        }\n                        player.x -= dx * 128;\n                        player.z -= dz * 128;\n                    }\n                }\n                let startTileX = 0;\n                let endTileX = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE;\n                let dirX = 1;\n                if (dx < 0) {\n                    startTileX = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1;\n                    endTileX = -1;\n                    dirX = -1;\n                }\n                let startTileZ = 0;\n                let endTileZ = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE;\n                let dirZ = 1;\n                if (dz < 0) {\n                    startTileZ = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1;\n                    endTileZ = -1;\n                    dirZ = -1;\n                }\n                for (let x = startTileX; x !== endTileX; x += dirX) {\n                    for (let z = startTileZ; z !== endTileZ; z += dirZ) {\n                        const lastX = x + dx;\n                        const lastZ = z + dz;\n                        for (let level = 0; level < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS; level++) {\n                            if (lastX >= 0 && lastZ >= 0 && lastX < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && lastZ < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                                this.levelObjStacks[level][x][z] = this.levelObjStacks[level][lastX][lastZ];\n                            }\n                            else {\n                                this.levelObjStacks[level][x][z] = null;\n                            }\n                        }\n                    }\n                }\n                for (let loc = this.spawnedLocations.head(); loc; loc = this.spawnedLocations.next()) {\n                    loc.x -= dx;\n                    loc.z -= dz;\n                    if (loc.x < 0 || loc.z < 0 || loc.x >= _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE || loc.z >= _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                        loc.unlink();\n                    }\n                }\n                if (this.flagSceneTileX !== 0) {\n                    this.flagSceneTileX -= dx;\n                    this.flagSceneTileZ -= dz;\n                }\n                this.cutscene = false;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETPLAYERHEAD) {\n                // IF_SETPLAYERHEAD\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.in.g2].model = this.localPlayer?.getHeadModel() || null;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].HINT_ARROW) {\n                this.hintType = this.in.g1;\n                if (this.hintType === 1) {\n                    this.hintNpc = this.in.g2;\n                }\n                if (this.hintType >= 2 && this.hintType <= 6) {\n                    if (this.hintType === 2) {\n                        this.hintOffsetX = 64;\n                        this.hintOffsetZ = 64;\n                    }\n                    if (this.hintType === 3) {\n                        this.hintOffsetX = 0;\n                        this.hintOffsetZ = 64;\n                    }\n                    if (this.hintType === 4) {\n                        this.hintOffsetX = 128;\n                        this.hintOffsetZ = 64;\n                    }\n                    if (this.hintType === 5) {\n                        this.hintOffsetX = 64;\n                        this.hintOffsetZ = 0;\n                    }\n                    if (this.hintType === 6) {\n                        this.hintOffsetX = 64;\n                        this.hintOffsetZ = 128;\n                    }\n                    this.hintType = 2;\n                    this.hintTileX = this.in.g2;\n                    this.hintTileZ = this.in.g2;\n                    this.hintHeight = this.in.g1;\n                }\n                if (this.hintType === 10) {\n                    this.hintPlayer = this.in.g2;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MIDI_SONG) {\n                // MIDI_SONG\n                const name = this.in.gjstr;\n                const crc = this.in.g4;\n                const length = this.in.g4;\n                if (!(name === this.currentMidi) && this.midiActive && !_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory) {\n                    await this.setMidi(name, crc, length);\n                }\n                this.currentMidi = name;\n                this.midiCrc = crc;\n                this.midiSize = length;\n                this.nextMusicDelay = 0;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOGOUT) {\n                // LOGOUT\n                await this.logout();\n                this.packetType = -1;\n                return false;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].DATA_LOC_DONE) {\n                // DATA_LOC_DONE\n                const x = this.in.g1;\n                const z = this.in.g1;\n                let index = -1;\n                if (this.sceneMapIndex) {\n                    for (let i = 0; i < this.sceneMapIndex.length; i++) {\n                        if (this.sceneMapIndex[i] === (x << 8) + z) {\n                            index = i;\n                        }\n                    }\n                }\n                if (index !== -1) {\n                    const mapdata = this.sceneMapLocData;\n                    if (mapdata) {\n                        const data = mapdata[index];\n                        if (index !== -1 && data) {\n                            this.db?.cachesave(`l${x}_${z}`, data);\n                            this.sceneState = 1;\n                        }\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UNSET_MAP_FLAG) {\n                // CLEAR_WALKING_QUEUE\n                this.flagSceneTileX = 0;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_UID192) {\n                // UPDATE_UID192\n                this.localPid = this.in.g2;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_COUNT ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_MERGE ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_REVEAL ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MAP_ANIM ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MAP_PROJANIM ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_DEL ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_ADD ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_ANIM ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_DEL ||\n                this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_ADD_CHANGE) {\n                // Zone Protocol\n                this.readZonePacket(this.in, this.packetType);\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_OPENMAINSIDEMODAL) {\n                // IF_OPENMAINMODALSIDEOVERLAY\n                const main = this.in.g2;\n                const side = this.in.g2;\n                if (this.chatInterfaceId !== -1) {\n                    this.chatInterfaceId = -1;\n                    this.redrawChatback = true;\n                }\n                if (this.chatbackInputOpen) {\n                    this.chatbackInputOpen = false;\n                    this.redrawChatback = true;\n                }\n                this.viewportInterfaceId = main;\n                this.sidebarInterfaceId = side;\n                this.redrawSidebar = true;\n                this.redrawSideicons = true;\n                this.pressedContinueOption = false;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].VARP_LARGE) {\n                // VARP_LARGE\n                const varp = this.in.g2;\n                const value = this.in.g4;\n                this.varCache[varp] = value;\n                if (this.varps[varp] !== value) {\n                    this.varps[varp] = value;\n                    await this.updateVarp(varp);\n                    this.redrawSidebar = true;\n                    if (this.stickyChatInterfaceId !== -1) {\n                        this.redrawChatback = true;\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETANIM) {\n                // IF_SETANIM\n                const com = this.in.g2;\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].anim = this.in.g2;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_OPENSIDEOVERLAY) {\n                // IF_SETTAB\n                let com = this.in.g2;\n                const tab = this.in.g1;\n                if (com === 65535) {\n                    com = -1;\n                }\n                this.tabInterfaceId[tab] = com;\n                this.redrawSidebar = true;\n                this.redrawSideicons = true;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].DATA_LOC) {\n                // DATA_LOC\n                const x = this.in.g1;\n                const z = this.in.g1;\n                const off = this.in.g2;\n                const length = this.in.g2;\n                let index = -1;\n                if (this.sceneMapIndex) {\n                    for (let i = 0; i < this.sceneMapIndex.length; i++) {\n                        if (this.sceneMapIndex[i] === (x << 8) + z) {\n                            index = i;\n                        }\n                    }\n                }\n                if (index !== -1 && this.sceneMapLocData) {\n                    if (!this.sceneMapLocData[index] || this.sceneMapLocData[index]?.length !== length) {\n                        this.sceneMapLocData[index] = new Int8Array(length);\n                    }\n                    const data = this.sceneMapLocData[index];\n                    if (data) {\n                        this.in.gdata(this.packetSize - 6, off, data);\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].FINISH_TRACKING) {\n                // FINISH_TRACKING\n                const tracking = _jagex2_client_InputTracking__WEBPACK_IMPORTED_MODULE_30__[\"default\"].stop();\n                if (tracking) {\n                    this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].EVENT_TRACKING);\n                    this.out.p2(tracking.pos);\n                    this.out.pdata(tracking.data, tracking.pos, 0);\n                    tracking.release();\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_INV_FULL) {\n                // UPDATE_INV_FULL\n                this.redrawSidebar = true;\n                const com = this.in.g2;\n                const inv = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com];\n                const size = this.in.g1;\n                if (inv.invSlotObjId && inv.invSlotObjCount) {\n                    for (let i = 0; i < size; i++) {\n                        inv.invSlotObjId[i] = this.in.g2;\n                        let count = this.in.g1;\n                        if (count === 255) {\n                            count = this.in.g4;\n                        }\n                        inv.invSlotObjCount[i] = count;\n                    }\n                    for (let i = size; i < inv.invSlotObjId.length; i++) {\n                        inv.invSlotObjId[i] = 0;\n                        inv.invSlotObjCount[i] = 0;\n                    }\n                }\n                else {\n                    for (let i = 0; i < size; i++) {\n                        this.in.g2;\n                        if (this.in.g1 === 255) {\n                            this.in.g4;\n                        }\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].ENABLE_TRACKING) {\n                // ENABLE_TRACKING\n                _jagex2_client_InputTracking__WEBPACK_IMPORTED_MODULE_30__[\"default\"].setEnabled();\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].P_COUNTDIALOG) {\n                // IF_IAMOUNT\n                this.showSocialInput = false;\n                this.chatbackInputOpen = true;\n                this.chatbackInput = '';\n                this.redrawChatback = true;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_INV_STOP_TRANSMIT) {\n                // UPDATE_INV_STOP_TRANSMIT\n                const inv = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.in.g2];\n                if (inv.invSlotObjId) {\n                    for (let i = 0; i < inv.invSlotObjId.length; i++) {\n                        inv.invSlotObjId[i] = -1;\n                        inv.invSlotObjId[i] = 0;\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LAST_LOGIN_INFO) {\n                // LAST_LOGIN_INFO\n                this.lastAddress = this.in.g4;\n                this.daysSinceLastLogin = this.in.g2;\n                this.daysSinceRecoveriesChanged = this.in.g1;\n                this.unreadMessages = this.in.g2;\n                if (this.lastAddress !== 0 && this.viewportInterfaceId === -1) {\n                    // signlink.dnslookup(JString.formatIPv4(this.lastAddress)); // TODO?\n                    this.closeInterfaces();\n                    let contentType = 650;\n                    if (this.daysSinceRecoveriesChanged !== 201) {\n                        contentType = 655;\n                    }\n                    this.reportAbuseInput = '';\n                    this.reportAbuseMuteOption = false;\n                    for (let i = 0; i < _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances.length; i++) {\n                        if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i] && _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i].clientCode === contentType) {\n                            this.viewportInterfaceId = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[i].layer;\n                            break;\n                        }\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].TUTORIAL_FLASHSIDE) {\n                // IF_SETTAB_FLASH\n                this.flashingTab = this.in.g1;\n                if (this.flashingTab === this.selectedTab) {\n                    if (this.flashingTab === 3) {\n                        this.selectedTab = 1;\n                    }\n                    else {\n                        this.selectedTab = 3;\n                    }\n                    this.redrawSidebar = true;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MIDI_JINGLE) {\n                // MIDI_JINGLE\n                if (this.midiActive && !_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory) {\n                    const delay = this.in.g2;\n                    const length = this.in.g4;\n                    const remaining = this.packetSize - 6;\n                    const uncompressed = _vendor_bzip__WEBPACK_IMPORTED_MODULE_27__[\"default\"].read(length, Int8Array.from(this.in.data), remaining, this.in.pos);\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.playMidi)(uncompressed, this.midiVolume);\n                    this.nextMusicDelay = delay;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].SET_MULTIWAY) {\n                // IF_MULTIZONE\n                this.inMultizone = this.in.g1;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].SYNTH_SOUND) {\n                // SYNTH_SOUND\n                const id = this.in.g2;\n                const loop = this.in.g1;\n                const delay = this.in.g2;\n                if (this.waveEnabled && !_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory && this.waveCount < 50) {\n                    this.waveIds[this.waveCount] = id;\n                    this.waveLoops[this.waveCount] = loop;\n                    this.waveDelay[this.waveCount] = delay + _jagex2_sound_Wave__WEBPACK_IMPORTED_MODULE_25__[\"default\"].delays[id];\n                    this.waveCount++;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETNPCHEAD) {\n                // IF_SETNPCHEAD\n                const com = this.in.g2;\n                const npcId = this.in.g2;\n                const npc = _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(npcId);\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].model = npc.getHeadModel();\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_ZONE_PARTIAL_FOLLOWS) {\n                // UPDATE_ZONE_PARTIAL_FOLLOWS\n                this.baseX = this.in.g1;\n                this.baseZ = this.in.g1;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETRECOL) {\n                // IF_SETMODEL_COLOUR\n                const com = this.in.g2;\n                const src = this.in.g2;\n                const dst = this.in.g2;\n                const inter = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com];\n                const model = inter.model;\n                model?.recolor(src, dst);\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].CHAT_FILTER_SETTINGS) {\n                // CHAT_FILTER_SETTINGS\n                this.publicChatSetting = this.in.g1;\n                this.privateChatSetting = this.in.g1;\n                this.tradeChatSetting = this.in.g1;\n                this.redrawPrivacySettings = true;\n                this.redrawChatback = true;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_OPENSIDEMODAL) {\n                // IF_OPENSIDEOVERLAY\n                const com = this.in.g2;\n                this.resetInterfaceAnimation(com);\n                if (this.chatInterfaceId !== -1) {\n                    this.chatInterfaceId = -1;\n                    this.redrawChatback = true;\n                }\n                if (this.chatbackInputOpen) {\n                    this.chatbackInputOpen = false;\n                    this.redrawChatback = true;\n                }\n                this.sidebarInterfaceId = com;\n                this.redrawSidebar = true;\n                this.redrawSideicons = true;\n                this.viewportInterfaceId = -1;\n                this.pressedContinueOption = false;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_OPENCHATMODAL) {\n                // IF_OPENCHAT\n                const com = this.in.g2;\n                this.resetInterfaceAnimation(com);\n                if (this.sidebarInterfaceId !== -1) {\n                    this.sidebarInterfaceId = -1;\n                    this.redrawSidebar = true;\n                    this.redrawSideicons = true;\n                }\n                this.chatInterfaceId = com;\n                this.redrawChatback = true;\n                this.viewportInterfaceId = -1;\n                this.pressedContinueOption = false;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETPOSITION) {\n                // IF_SETPOSITION\n                const com = this.in.g2;\n                const x = this.in.g2b;\n                const z = this.in.g2b;\n                const inter = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com];\n                inter.x = x;\n                inter.y = z;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].CAM_MOVETO) {\n                // CAM_MOVETO\n                this.cutscene = true;\n                this.cutsceneSrcLocalTileX = this.in.g1;\n                this.cutsceneSrcLocalTileZ = this.in.g1;\n                this.cutsceneSrcHeight = this.in.g2;\n                this.cutsceneMoveSpeed = this.in.g1;\n                this.cutsceneMoveAcceleration = this.in.g1;\n                if (this.cutsceneMoveAcceleration >= 100) {\n                    this.cameraX = this.cutsceneSrcLocalTileX * 128 + 64;\n                    this.cameraZ = this.cutsceneSrcLocalTileZ * 128 + 64;\n                    this.cameraY = this.getHeightmapY(this.currentLevel, this.cutsceneSrcLocalTileX, this.cutsceneSrcLocalTileZ) - this.cutsceneSrcHeight;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_ZONE_FULL_FOLLOWS) {\n                // UPDATE_ZONE_FULL_FOLLOWS\n                this.baseX = this.in.g1;\n                this.baseZ = this.in.g1;\n                for (let x = this.baseX; x < this.baseX + 8; x++) {\n                    for (let z = this.baseZ; z < this.baseZ + 8; z++) {\n                        if (this.levelObjStacks[this.currentLevel][x][z]) {\n                            this.levelObjStacks[this.currentLevel][x][z] = null;\n                            this.sortObjStacks(x, z);\n                        }\n                    }\n                }\n                for (let loc = this.spawnedLocations.head(); loc; loc = this.spawnedLocations.next()) {\n                    if (loc.x >= this.baseX && loc.x < this.baseX + 8 && loc.z >= this.baseZ && loc.z < this.baseZ + 8 && loc.plane === this.currentLevel) {\n                        this.addLoc(loc.plane, loc.x, loc.z, loc.lastLocIndex, loc.lastAngle, loc.lastShape, loc.layer);\n                        loc.unlink();\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].DATA_LAND) {\n                // DATA_LAND\n                const x = this.in.g1;\n                const z = this.in.g1;\n                const off = this.in.g2;\n                const length = this.in.g2;\n                let index = -1;\n                if (this.sceneMapIndex) {\n                    for (let i = 0; i < this.sceneMapIndex.length; i++) {\n                        if (this.sceneMapIndex[i] === (x << 8) + z) {\n                            index = i;\n                        }\n                    }\n                }\n                if (index !== -1 && this.sceneMapLandData) {\n                    if (!this.sceneMapLandData[index] || this.sceneMapLandData[index]?.length !== length) {\n                        this.sceneMapLandData[index] = new Int8Array(length);\n                    }\n                    const data = this.sceneMapLandData[index];\n                    if (data) {\n                        this.in.gdata(this.packetSize - 6, off, data);\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MESSAGE_PRIVATE) {\n                // MESSAGE_PRIVATE\n                const from = this.in.g8;\n                const messageId = this.in.g4;\n                const staffModLevel = this.in.g1;\n                let ignored = false;\n                for (let i = 0; i < 100; i++) {\n                    if (this.messageIds[i] === messageId) {\n                        ignored = true;\n                        break;\n                    }\n                }\n                if (staffModLevel <= 1) {\n                    for (let i = 0; i < this.ignoreCount; i++) {\n                        if (this.ignoreName37[i] === from) {\n                            ignored = true;\n                            break;\n                        }\n                    }\n                }\n                if (!ignored && this.overrideChat === 0) {\n                    try {\n                        this.messageIds[this.privateMessageCount] = messageId;\n                        this.privateMessageCount = (this.privateMessageCount + 1) % 100;\n                        const uncompressed = _jagex2_wordenc_WordPack__WEBPACK_IMPORTED_MODULE_24__[\"default\"].unpack(this.in, this.packetSize - 13);\n                        const filtered = _jagex2_wordenc_WordFilter__WEBPACK_IMPORTED_MODULE_23__[\"default\"].filter(uncompressed);\n                        if (staffModLevel > 1) {\n                            this.addMessage(7, filtered, _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].fromBase37(from)));\n                        }\n                        else {\n                            this.addMessage(3, filtered, _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].formatName(_jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].fromBase37(from)));\n                        }\n                    }\n                    catch (e) {\n                        // signlink.reporterror(\"cde1\"); TODO?\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].RESET_CLIENT_VARCACHE) {\n                // RESET_CLIENT_VARCACHE\n                for (let i = 0; i < this.varps.length; i++) {\n                    if (this.varps[i] !== this.varCache[i]) {\n                        this.varps[i] = this.varCache[i];\n                        await this.updateVarp(i);\n                        this.redrawSidebar = true;\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETMODEL) {\n                // IF_SETMODEL\n                const com = this.in.g2;\n                const model = this.in.g2;\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].model = _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].model(model);\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].TUTORIAL_OPENCHAT) {\n                // IF_OPENCHATSTICKY\n                this.stickyChatInterfaceId = this.in.g2b;\n                this.redrawChatback = true;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_RUNENERGY) {\n                // UPDATE_RUNENERGY\n                if (this.selectedTab === 12) {\n                    this.redrawSidebar = true;\n                }\n                this.energy = this.in.g1;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].CAM_LOOKAT) {\n                // CAM_LOOKAT\n                this.cutscene = true;\n                this.cutsceneDstLocalTileX = this.in.g1;\n                this.cutsceneDstLocalTileZ = this.in.g1;\n                this.cutsceneDstHeight = this.in.g2;\n                this.cutsceneRotateSpeed = this.in.g1;\n                this.cutsceneRotateAcceleration = this.in.g1;\n                if (this.cutsceneRotateAcceleration >= 100) {\n                    const sceneX = this.cutsceneDstLocalTileX * 128 + 64;\n                    const sceneZ = this.cutsceneDstLocalTileZ * 128 + 64;\n                    const sceneY = this.getHeightmapY(this.currentLevel, this.cutsceneDstLocalTileX, this.cutsceneDstLocalTileZ) - this.cutsceneDstHeight;\n                    const deltaX = sceneX - this.cameraX;\n                    const deltaY = sceneY - this.cameraY;\n                    const deltaZ = sceneZ - this.cameraZ;\n                    const distance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ) | 0;\n                    this.cameraPitch = ((Math.atan2(deltaY, distance) * 325.949) | 0) & 0x7ff;\n                    this.cameraYaw = ((Math.atan2(deltaX, deltaZ) * -325.949) | 0) & 0x7ff;\n                    if (this.cameraPitch < 128) {\n                        this.cameraPitch = 128;\n                    }\n                    if (this.cameraPitch > 383) {\n                        this.cameraPitch = 383;\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SHOWSIDE) {\n                // IF_SETTAB_ACTIVE\n                this.selectedTab = this.in.g1;\n                this.redrawSidebar = true;\n                this.redrawSideicons = true;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MESSAGE_GAME) {\n                // MESSAGE_GAME\n                const message = this.in.gjstr;\n                let username;\n                if (message.endsWith(':tradereq:')) {\n                    const player = message.substring(0, message.indexOf(':'));\n                    username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(player);\n                    let ignored = false;\n                    for (let i = 0; i < this.ignoreCount; i++) {\n                        if (this.ignoreName37[i] === username) {\n                            ignored = true;\n                            break;\n                        }\n                    }\n                    if (!ignored && this.overrideChat === 0) {\n                        this.addMessage(4, 'wishes to trade with you.', player);\n                    }\n                }\n                else if (message.endsWith(':duelreq:')) {\n                    const player = message.substring(0, message.indexOf(':'));\n                    username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(player);\n                    let ignored = false;\n                    for (let i = 0; i < this.ignoreCount; i++) {\n                        if (this.ignoreName37[i] === username) {\n                            ignored = true;\n                            break;\n                        }\n                    }\n                    if (!ignored && this.overrideChat === 0) {\n                        this.addMessage(8, 'wishes to duel with you.', player);\n                    }\n                }\n                else {\n                    this.addMessage(0, message, '');\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETOBJECT) {\n                // IF_SETOBJECT\n                const com = this.in.g2;\n                const objId = this.in.g2;\n                const zoom = this.in.g2;\n                const obj = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(objId);\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].model = obj.getInterfaceModel(50);\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].xan = obj.xan2d;\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].yan = obj.yan2d;\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].zoom = ((obj.zoom2d * 100) / zoom) | 0;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_OPENMAINMODAL) {\n                // IF_OPENMAIN\n                const com = this.in.g2;\n                this.resetInterfaceAnimation(com);\n                if (this.sidebarInterfaceId !== -1) {\n                    this.sidebarInterfaceId = -1;\n                    this.redrawSidebar = true;\n                    this.redrawSideicons = true;\n                }\n                if (this.chatInterfaceId !== -1) {\n                    this.chatInterfaceId = -1;\n                    this.redrawChatback = true;\n                }\n                if (this.chatbackInputOpen) {\n                    this.chatbackInputOpen = false;\n                    this.redrawChatback = true;\n                }\n                this.viewportInterfaceId = com;\n                this.pressedContinueOption = false;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETCOLOUR) {\n                // IF_SETCOLOUR\n                const com = this.in.g2;\n                const color = this.in.g2;\n                const r = (color >> 10) & 0x1f;\n                const g = (color >> 5) & 0x1f;\n                const b = color & 0x1f;\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].colour = (r << 19) + (g << 11) + (b << 3);\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].RESET_ANIMS) {\n                // RESET_ANIMS\n                for (let i = 0; i < this.players.length; i++) {\n                    const player = this.players[i];\n                    if (!player) {\n                        continue;\n                    }\n                    player.primarySeqId = -1;\n                }\n                for (let i = 0; i < this.npcs.length; i++) {\n                    const npc = this.npcs[i];\n                    if (!npc) {\n                        continue;\n                    }\n                    npc.primarySeqId = -1;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETHIDE) {\n                // IF_SETHIDE\n                const com = this.in.g2;\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].hide = this.in.g1 === 1;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_IGNORELIST) {\n                // UPDATE_IGNORELIST\n                this.ignoreCount = (this.packetSize / 8) | 0;\n                for (let i = 0; i < this.ignoreCount; i++) {\n                    this.ignoreName37[i] = this.in.g8;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].CAM_RESET) {\n                // CAM_RESET\n                this.cutscene = false;\n                for (let i = 0; i < 5; i++) {\n                    this.cameraModifierEnabled[i] = false;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_CLOSE) {\n                // IF_CLOSE\n                if (this.sidebarInterfaceId !== -1) {\n                    this.sidebarInterfaceId = -1;\n                    this.redrawSidebar = true;\n                    this.redrawSideicons = true;\n                }\n                if (this.chatInterfaceId !== -1) {\n                    this.chatInterfaceId = -1;\n                    this.redrawChatback = true;\n                }\n                if (this.chatbackInputOpen) {\n                    this.chatbackInputOpen = false;\n                    this.redrawChatback = true;\n                }\n                this.viewportInterfaceId = -1;\n                this.pressedContinueOption = false;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].IF_SETTEXT) {\n                // IF_SETTEXT\n                const com = this.in.g2;\n                _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].text = this.in.gjstr;\n                if (_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com].layer === this.tabInterfaceId[this.selectedTab]) {\n                    this.redrawSidebar = true;\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_STAT) {\n                // UPDATE_STAT\n                this.redrawSidebar = true;\n                const stat = this.in.g1;\n                const xp = this.in.g4;\n                const level = this.in.g1;\n                this.skillExperience[stat] = xp;\n                this.skillLevel[stat] = level;\n                this.skillBaseLevel[stat] = 1;\n                for (let i = 0; i < 98; i++) {\n                    if (xp >= this.levelExperience[i]) {\n                        this.skillBaseLevel[stat] = i + 2;\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_ZONE_PARTIAL_ENCLOSED) {\n                // UPDATE_ZONE_PARTIAL_ENCLOSED\n                this.baseX = this.in.g1;\n                this.baseZ = this.in.g1;\n                while (this.in.pos < this.packetSize) {\n                    const opcode = this.in.g1;\n                    this.readZonePacket(this.in, opcode);\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_RUNWEIGHT) {\n                // UPDATE_RUNWEIGHT\n                if (this.selectedTab === 12) {\n                    this.redrawSidebar = true;\n                }\n                this.weightCarried = this.in.g2b;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].CAM_SHAKE) {\n                // CAM_SHAKE\n                const type = this.in.g1;\n                const jitter = this.in.g1;\n                const wobbleScale = this.in.g1;\n                const wobbleSpeed = this.in.g1;\n                this.cameraModifierEnabled[type] = true;\n                this.cameraModifierJitter[type] = jitter;\n                this.cameraModifierWobbleScale[type] = wobbleScale;\n                this.cameraModifierWobbleSpeed[type] = wobbleSpeed;\n                this.cameraModifierCycle[type] = 0;\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].UPDATE_INV_PARTIAL) {\n                // UPDATE_INV_PARTIAL\n                this.redrawSidebar = true;\n                const com = this.in.g2;\n                const inv = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com];\n                while (this.in.pos < this.packetSize) {\n                    const slot = this.in.g1;\n                    const id = this.in.g2;\n                    let count = this.in.g1;\n                    if (count === 255) {\n                        count = this.in.g4;\n                    }\n                    if (inv.invSlotObjId && inv.invSlotObjCount && slot >= 0 && slot < inv.invSlotObjId.length) {\n                        inv.invSlotObjId[slot] = id;\n                        inv.invSlotObjCount[slot] = count;\n                    }\n                }\n                this.packetType = -1;\n                return true;\n            }\n            if (this.packetType === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].PLAYER_INFO) {\n                this.lastTickFlag = !this.lastTickFlag; // custom\n                // PLAYER_INFO\n                this.readPlayerInfo(this.in, this.packetSize);\n                if (this.sceneState === 1) {\n                    this.sceneState = 2;\n                    _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__[\"default\"].levelBuilt = this.currentLevel;\n                    this.buildScene();\n                }\n                if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory && this.sceneState === 2 && _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__[\"default\"].levelBuilt !== this.currentLevel) {\n                    this.areaViewport?.bind();\n                    this.fontPlain12?.drawStringCenter(257, 151, 'Loading - please wait.', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].BLACK);\n                    this.fontPlain12?.drawStringCenter(256, 150, 'Loading - please wait.', _jagex2_graphics_Colors__WEBPACK_IMPORTED_MODULE_15__[\"default\"].WHITE);\n                    this.areaViewport?.draw(8, 11);\n                    _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__[\"default\"].levelBuilt = this.currentLevel;\n                    this.buildScene();\n                }\n                if (this.currentLevel !== this.minimapLevel && this.sceneState === 2) {\n                    this.minimapLevel = this.currentLevel;\n                    this.createMinimap(this.currentLevel);\n                }\n                this.packetType = -1;\n                return true;\n            }\n            await this.logout();\n        }\n        catch (e) {\n            console.log(e);\n            await this.tryReconnect();\n            // TODO extra logic for logout??\n        }\n        return true;\n    };\n    buildScene = () => {\n        try {\n            this.minimapLevel = -1;\n            this.temporaryLocs.clear();\n            this.locList.clear();\n            this.spotanims.clear();\n            this.projectiles.clear();\n            _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].clearTexels();\n            this.clearCaches();\n            this.scene?.reset();\n            for (let level = 0; level < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].LEVELS; level++) {\n                this.levelCollisionMap[level]?.reset();\n            }\n            const world = new _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__[\"default\"](_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE, this.levelHeightmap, this.levelTileFlags); // has try catch here\n            _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__[\"default\"].lowMemory = _client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory;\n            const maps = this.sceneMapLandData?.length ?? 0;\n            if (this.sceneMapIndex) {\n                for (let index = 0; index < maps; index++) {\n                    const mapsquareX = this.sceneMapIndex[index] >> 8;\n                    const mapsquareZ = this.sceneMapIndex[index] & 0xff;\n                    // underground pass check\n                    if (mapsquareX === 33 && mapsquareZ >= 71 && mapsquareZ <= 73) {\n                        _jagex2_dash3d_World__WEBPACK_IMPORTED_MODULE_32__[\"default\"].lowMemory = false;\n                        break;\n                    }\n                }\n            }\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory) {\n                this.scene?.setMinLevel(this.currentLevel);\n            }\n            else {\n                this.scene?.setMinLevel(0);\n            }\n            if (this.sceneMapIndex && this.sceneMapLandData) {\n                // NO_TIMEOUT\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].NO_TIMEOUT);\n                for (let i = 0; i < maps; i++) {\n                    const x = (this.sceneMapIndex[i] >> 8) * 64 - this.sceneBaseTileX;\n                    const z = (this.sceneMapIndex[i] & 0xff) * 64 - this.sceneBaseTileZ;\n                    const src = this.sceneMapLandData[i];\n                    if (src) {\n                        const length = new _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_16__[\"default\"](new Uint8Array(src)).g4;\n                        const data = _vendor_bzip__WEBPACK_IMPORTED_MODULE_27__[\"default\"].read(length, src, src.length - 4, 4);\n                        world.readLandscape((this.sceneCenterZoneX - 6) * 8, (this.sceneCenterZoneZ - 6) * 8, x, z, data);\n                    }\n                    else if (this.sceneCenterZoneZ < 800) {\n                        world.clearLandscape(z, x, 64, 64);\n                    }\n                }\n            }\n            if (this.sceneMapIndex && this.sceneMapLocData) {\n                // NO_TIMEOUT\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].NO_TIMEOUT);\n                for (let i = 0; i < maps; i++) {\n                    const src = this.sceneMapLocData[i];\n                    if (src) {\n                        const length = new _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_16__[\"default\"](new Uint8Array(src)).g4;\n                        const data = _vendor_bzip__WEBPACK_IMPORTED_MODULE_27__[\"default\"].read(length, src, src.length - 4, 4);\n                        const x = (this.sceneMapIndex[i] >> 8) * 64 - this.sceneBaseTileX;\n                        const z = (this.sceneMapIndex[i] & 0xff) * 64 - this.sceneBaseTileZ;\n                        world.readLocs(this.scene, this.locList, this.levelCollisionMap, data, x, z);\n                    }\n                }\n            }\n            // NO_TIMEOUT\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].NO_TIMEOUT);\n            world.build(this.scene, this.levelCollisionMap);\n            this.areaViewport?.bind();\n            // NO_TIMEOUT\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].NO_TIMEOUT);\n            for (let loc = this.locList.head(); loc; loc = this.locList.next()) {\n                if ((this.levelTileFlags && this.levelTileFlags[1][loc.heightmapNE][loc.heightmapNW] & 0x2) === 2) {\n                    loc.heightmapSW--;\n                    if (loc.heightmapSW < 0) {\n                        loc.unlink();\n                    }\n                }\n            }\n            for (let x = 0; x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; x++) {\n                for (let z = 0; z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE; z++) {\n                    this.sortObjStacks(x, z);\n                }\n            }\n            for (let loc = this.spawnedLocations.head(); loc; loc = this.spawnedLocations.next()) {\n                this.addLoc(loc.plane, loc.x, loc.z, loc.locIndex, loc.angle, loc.shape, loc.layer);\n            }\n        }\n        catch (e) {\n            /* empty */\n        }\n        _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelCacheStatic?.clear();\n        _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].initPool(20);\n    };\n    resetInterfaceAnimation = (id) => {\n        const parent = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[id];\n        if (!parent.childId) {\n            return;\n        }\n        for (let i = 0; i < parent.childId.length && parent.childId[i] !== -1; i++) {\n            const child = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[parent.childId[i]];\n            if (child.type === 1) {\n                this.resetInterfaceAnimation(child.id);\n            }\n            child.seqFrame = 0;\n            child.seqCycle = 0;\n        }\n    };\n    initializeLevelExperience = () => {\n        let acc = 0;\n        for (let i = 0; i < 99; i++) {\n            const level = i + 1;\n            const delta = (level + Math.pow(2.0, level / 7.0) * 300.0) | 0;\n            acc += delta;\n            this.levelExperience[i] = (acc / 4) | 0;\n        }\n    };\n    addMessage = (type, text, sender) => {\n        if (type === 0 && this.stickyChatInterfaceId !== -1) {\n            this.modalMessage = text;\n            this.mouseClickButton = 0;\n        }\n        if (this.chatInterfaceId === -1) {\n            this.redrawChatback = true;\n        }\n        for (let i = 99; i > 0; i--) {\n            this.messageType[i] = this.messageType[i - 1];\n            this.messageSender[i] = this.messageSender[i - 1];\n            this.messageText[i] = this.messageText[i - 1];\n        }\n        if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug && type === 0) {\n            text = '[' + ((this.loopCycle / 30) | 0) + ']: ' + text;\n        }\n        this.messageType[0] = type;\n        this.messageSender[0] = sender;\n        this.messageText[0] = text;\n    };\n    updateVarp = async (id) => {\n        const clientcode = _jagex2_config_VarpType__WEBPACK_IMPORTED_MODULE_6__[\"default\"].instances[id].clientcode;\n        if (clientcode !== 0) {\n            const value = this.varps[id];\n            if (clientcode === 1) {\n                if (value === 1) {\n                    _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].setBrightness(0.9);\n                }\n                if (value === 2) {\n                    _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].setBrightness(0.8);\n                }\n                if (value === 3) {\n                    _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].setBrightness(0.7);\n                }\n                if (value === 4) {\n                    _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].setBrightness(0.6);\n                }\n                _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].iconCache?.clear();\n                this.redrawTitleBackground = true;\n            }\n            if (clientcode === 3) {\n                const lastMidiActive = this.midiActive;\n                if (value === 0) {\n                    this.midiVolume = 256;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setMidiVolume)(256);\n                    this.midiActive = true;\n                }\n                if (value === 1) {\n                    this.midiVolume = 192;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setMidiVolume)(192);\n                    this.midiActive = true;\n                }\n                if (value === 2) {\n                    this.midiVolume = 128;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setMidiVolume)(128);\n                    this.midiActive = true;\n                }\n                if (value === 3) {\n                    this.midiVolume = 64;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setMidiVolume)(64);\n                    this.midiActive = true;\n                }\n                if (value === 4) {\n                    this.midiActive = false;\n                }\n                if (this.midiActive !== lastMidiActive) {\n                    if (this.midiActive && this.currentMidi) {\n                        await this.setMidi(this.currentMidi, this.midiCrc, this.midiSize);\n                    }\n                    else {\n                        (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.stopMidi)();\n                    }\n                    this.nextMusicDelay = 0;\n                }\n            }\n            if (clientcode === 4) {\n                if (value === 0) {\n                    this.waveVolume = 256;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setWaveVolume)(256);\n                    this.waveEnabled = true;\n                }\n                if (value === 1) {\n                    this.waveVolume = 192;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setWaveVolume)(192);\n                    this.waveEnabled = true;\n                }\n                if (value === 2) {\n                    this.waveVolume = 128;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setWaveVolume)(128);\n                    this.waveEnabled = true;\n                }\n                if (value === 3) {\n                    this.waveVolume = 64;\n                    (0,_jagex2_util_AudioUtil_js__WEBPACK_IMPORTED_MODULE_46__.setWaveVolume)(64);\n                    this.waveEnabled = true;\n                }\n                if (value === 4) {\n                    this.waveEnabled = false;\n                }\n            }\n            if (clientcode === 5) {\n                this.mouseButtonsOption = value;\n            }\n            if (clientcode === 6) {\n                this.chatEffects = value;\n            }\n            if (clientcode === 8) {\n                this.splitPrivateChat = value;\n                this.redrawChatback = true;\n            }\n        }\n    };\n    handleChatMouseInput = (_mouseX, mouseY) => {\n        let line = 0;\n        for (let i = 0; i < 100; i++) {\n            if (!this.messageText[i]) {\n                continue;\n            }\n            const type = this.messageType[i];\n            const y = this.chatScrollOffset + 70 + 4 - line * 14;\n            if (y < -20) {\n                break;\n            }\n            if (type === 0) {\n                line++;\n            }\n            if ((type === 1 || type === 2) && (type === 1 || this.publicChatSetting === 0 || (this.publicChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                if (mouseY > y - 14 && mouseY <= y && this.localPlayer && this.messageSender[i] !== this.localPlayer.name) {\n                    if (this.rights) {\n                        this.menuOption[this.menuSize] = 'Report abuse @whi@' + this.messageSender[i];\n                        this.menuAction[this.menuSize] = 34;\n                        this.menuSize++;\n                    }\n                    this.menuOption[this.menuSize] = 'Add ignore @whi@' + this.messageSender[i];\n                    this.menuAction[this.menuSize] = 436;\n                    this.menuSize++;\n                    this.menuOption[this.menuSize] = 'Add friend @whi@' + this.messageSender[i];\n                    this.menuAction[this.menuSize] = 406;\n                    this.menuSize++;\n                }\n                line++;\n            }\n            if ((type === 3 || type === 7) && this.splitPrivateChat === 0 && (type === 7 || this.privateChatSetting === 0 || (this.privateChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                if (mouseY > y - 14 && mouseY <= y) {\n                    if (this.rights) {\n                        this.menuOption[this.menuSize] = 'Report abuse @whi@' + this.messageSender[i];\n                        this.menuAction[this.menuSize] = 34;\n                        this.menuSize++;\n                    }\n                    this.menuOption[this.menuSize] = 'Add ignore @whi@' + this.messageSender[i];\n                    this.menuAction[this.menuSize] = 436;\n                    this.menuSize++;\n                    this.menuOption[this.menuSize] = 'Add friend @whi@' + this.messageSender[i];\n                    this.menuAction[this.menuSize] = 406;\n                    this.menuSize++;\n                }\n                line++;\n            }\n            if (type === 4 && (this.tradeChatSetting === 0 || (this.tradeChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                if (mouseY > y - 14 && mouseY <= y) {\n                    this.menuOption[this.menuSize] = 'Accept trade @whi@' + this.messageSender[i];\n                    this.menuAction[this.menuSize] = 903;\n                    this.menuSize++;\n                }\n                line++;\n            }\n            if ((type === 5 || type === 6) && this.splitPrivateChat === 0 && this.privateChatSetting < 2) {\n                line++;\n            }\n            if (type === 8 && (this.tradeChatSetting === 0 || (this.tradeChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                if (mouseY > y - 14 && mouseY <= y) {\n                    this.menuOption[this.menuSize] = 'Accept duel @whi@' + this.messageSender[i];\n                    this.menuAction[this.menuSize] = 363;\n                    this.menuSize++;\n                }\n                line++;\n            }\n        }\n    };\n    handlePrivateChatInput = (mouseY) => {\n        if (this.splitPrivateChat === 0) {\n            return;\n        }\n        let lineOffset = 0;\n        if (this.systemUpdateTimer !== 0) {\n            lineOffset = 1;\n        }\n        for (let i = 0; i < 100; i++) {\n            if (this.messageText[i] !== null) {\n                const type = this.messageType[i];\n                if ((type === 3 || type === 7) && (type === 7 || this.privateChatSetting === 0 || (this.privateChatSetting === 1 && this.isFriend(this.messageSender[i])))) {\n                    const y = 329 - lineOffset * 13;\n                    if (this.mouseX > 8 && this.mouseX < 520 && mouseY - 11 > y - 10 && mouseY - 11 <= y + 3) {\n                        if (this.rights) {\n                            this.menuOption[this.menuSize] = 'Report abuse @whi@' + this.messageSender[i];\n                            this.menuAction[this.menuSize] = 2034;\n                            this.menuSize++;\n                        }\n                        this.menuOption[this.menuSize] = 'Add ignore @whi@' + this.messageSender[i];\n                        this.menuAction[this.menuSize] = 2436;\n                        this.menuSize++;\n                        this.menuOption[this.menuSize] = 'Add friend @whi@' + this.messageSender[i];\n                        this.menuAction[this.menuSize] = 2406;\n                        this.menuSize++;\n                    }\n                    lineOffset++;\n                    if (lineOffset >= 5) {\n                        return;\n                    }\n                }\n                if ((type === 5 || type === 6) && this.privateChatSetting < 2) {\n                    lineOffset++;\n                    if (lineOffset >= 5) {\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    handleInterfaceInput = (com, mouseX, mouseY, x, y, scrollPosition) => {\n        if (com.type !== 0 || !com.childId || com.hide || mouseX < x || mouseY < y || mouseX > x + com.width || mouseY > y + com.height || !com.childX || !com.childY) {\n            return;\n        }\n        const children = com.childId.length;\n        for (let i = 0; i < children; i++) {\n            let childX = com.childX[i] + x;\n            let childY = com.childY[i] + y - scrollPosition;\n            const child = _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[com.childId[i]];\n            childX += child.x;\n            childY += child.y;\n            if ((child.overLayer >= 0 || child.overColour !== 0) && mouseX >= childX && mouseY >= childY && mouseX < childX + child.width && mouseY < childY + child.height) {\n                if (child.overLayer >= 0) {\n                    this.lastHoveredInterfaceId = child.overLayer;\n                }\n                else {\n                    this.lastHoveredInterfaceId = child.id;\n                }\n            }\n            if (child.type === 0) {\n                this.handleInterfaceInput(child, mouseX, mouseY, childX, childY, child.scrollPosition);\n                if (child.scroll > child.height) {\n                    this.handleScrollInput(mouseX, mouseY, child.scroll, child.height, true, childX + child.width, childY, child);\n                }\n            }\n            else if (child.type === 2) {\n                let slot = 0;\n                for (let row = 0; row < child.height; row++) {\n                    for (let col = 0; col < child.width; col++) {\n                        let slotX = childX + col * (child.marginX + 32);\n                        let slotY = childY + row * (child.marginY + 32);\n                        if (slot < 20 && child.invSlotOffsetX && child.invSlotOffsetY) {\n                            slotX += child.invSlotOffsetX[slot];\n                            slotY += child.invSlotOffsetY[slot];\n                        }\n                        if (mouseX < slotX || mouseY < slotY || mouseX >= slotX + 32 || mouseY >= slotY + 32) {\n                            slot++;\n                            continue;\n                        }\n                        this.hoveredSlot = slot;\n                        this.hoveredSlotParentId = child.id;\n                        if (!child.invSlotObjId || child.invSlotObjId[slot] <= 0) {\n                            slot++;\n                            continue;\n                        }\n                        const obj = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(child.invSlotObjId[slot] - 1);\n                        if (this.objSelected === 1 && child.interactable) {\n                            if (child.id !== this.objSelectedInterface || slot !== this.objSelectedSlot) {\n                                this.menuOption[this.menuSize] = 'Use ' + this.objSelectedName + ' with @lre@' + obj.name;\n                                this.menuAction[this.menuSize] = 881;\n                                this.menuParamA[this.menuSize] = obj.id;\n                                this.menuParamB[this.menuSize] = slot;\n                                this.menuParamC[this.menuSize] = child.id;\n                                this.menuSize++;\n                            }\n                        }\n                        else if (this.spellSelected === 1 && child.interactable) {\n                            if ((this.activeSpellFlags & 0x10) === 16) {\n                                this.menuOption[this.menuSize] = this.spellCaption + ' @lre@' + obj.name;\n                                this.menuAction[this.menuSize] = 391;\n                                this.menuParamA[this.menuSize] = obj.id;\n                                this.menuParamB[this.menuSize] = slot;\n                                this.menuParamC[this.menuSize] = child.id;\n                                this.menuSize++;\n                            }\n                        }\n                        else {\n                            if (child.interactable) {\n                                for (let op = 4; op >= 3; op--) {\n                                    if (obj.iop && obj.iop[op]) {\n                                        this.menuOption[this.menuSize] = obj.iop[op] + ' @lre@' + obj.name;\n                                        if (op === 3) {\n                                            this.menuAction[this.menuSize] = 478;\n                                        }\n                                        else if (op === 4) {\n                                            this.menuAction[this.menuSize] = 347;\n                                        }\n                                        this.menuParamA[this.menuSize] = obj.id;\n                                        this.menuParamB[this.menuSize] = slot;\n                                        this.menuParamC[this.menuSize] = child.id;\n                                        this.menuSize++;\n                                    }\n                                    else if (op === 4) {\n                                        this.menuOption[this.menuSize] = 'Drop @lre@' + obj.name;\n                                        this.menuAction[this.menuSize] = 347;\n                                        this.menuParamA[this.menuSize] = obj.id;\n                                        this.menuParamB[this.menuSize] = slot;\n                                        this.menuParamC[this.menuSize] = child.id;\n                                        this.menuSize++;\n                                    }\n                                }\n                            }\n                            if (child.usable) {\n                                this.menuOption[this.menuSize] = 'Use @lre@' + obj.name;\n                                this.menuAction[this.menuSize] = 188;\n                                this.menuParamA[this.menuSize] = obj.id;\n                                this.menuParamB[this.menuSize] = slot;\n                                this.menuParamC[this.menuSize] = child.id;\n                                this.menuSize++;\n                            }\n                            if (child.interactable && obj.iop) {\n                                for (let op = 2; op >= 0; op--) {\n                                    if (obj.iop[op]) {\n                                        this.menuOption[this.menuSize] = obj.iop[op] + ' @lre@' + obj.name;\n                                        if (op === 0) {\n                                            this.menuAction[this.menuSize] = 405;\n                                        }\n                                        else if (op === 1) {\n                                            this.menuAction[this.menuSize] = 38;\n                                        }\n                                        else if (op === 2) {\n                                            this.menuAction[this.menuSize] = 422;\n                                        }\n                                        this.menuParamA[this.menuSize] = obj.id;\n                                        this.menuParamB[this.menuSize] = slot;\n                                        this.menuParamC[this.menuSize] = child.id;\n                                        this.menuSize++;\n                                    }\n                                }\n                            }\n                            if (child.iops) {\n                                for (let op = 4; op >= 0; op--) {\n                                    if (child.iops[op]) {\n                                        this.menuOption[this.menuSize] = child.iops[op] + ' @lre@' + obj.name;\n                                        if (op === 0) {\n                                            this.menuAction[this.menuSize] = 602;\n                                        }\n                                        else if (op === 1) {\n                                            this.menuAction[this.menuSize] = 596;\n                                        }\n                                        else if (op === 2) {\n                                            this.menuAction[this.menuSize] = 22;\n                                        }\n                                        else if (op === 3) {\n                                            this.menuAction[this.menuSize] = 892;\n                                        }\n                                        else if (op === 4) {\n                                            this.menuAction[this.menuSize] = 415;\n                                        }\n                                        this.menuParamA[this.menuSize] = obj.id;\n                                        this.menuParamB[this.menuSize] = slot;\n                                        this.menuParamC[this.menuSize] = child.id;\n                                        this.menuSize++;\n                                    }\n                                }\n                            }\n                            this.menuOption[this.menuSize] = 'Examine @lre@' + obj.name;\n                            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug) {\n                                this.menuOption[this.menuSize] += '@whi@ (' + obj.id + ')';\n                            }\n                            this.menuAction[this.menuSize] = 1773;\n                            this.menuParamA[this.menuSize] = obj.id;\n                            if (child.invSlotObjCount) {\n                                this.menuParamC[this.menuSize] = child.invSlotObjCount[slot];\n                            }\n                            this.menuSize++;\n                        }\n                        slot++;\n                    }\n                }\n            }\n            else if (mouseX >= childX && mouseY >= childY && mouseX < childX + child.width && mouseY < childY + child.height) {\n                if (child.buttonType === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].BUTTON_OK) {\n                    let override = false;\n                    if (child.clientCode !== 0) {\n                        override = this.handleSocialMenuOption(child);\n                    }\n                    if (!override && child.option) {\n                        this.menuOption[this.menuSize] = child.option;\n                        this.menuAction[this.menuSize] = 951;\n                        this.menuParamC[this.menuSize] = child.id;\n                        this.menuSize++;\n                    }\n                }\n                else if (child.buttonType === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].BUTTON_TARGET && this.spellSelected === 0) {\n                    let prefix = child.actionVerb;\n                    if (prefix && prefix.indexOf(' ') !== -1) {\n                        prefix = prefix.substring(0, prefix.indexOf(' '));\n                    }\n                    this.menuOption[this.menuSize] = prefix + ' @gre@' + child.action;\n                    this.menuAction[this.menuSize] = 930;\n                    this.menuParamC[this.menuSize] = child.id;\n                    this.menuSize++;\n                }\n                else if (child.buttonType === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].BUTTON_CLOSE) {\n                    this.menuOption[this.menuSize] = 'Close';\n                    this.menuAction[this.menuSize] = 947;\n                    this.menuParamC[this.menuSize] = child.id;\n                    this.menuSize++;\n                }\n                else if (child.buttonType === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].BUTTON_TOGGLE && child.option) {\n                    this.menuOption[this.menuSize] = child.option;\n                    this.menuAction[this.menuSize] = 465;\n                    this.menuParamC[this.menuSize] = child.id;\n                    this.menuSize++;\n                }\n                else if (child.buttonType === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].BUTTON_SELECT && child.option) {\n                    this.menuOption[this.menuSize] = child.option;\n                    this.menuAction[this.menuSize] = 960;\n                    this.menuParamC[this.menuSize] = child.id;\n                    this.menuSize++;\n                }\n                else if (child.buttonType === _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].BUTTON_CONTINUE && !this.pressedContinueOption && child.option) {\n                    this.menuOption[this.menuSize] = child.option;\n                    this.menuAction[this.menuSize] = 44;\n                    this.menuParamC[this.menuSize] = child.id;\n                    this.menuSize++;\n                }\n            }\n        }\n    };\n    handleSocialMenuOption = (component) => {\n        let type = component.clientCode;\n        if (type >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_FRIENDS_START && type <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_FRIENDS_UPDATE_END) {\n            if (type >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_FRIENDS_UPDATE_START) {\n                type -= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_FRIENDS_UPDATE_START;\n            }\n            else {\n                type--;\n            }\n            this.menuOption[this.menuSize] = 'Remove @whi@' + this.friendName[type];\n            this.menuAction[this.menuSize] = 557;\n            this.menuSize++;\n            this.menuOption[this.menuSize] = 'Message @whi@' + this.friendName[type];\n            this.menuAction[this.menuSize] = 679;\n            this.menuSize++;\n            return true;\n        }\n        else if (type >= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_IGNORES_START && type <= _jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].CC_IGNORES_END) {\n            this.menuOption[this.menuSize] = 'Remove @whi@' + component.text;\n            this.menuAction[this.menuSize] = 556;\n            this.menuSize++;\n            return true;\n        }\n        return false;\n    };\n    handleViewportOptions = () => {\n        if (this.objSelected === 0 && this.spellSelected === 0) {\n            this.menuOption[this.menuSize] = 'Walk here';\n            this.menuAction[this.menuSize] = 660;\n            this.menuParamB[this.menuSize] = this.mouseX;\n            this.menuParamC[this.menuSize] = this.mouseY;\n            this.menuSize++;\n        }\n        let lastBitset = -1;\n        for (let picked = 0; picked < _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].pickedCount; picked++) {\n            const bitset = _jagex2_graphics_Model__WEBPACK_IMPORTED_MODULE_14__[\"default\"].pickedBitsets[picked];\n            const x = bitset & 0x7f;\n            const z = (bitset >> 7) & 0x7f;\n            const entityType = (bitset >> 29) & 0x3;\n            const typeId = (bitset >> 14) & 0x7fff;\n            if (bitset === lastBitset) {\n                continue;\n            }\n            lastBitset = bitset;\n            if (entityType === 2 && this.scene && this.scene.getInfo(this.currentLevel, x, z, bitset) >= 0) {\n                const loc = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(typeId);\n                if (this.objSelected === 1) {\n                    this.menuOption[this.menuSize] = 'Use ' + this.objSelectedName + ' with @cya@' + loc.name;\n                    this.menuAction[this.menuSize] = 450;\n                    this.menuParamA[this.menuSize] = bitset;\n                    this.menuParamB[this.menuSize] = x;\n                    this.menuParamC[this.menuSize] = z;\n                    this.menuSize++;\n                }\n                else if (this.spellSelected !== 1) {\n                    if (loc.op) {\n                        for (let op = 4; op >= 0; op--) {\n                            if (loc.op[op]) {\n                                this.menuOption[this.menuSize] = loc.op[op] + ' @cya@' + loc.name;\n                                if (op === 0) {\n                                    this.menuAction[this.menuSize] = 285;\n                                }\n                                if (op === 1) {\n                                    this.menuAction[this.menuSize] = 504;\n                                }\n                                if (op === 2) {\n                                    this.menuAction[this.menuSize] = 364;\n                                }\n                                if (op === 3) {\n                                    this.menuAction[this.menuSize] = 581;\n                                }\n                                if (op === 4) {\n                                    this.menuAction[this.menuSize] = 1501;\n                                }\n                                this.menuParamA[this.menuSize] = bitset;\n                                this.menuParamB[this.menuSize] = x;\n                                this.menuParamC[this.menuSize] = z;\n                                this.menuSize++;\n                            }\n                        }\n                    }\n                    this.menuOption[this.menuSize] = 'Examine @cya@' + loc.name;\n                    if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug) {\n                        this.menuOption[this.menuSize] += '@whi@ (' + loc.id + ')';\n                    }\n                    this.menuAction[this.menuSize] = 1175;\n                    this.menuParamA[this.menuSize] = bitset;\n                    this.menuParamB[this.menuSize] = x;\n                    this.menuParamC[this.menuSize] = z;\n                    this.menuSize++;\n                }\n                else if ((this.activeSpellFlags & 0x4) === 4) {\n                    this.menuOption[this.menuSize] = this.spellCaption + ' @cya@' + loc.name;\n                    this.menuAction[this.menuSize] = 55;\n                    this.menuParamA[this.menuSize] = bitset;\n                    this.menuParamB[this.menuSize] = x;\n                    this.menuParamC[this.menuSize] = z;\n                    this.menuSize++;\n                }\n            }\n            if (entityType === 1) {\n                const npc = this.npcs[typeId];\n                if (npc && npc.type && npc.type.size === 1 && (npc.x & 0x7f) === 64 && (npc.z & 0x7f) === 64) {\n                    for (let i = 0; i < this.npcCount; i++) {\n                        const other = this.npcs[this.npcIds[i]];\n                        if (other && other !== npc && other.type && other.type.size === 1 && other.x === npc.x && other.z === npc.z) {\n                            this.addNpcOptions(other.type, this.npcIds[i], x, z);\n                        }\n                    }\n                }\n                if (npc && npc.type) {\n                    this.addNpcOptions(npc.type, typeId, x, z);\n                }\n            }\n            if (entityType === 0) {\n                const player = this.players[typeId];\n                if (player && (player.x & 0x7f) === 64 && (player.z & 0x7f) === 64) {\n                    for (let i = 0; i < this.npcCount; i++) {\n                        const other = this.npcs[this.npcIds[i]];\n                        if (other && other.type && other.type.size === 1 && other.x === player.x && other.z === player.z) {\n                            this.addNpcOptions(other.type, this.npcIds[i], x, z);\n                        }\n                    }\n                    for (let i = 0; i < this.playerCount; i++) {\n                        const other = this.players[this.playerIds[i]];\n                        if (other && other !== player && other.x === player.x && other.z === player.z) {\n                            this.addPlayerOptions(other, this.playerIds[i], x, z);\n                        }\n                    }\n                }\n                if (player) {\n                    this.addPlayerOptions(player, typeId, x, z);\n                }\n            }\n            if (entityType === 3) {\n                const objs = this.levelObjStacks[this.currentLevel][x][z];\n                if (!objs) {\n                    continue;\n                }\n                for (let obj = objs.tail(); obj; obj = objs.prev()) {\n                    const type = _jagex2_config_ObjType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(obj.index);\n                    if (this.objSelected === 1) {\n                        this.menuOption[this.menuSize] = 'Use ' + this.objSelectedName + ' with @lre@' + type.name;\n                        this.menuAction[this.menuSize] = 217;\n                        this.menuParamA[this.menuSize] = obj.index;\n                        this.menuParamB[this.menuSize] = x;\n                        this.menuParamC[this.menuSize] = z;\n                        this.menuSize++;\n                    }\n                    else if (this.spellSelected !== 1) {\n                        for (let op = 4; op >= 0; op--) {\n                            if (type.op && type.op[op]) {\n                                this.menuOption[this.menuSize] = type.op[op] + ' @lre@' + type.name;\n                                if (op === 0) {\n                                    this.menuAction[this.menuSize] = 224;\n                                }\n                                if (op === 1) {\n                                    this.menuAction[this.menuSize] = 993;\n                                }\n                                if (op === 2) {\n                                    this.menuAction[this.menuSize] = 99;\n                                }\n                                if (op === 3) {\n                                    this.menuAction[this.menuSize] = 746;\n                                }\n                                if (op === 4) {\n                                    this.menuAction[this.menuSize] = 877;\n                                }\n                                this.menuParamA[this.menuSize] = obj.index;\n                                this.menuParamB[this.menuSize] = x;\n                                this.menuParamC[this.menuSize] = z;\n                                this.menuSize++;\n                            }\n                            else if (op === 2) {\n                                this.menuOption[this.menuSize] = 'Take @lre@' + type.name;\n                                this.menuAction[this.menuSize] = 99;\n                                this.menuParamA[this.menuSize] = obj.index;\n                                this.menuParamB[this.menuSize] = x;\n                                this.menuParamC[this.menuSize] = z;\n                                this.menuSize++;\n                            }\n                        }\n                        this.menuOption[this.menuSize] = 'Examine @lre@' + type.name;\n                        if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug) {\n                            this.menuOption[this.menuSize] += '@whi@ (' + obj.index + ')';\n                        }\n                        this.menuAction[this.menuSize] = 1102;\n                        this.menuParamA[this.menuSize] = obj.index;\n                        this.menuParamB[this.menuSize] = x;\n                        this.menuParamC[this.menuSize] = z;\n                        this.menuSize++;\n                    }\n                    else if ((this.activeSpellFlags & 0x1) === 1) {\n                        this.menuOption[this.menuSize] = this.spellCaption + ' @lre@' + type.name;\n                        this.menuAction[this.menuSize] = 965;\n                        this.menuParamA[this.menuSize] = obj.index;\n                        this.menuParamB[this.menuSize] = x;\n                        this.menuParamC[this.menuSize] = z;\n                        this.menuSize++;\n                    }\n                }\n            }\n        }\n    };\n    addNpcOptions = (npc, a, b, c) => {\n        if (this.menuSize >= 400) {\n            return;\n        }\n        let tooltip = npc.name;\n        if (npc.vislevel !== 0 && this.localPlayer) {\n            tooltip = tooltip + this.getCombatLevelColorTag(this.localPlayer.combatLevel, npc.vislevel) + ' (level-' + npc.vislevel + ')';\n        }\n        if (this.objSelected === 1) {\n            this.menuOption[this.menuSize] = 'Use ' + this.objSelectedName + ' with @yel@' + tooltip;\n            this.menuAction[this.menuSize] = 900;\n            this.menuParamA[this.menuSize] = a;\n            this.menuParamB[this.menuSize] = b;\n            this.menuParamC[this.menuSize] = c;\n            this.menuSize++;\n        }\n        else if (this.spellSelected !== 1) {\n            let type;\n            if (npc.op) {\n                for (type = 4; type >= 0; type--) {\n                    if (npc.op[type] && npc.op[type]?.toLowerCase() !== 'attack') {\n                        this.menuOption[this.menuSize] = npc.op[type] + ' @yel@' + tooltip;\n                        if (type === 0) {\n                            this.menuAction[this.menuSize] = 728;\n                        }\n                        else if (type === 1) {\n                            this.menuAction[this.menuSize] = 542;\n                        }\n                        else if (type === 2) {\n                            this.menuAction[this.menuSize] = 6;\n                        }\n                        else if (type === 3) {\n                            this.menuAction[this.menuSize] = 963;\n                        }\n                        else if (type === 4) {\n                            this.menuAction[this.menuSize] = 245;\n                        }\n                        this.menuParamA[this.menuSize] = a;\n                        this.menuParamB[this.menuSize] = b;\n                        this.menuParamC[this.menuSize] = c;\n                        this.menuSize++;\n                    }\n                }\n            }\n            if (npc.op) {\n                for (type = 4; type >= 0; type--) {\n                    if (npc.op[type] && npc.op[type]?.toLowerCase() === 'attack') {\n                        let action = 0;\n                        if (this.localPlayer && npc.vislevel > this.localPlayer.combatLevel) {\n                            action = 2000;\n                        }\n                        this.menuOption[this.menuSize] = npc.op[type] + ' @yel@' + tooltip;\n                        if (type === 0) {\n                            this.menuAction[this.menuSize] = action + 728;\n                        }\n                        else if (type === 1) {\n                            this.menuAction[this.menuSize] = action + 542;\n                        }\n                        else if (type === 2) {\n                            this.menuAction[this.menuSize] = action + 6;\n                        }\n                        else if (type === 3) {\n                            this.menuAction[this.menuSize] = action + 963;\n                        }\n                        else if (type === 4) {\n                            this.menuAction[this.menuSize] = action + 245;\n                        }\n                        this.menuParamA[this.menuSize] = a;\n                        this.menuParamB[this.menuSize] = b;\n                        this.menuParamC[this.menuSize] = c;\n                        this.menuSize++;\n                    }\n                }\n            }\n            this.menuOption[this.menuSize] = 'Examine @yel@' + tooltip;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug) {\n                this.menuOption[this.menuSize] += '@whi@ (' + npc.id + ')';\n            }\n            this.menuAction[this.menuSize] = 1607;\n            this.menuParamA[this.menuSize] = a;\n            this.menuParamB[this.menuSize] = b;\n            this.menuParamC[this.menuSize] = c;\n            this.menuSize++;\n        }\n        else if ((this.activeSpellFlags & 0x2) === 2) {\n            this.menuOption[this.menuSize] = this.spellCaption + ' @yel@' + tooltip;\n            this.menuAction[this.menuSize] = 265;\n            this.menuParamA[this.menuSize] = a;\n            this.menuParamB[this.menuSize] = b;\n            this.menuParamC[this.menuSize] = c;\n            this.menuSize++;\n        }\n    };\n    addPlayerOptions = (player, a, b, c) => {\n        if (player === this.localPlayer || this.menuSize >= 400) {\n            return;\n        }\n        let tooltip = null;\n        if (this.localPlayer) {\n            tooltip = player.name + this.getCombatLevelColorTag(this.localPlayer.combatLevel, player.combatLevel) + ' (level-' + player.combatLevel + ')';\n        }\n        if (this.objSelected === 1) {\n            this.menuOption[this.menuSize] = 'Use ' + this.objSelectedName + ' with @whi@' + tooltip;\n            this.menuAction[this.menuSize] = 367;\n            this.menuParamA[this.menuSize] = a;\n            this.menuParamB[this.menuSize] = b;\n            this.menuParamC[this.menuSize] = c;\n            this.menuSize++;\n        }\n        else if (this.spellSelected !== 1) {\n            this.menuOption[this.menuSize] = 'Follow @whi@' + tooltip;\n            this.menuAction[this.menuSize] = 1544;\n            this.menuParamA[this.menuSize] = a;\n            this.menuParamB[this.menuSize] = b;\n            this.menuParamC[this.menuSize] = c;\n            this.menuSize++;\n            if (this.overrideChat === 0) {\n                this.menuOption[this.menuSize] = 'Trade with @whi@' + tooltip;\n                this.menuAction[this.menuSize] = 1373;\n                this.menuParamA[this.menuSize] = a;\n                this.menuParamB[this.menuSize] = b;\n                this.menuParamC[this.menuSize] = c;\n                this.menuSize++;\n            }\n            if (this.wildernessLevel > 0) {\n                this.menuOption[this.menuSize] = 'Attack @whi@' + tooltip;\n                if (this.localPlayer && this.localPlayer.combatLevel >= player.combatLevel) {\n                    this.menuAction[this.menuSize] = 151;\n                }\n                else {\n                    this.menuAction[this.menuSize] = 2151;\n                }\n                this.menuParamA[this.menuSize] = a;\n                this.menuParamB[this.menuSize] = b;\n                this.menuParamC[this.menuSize] = c;\n                this.menuSize++;\n            }\n            if (this.worldLocationState === 1) {\n                this.menuOption[this.menuSize] = 'Fight @whi@' + tooltip;\n                this.menuAction[this.menuSize] = 151;\n                this.menuParamA[this.menuSize] = a;\n                this.menuParamB[this.menuSize] = b;\n                this.menuParamC[this.menuSize] = c;\n                this.menuSize++;\n            }\n            if (this.worldLocationState === 2) {\n                this.menuOption[this.menuSize] = 'Duel-with @whi@' + tooltip;\n                this.menuAction[this.menuSize] = 1101;\n                this.menuParamA[this.menuSize] = a;\n                this.menuParamB[this.menuSize] = b;\n                this.menuParamC[this.menuSize] = c;\n                this.menuSize++;\n            }\n        }\n        else if ((this.activeSpellFlags & 0x8) === 8) {\n            this.menuOption[this.menuSize] = this.spellCaption + ' @whi@' + tooltip;\n            this.menuAction[this.menuSize] = 651;\n            this.menuParamA[this.menuSize] = a;\n            this.menuParamB[this.menuSize] = b;\n            this.menuParamC[this.menuSize] = c;\n            this.menuSize++;\n        }\n        for (let i = 0; i < this.menuSize; i++) {\n            if (this.menuAction[i] === 660) {\n                this.menuOption[i] = 'Walk here @whi@' + tooltip;\n                return;\n            }\n        }\n    };\n    getCombatLevelColorTag = (viewerLevel, otherLevel) => {\n        const diff = viewerLevel - otherLevel;\n        if (diff < -9) {\n            return '@red@';\n        }\n        else if (diff < -6) {\n            return '@or3@';\n        }\n        else if (diff < -3) {\n            return '@or2@';\n        }\n        else if (diff < 0) {\n            return '@or1@';\n        }\n        else if (diff > 9) {\n            return '@gre@';\n        }\n        else if (diff > 6) {\n            return '@gr3@';\n        }\n        else if (diff > 3) {\n            return '@gr2@';\n        }\n        else if (diff > 0) {\n            return '@gr1@';\n        }\n        else {\n            return '@yel@';\n        }\n    };\n    handleInput = () => {\n        if (this.objDragArea === 0) {\n            this.menuOption[0] = 'Cancel';\n            this.menuAction[0] = 1252;\n            this.menuSize = 1;\n            this.handlePrivateChatInput(this.mouseY);\n            this.lastHoveredInterfaceId = 0;\n            // the main viewport area\n            if (this.mouseX > 8 && this.mouseY > 11 && this.mouseX < 520 && this.mouseY < 345) {\n                if (this.viewportInterfaceId === -1) {\n                    this.handleViewportOptions();\n                }\n                else {\n                    this.handleInterfaceInput(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.viewportInterfaceId], this.mouseX, this.mouseY, 8, 11, 0);\n                }\n            }\n            if (this.lastHoveredInterfaceId !== this.viewportHoveredInterfaceIndex) {\n                this.viewportHoveredInterfaceIndex = this.lastHoveredInterfaceId;\n            }\n            this.lastHoveredInterfaceId = 0;\n            // the sidebar/tabs area\n            if (this.mouseX > 562 && this.mouseY > 231 && this.mouseX < 752 && this.mouseY < 492) {\n                if (this.sidebarInterfaceId !== -1) {\n                    this.handleInterfaceInput(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.sidebarInterfaceId], this.mouseX, this.mouseY, 562, 231, 0);\n                }\n                else if (this.tabInterfaceId[this.selectedTab] !== -1) {\n                    this.handleInterfaceInput(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.tabInterfaceId[this.selectedTab]], this.mouseX, this.mouseY, 562, 231, 0);\n                }\n            }\n            if (this.lastHoveredInterfaceId !== this.sidebarHoveredInterfaceIndex) {\n                this.redrawSidebar = true;\n                this.sidebarHoveredInterfaceIndex = this.lastHoveredInterfaceId;\n            }\n            this.lastHoveredInterfaceId = 0;\n            // the chatbox area\n            if (this.mouseX > 22 && this.mouseY > 375 && this.mouseX < 431 && this.mouseY < 471) {\n                if (this.chatInterfaceId === -1) {\n                    this.handleChatMouseInput(this.mouseX - 22, this.mouseY - 375);\n                }\n                else {\n                    this.handleInterfaceInput(_jagex2_config_Component__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[this.chatInterfaceId], this.mouseX, this.mouseY, 22, 375, 0);\n                }\n            }\n            if (this.chatInterfaceId !== -1 && this.lastHoveredInterfaceId !== this.chatHoveredInterfaceIndex) {\n                this.redrawChatback = true;\n                this.chatHoveredInterfaceIndex = this.lastHoveredInterfaceId;\n            }\n            let done = false;\n            while (!done) {\n                done = true;\n                for (let i = 0; i < this.menuSize - 1; i++) {\n                    if (this.menuAction[i] < 1000 && this.menuAction[i + 1] > 1000) {\n                        const tmp0 = this.menuOption[i];\n                        this.menuOption[i] = this.menuOption[i + 1];\n                        this.menuOption[i + 1] = tmp0;\n                        const tmp1 = this.menuAction[i];\n                        this.menuAction[i] = this.menuAction[i + 1];\n                        this.menuAction[i + 1] = tmp1;\n                        const tmp2 = this.menuParamB[i];\n                        this.menuParamB[i] = this.menuParamB[i + 1];\n                        this.menuParamB[i + 1] = tmp2;\n                        const tmp3 = this.menuParamC[i];\n                        this.menuParamC[i] = this.menuParamC[i + 1];\n                        this.menuParamC[i + 1] = tmp3;\n                        const tmp4 = this.menuParamA[i];\n                        this.menuParamA[i] = this.menuParamA[i + 1];\n                        this.menuParamA[i + 1] = tmp4;\n                        done = false;\n                    }\n                }\n            }\n        }\n    };\n    showContextMenu = () => {\n        let width = 0;\n        if (this.fontBold12) {\n            width = this.fontBold12.stringWidth('Choose Option');\n            let maxWidth;\n            for (let i = 0; i < this.menuSize; i++) {\n                maxWidth = this.fontBold12.stringWidth(this.menuOption[i]);\n                if (maxWidth > width) {\n                    width = maxWidth;\n                }\n            }\n        }\n        width += 8;\n        const height = this.menuSize * 15 + 21;\n        let x;\n        let y;\n        // the main viewport area\n        if (this.mouseClickX > 8 && this.mouseClickY > 11 && this.mouseClickX < 520 && this.mouseClickY < 345) {\n            x = this.mouseClickX - ((width / 2) | 0) - 8;\n            if (x + width > 512) {\n                x = 512 - width;\n            }\n            else if (x < 0) {\n                x = 0;\n            }\n            y = this.mouseClickY - 11;\n            if (y + height > 334) {\n                y = 334 - height;\n            }\n            else if (y < 0) {\n                y = 0;\n            }\n            this.menuVisible = true;\n            this.menuArea = 0;\n            this.menuX = x;\n            this.menuY = y;\n            this.menuWidth = width;\n            this.menuHeight = this.menuSize * 15 + 22;\n        }\n        // the sidebar/tabs area\n        if (this.mouseClickX > 562 && this.mouseClickY > 231 && this.mouseClickX < 752 && this.mouseClickY < 492) {\n            x = this.mouseClickX - ((width / 2) | 0) - 562;\n            if (x < 0) {\n                x = 0;\n            }\n            else if (x + width > 190) {\n                x = 190 - width;\n            }\n            y = this.mouseClickY - 231;\n            if (y < 0) {\n                y = 0;\n            }\n            else if (y + height > 261) {\n                y = 261 - height;\n            }\n            this.menuVisible = true;\n            this.menuArea = 1;\n            this.menuX = x;\n            this.menuY = y;\n            this.menuWidth = width;\n            this.menuHeight = this.menuSize * 15 + 22;\n        }\n        // the chatbox area\n        if (this.mouseClickX > 22 && this.mouseClickY > 375 && this.mouseClickX < 501 && this.mouseClickY < 471) {\n            x = this.mouseClickX - ((width / 2) | 0) - 22;\n            if (x < 0) {\n                x = 0;\n            }\n            else if (x + width > 479) {\n                x = 479 - width;\n            }\n            y = this.mouseClickY - 375;\n            if (y < 0) {\n                y = 0;\n            }\n            else if (y + height > 96) {\n                y = 96 - height;\n            }\n            this.menuVisible = true;\n            this.menuArea = 2;\n            this.menuX = x;\n            this.menuY = y;\n            this.menuWidth = width;\n            this.menuHeight = this.menuSize * 15 + 22;\n        }\n    };\n    tryMove = (srcX, srcZ, dx, dz, type, locWidth, locLength, locAngle, locShape, forceapproach, tryNearest) => {\n        const collisionMap = this.levelCollisionMap[this.currentLevel];\n        if (!collisionMap) {\n            return false;\n        }\n        const sceneWidth = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE;\n        const sceneLength = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE;\n        for (let x = 0; x < sceneWidth; x++) {\n            for (let z = 0; z < sceneLength; z++) {\n                const index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z);\n                this.bfsDirection[index] = 0;\n                this.bfsCost[index] = 99999999;\n            }\n        }\n        let x = srcX;\n        let z = srcZ;\n        const srcIndex = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(srcX, srcZ);\n        this.bfsDirection[srcIndex] = 99;\n        this.bfsCost[srcIndex] = 0;\n        let steps = 0;\n        let length = 0;\n        this.bfsStepX[steps] = srcX;\n        this.bfsStepZ[steps++] = srcZ;\n        let arrived = false;\n        let bufferSize = this.bfsStepX.length;\n        const flags = collisionMap.flags;\n        while (length !== steps) {\n            x = this.bfsStepX[length];\n            z = this.bfsStepZ[length];\n            length = (length + 1) % bufferSize;\n            if (x === dx && z === dz) {\n                arrived = true;\n                break;\n            }\n            if (locShape !== _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_STRAIGHT.id) {\n                if ((locShape < _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALLDECOR_STRAIGHT_OFFSET.id || locShape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].CENTREPIECE_STRAIGHT.id) && collisionMap.reachedWall(x, z, dx, dz, locShape - 1, locAngle)) {\n                    arrived = true;\n                    break;\n                }\n                if (locShape < _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].CENTREPIECE_STRAIGHT.id && collisionMap.reachedWallDecoration(x, z, dx, dz, locShape - 1, locAngle)) {\n                    arrived = true;\n                    break;\n                }\n            }\n            if (locWidth !== 0 && locLength !== 0 && collisionMap.reachedLoc(x, z, dx, dz, locWidth, locLength, forceapproach)) {\n                arrived = true;\n                break;\n            }\n            const nextCost = this.bfsCost[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z)] + 1;\n            let index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x - 1, z);\n            if (x > 0 && this.bfsDirection[index] === 0 && (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_WEST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x - 1;\n                this.bfsStepZ[steps] = z;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 2;\n                this.bfsCost[index] = nextCost;\n            }\n            index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x + 1, z);\n            if (x < sceneWidth - 1 && this.bfsDirection[index] === 0 && (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_EAST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x + 1;\n                this.bfsStepZ[steps] = z;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 8;\n                this.bfsCost[index] = nextCost;\n            }\n            index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z - 1);\n            if (z > 0 && this.bfsDirection[index] === 0 && (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_SOUTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x;\n                this.bfsStepZ[steps] = z - 1;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 1;\n                this.bfsCost[index] = nextCost;\n            }\n            index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z + 1);\n            if (z < sceneLength - 1 && this.bfsDirection[index] === 0 && (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_NORTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x;\n                this.bfsStepZ[steps] = z + 1;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 4;\n                this.bfsCost[index] = nextCost;\n            }\n            index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x - 1, z - 1);\n            if (x > 0 &&\n                z > 0 &&\n                this.bfsDirection[index] === 0 &&\n                (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_SOUTH_WEST) === 0 &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x - 1, z)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_WEST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z - 1)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_SOUTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x - 1;\n                this.bfsStepZ[steps] = z - 1;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 3;\n                this.bfsCost[index] = nextCost;\n            }\n            index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x + 1, z - 1);\n            if (x < sceneWidth - 1 &&\n                z > 0 &&\n                this.bfsDirection[index] === 0 &&\n                (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_SOUTH_EAST) === 0 &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x + 1, z)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_EAST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z - 1)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_SOUTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x + 1;\n                this.bfsStepZ[steps] = z - 1;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 9;\n                this.bfsCost[index] = nextCost;\n            }\n            index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x - 1, z + 1);\n            if (x > 0 &&\n                z < sceneLength - 1 &&\n                this.bfsDirection[index] === 0 &&\n                (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_NORTH_WEST) === 0 &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x - 1, z)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_WEST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z + 1)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_NORTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x - 1;\n                this.bfsStepZ[steps] = z + 1;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 6;\n                this.bfsCost[index] = nextCost;\n            }\n            index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x + 1, z + 1);\n            if (x < sceneWidth - 1 &&\n                z < sceneLength - 1 &&\n                this.bfsDirection[index] === 0 &&\n                (flags[index] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_NORTH_EAST) === 0 &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x + 1, z)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_EAST) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN &&\n                (flags[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z + 1)] & _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].BLOCK_NORTH) === _jagex2_dash3d_CollisionFlag__WEBPACK_IMPORTED_MODULE_39__[\"default\"].OPEN) {\n                this.bfsStepX[steps] = x + 1;\n                this.bfsStepZ[steps] = z + 1;\n                steps = (steps + 1) % bufferSize;\n                this.bfsDirection[index] = 12;\n                this.bfsCost[index] = nextCost;\n            }\n        }\n        this.tryMoveNearest = 0;\n        if (!arrived) {\n            if (tryNearest) {\n                let min = 100;\n                for (let padding = 1; padding < 2; padding++) {\n                    for (let px = dx - padding; px <= dx + padding; px++) {\n                        for (let pz = dz - padding; pz <= dz + padding; pz++) {\n                            const index = _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(px, pz);\n                            if (px >= 0 && pz >= 0 && px < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && pz < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && this.bfsCost[index] < min) {\n                                min = this.bfsCost[index];\n                                x = px;\n                                z = pz;\n                                this.tryMoveNearest = 1;\n                                arrived = true;\n                            }\n                        }\n                    }\n                    if (arrived) {\n                        break;\n                    }\n                }\n            }\n            if (!arrived) {\n                return false;\n            }\n        }\n        length = 0;\n        this.bfsStepX[length] = x;\n        this.bfsStepZ[length++] = z;\n        let dir = this.bfsDirection[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z)];\n        let next = dir;\n        while (x !== srcX || z !== srcZ) {\n            if (next !== dir) {\n                dir = next;\n                this.bfsStepX[length] = x;\n                this.bfsStepZ[length++] = z;\n            }\n            if ((next & _jagex2_dash3d_DirectionFlag__WEBPACK_IMPORTED_MODULE_55__[\"default\"].EAST) !== 0) {\n                x++;\n            }\n            else if ((next & _jagex2_dash3d_DirectionFlag__WEBPACK_IMPORTED_MODULE_55__[\"default\"].WEST) !== 0) {\n                x--;\n            }\n            if ((next & _jagex2_dash3d_DirectionFlag__WEBPACK_IMPORTED_MODULE_55__[\"default\"].NORTH) !== 0) {\n                z++;\n            }\n            else if ((next & _jagex2_dash3d_DirectionFlag__WEBPACK_IMPORTED_MODULE_55__[\"default\"].SOUTH) !== 0) {\n                z--;\n            }\n            next = this.bfsDirection[_jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].index(x, z)];\n        }\n        if (length > 0) {\n            bufferSize = Math.min(length, 25); // max number of turns in a single pf request\n            length--;\n            const startX = this.bfsStepX[length];\n            const startZ = this.bfsStepZ[length];\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.showDebug && this.actionKey[6] === 1 && this.actionKey[7] === 1) {\n                // check if tile is already added, if so remove it\n                for (let i = 0; i < this.userTileMarkers.length; i++) {\n                    const marker = this.userTileMarkers[i];\n                    if (marker && marker.x === _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileX && marker.z === _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileZ) {\n                        this.userTileMarkers[i] = null;\n                        return false;\n                    }\n                }\n                // add new\n                this.userTileMarkers[this.userTileMarkerIndex] = new _jagex2_dash3d_type_Tile__WEBPACK_IMPORTED_MODULE_54__[\"default\"](this.currentLevel, _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileX, _jagex2_dash3d_World3D__WEBPACK_IMPORTED_MODULE_31__[\"default\"].clickTileZ);\n                this.userTileMarkerIndex = (this.userTileMarkerIndex + 1) & (this.userTileMarkers.length - 1);\n                return false;\n            }\n            if (type === 0) {\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].MOVE_GAMECLICK);\n                this.out.p1(bufferSize + bufferSize + 3);\n            }\n            else if (type === 1) {\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].MOVE_MINIMAPCLICK);\n                this.out.p1(bufferSize + bufferSize + 3 + 14);\n            }\n            else if (type === 2) {\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].MOVE_OPCLICK);\n                this.out.p1(bufferSize + bufferSize + 3);\n            }\n            if (this.actionKey[5] === 1) {\n                this.out.p1(1);\n            }\n            else {\n                this.out.p1(0);\n            }\n            this.out.p2(startX + this.sceneBaseTileX);\n            this.out.p2(startZ + this.sceneBaseTileZ);\n            this.flagSceneTileX = this.bfsStepX[0];\n            this.flagSceneTileZ = this.bfsStepZ[0];\n            for (let i = 1; i < bufferSize; i++) {\n                length--;\n                this.out.p1(this.bfsStepX[length] - startX);\n                this.out.p1(this.bfsStepZ[length] - startZ);\n            }\n            return true;\n        }\n        return type !== 1;\n    };\n    readPlayerInfo = (buf, size) => {\n        this.entityRemovalCount = 0;\n        this.entityUpdateCount = 0;\n        this.readLocalPlayer(buf);\n        this.readPlayers(buf);\n        this.readNewPlayers(buf, size);\n        this.readPlayerUpdates(buf);\n        for (let i = 0; i < this.entityRemovalCount; i++) {\n            const index = this.entityRemovalIds[i];\n            const player = this.players[index];\n            if (!player) {\n                continue;\n            }\n            if (player.cycle !== this.loopCycle) {\n                this.players[index] = null;\n            }\n        }\n        if (buf.pos !== size) {\n            throw new Error(`eek! Error packet size mismatch in getplayer pos:${buf.pos} psize:${size}`);\n        }\n        for (let index = 0; index < this.playerCount; index++) {\n            if (!this.players[this.playerIds[index]]) {\n                throw new Error(`eek! ${this.username} null entry in pl list - pos:${index} size:${this.playerCount}`);\n            }\n        }\n    };\n    readLocalPlayer = (buf) => {\n        buf.bits();\n        const hasUpdate = buf.gBit(1);\n        if (hasUpdate !== 0) {\n            const updateType = buf.gBit(2);\n            if (updateType === 0) {\n                this.entityUpdateIds[this.entityUpdateCount++] = this.LOCAL_PLAYER_INDEX;\n            }\n            else if (updateType === 1) {\n                const walkDir = buf.gBit(3);\n                this.localPlayer?.step(false, walkDir);\n                const hasMaskUpdate = buf.gBit(1);\n                if (hasMaskUpdate === 1) {\n                    this.entityUpdateIds[this.entityUpdateCount++] = this.LOCAL_PLAYER_INDEX;\n                }\n            }\n            else if (updateType === 2) {\n                const walkDir = buf.gBit(3);\n                this.localPlayer?.step(true, walkDir);\n                const runDir = buf.gBit(3);\n                this.localPlayer?.step(true, runDir);\n                const hasMaskUpdate = buf.gBit(1);\n                if (hasMaskUpdate === 1) {\n                    this.entityUpdateIds[this.entityUpdateCount++] = this.LOCAL_PLAYER_INDEX;\n                }\n            }\n            else if (updateType === 3) {\n                this.currentLevel = buf.gBit(2);\n                const localX = buf.gBit(7);\n                const localZ = buf.gBit(7);\n                const jump = buf.gBit(1);\n                this.localPlayer?.move(jump === 1, localX, localZ);\n                const hasMaskUpdate = buf.gBit(1);\n                if (hasMaskUpdate === 1) {\n                    this.entityUpdateIds[this.entityUpdateCount++] = this.LOCAL_PLAYER_INDEX;\n                }\n            }\n        }\n    };\n    readPlayers = (buf) => {\n        const count = buf.gBit(8);\n        if (count < this.playerCount) {\n            for (let i = count; i < this.playerCount; i++) {\n                this.entityRemovalIds[this.entityRemovalCount++] = this.playerIds[i];\n            }\n        }\n        if (count > this.playerCount) {\n            throw new Error(`eek! ${this.username} Too many players`);\n        }\n        this.playerCount = 0;\n        for (let i = 0; i < count; i++) {\n            const index = this.playerIds[i];\n            const player = this.players[index];\n            const hasUpdate = buf.gBit(1);\n            if (hasUpdate === 0) {\n                this.playerIds[this.playerCount++] = index;\n                if (player) {\n                    player.cycle = this.loopCycle;\n                }\n            }\n            else {\n                const updateType = buf.gBit(2);\n                if (updateType === 0) {\n                    this.playerIds[this.playerCount++] = index;\n                    if (player) {\n                        player.cycle = this.loopCycle;\n                    }\n                    this.entityUpdateIds[this.entityUpdateCount++] = index;\n                }\n                else if (updateType === 1) {\n                    this.playerIds[this.playerCount++] = index;\n                    if (player) {\n                        player.cycle = this.loopCycle;\n                    }\n                    const walkDir = buf.gBit(3);\n                    player?.step(false, walkDir);\n                    const hasMaskUpdate = buf.gBit(1);\n                    if (hasMaskUpdate === 1) {\n                        this.entityUpdateIds[this.entityUpdateCount++] = index;\n                    }\n                }\n                else if (updateType === 2) {\n                    this.playerIds[this.playerCount++] = index;\n                    if (player) {\n                        player.cycle = this.loopCycle;\n                    }\n                    const walkDir = buf.gBit(3);\n                    player?.step(true, walkDir);\n                    const runDir = buf.gBit(3);\n                    player?.step(true, runDir);\n                    const hasMaskUpdate = buf.gBit(1);\n                    if (hasMaskUpdate === 1) {\n                        this.entityUpdateIds[this.entityUpdateCount++] = index;\n                    }\n                }\n                else if (updateType === 3) {\n                    this.entityRemovalIds[this.entityRemovalCount++] = index;\n                }\n            }\n        }\n    };\n    readNewPlayers = (buf, size) => {\n        let index;\n        while (buf.bitPos + 10 < size * 8) {\n            index = buf.gBit(11);\n            if (index === 2047) {\n                break;\n            }\n            if (!this.players[index]) {\n                this.players[index] = new _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"]();\n                const appearance = this.playerAppearanceBuffer[index];\n                if (appearance) {\n                    this.players[index]?.read(appearance);\n                }\n            }\n            this.playerIds[this.playerCount++] = index;\n            const player = this.players[index];\n            if (player) {\n                player.cycle = this.loopCycle;\n            }\n            let dx = buf.gBit(5);\n            if (dx > 15) {\n                dx -= 32;\n            }\n            let dz = buf.gBit(5);\n            if (dz > 15) {\n                dz -= 32;\n            }\n            const jump = buf.gBit(1);\n            if (this.localPlayer) {\n                player?.move(jump === 1, this.localPlayer.pathTileX[0] + dx, this.localPlayer.pathTileZ[0] + dz);\n            }\n            const hasMaskUpdate = buf.gBit(1);\n            if (hasMaskUpdate === 1) {\n                this.entityUpdateIds[this.entityUpdateCount++] = index;\n            }\n        }\n        buf.bytes();\n    };\n    readPlayerUpdates = (buf) => {\n        for (let i = 0; i < this.entityUpdateCount; i++) {\n            const index = this.entityUpdateIds[i];\n            const player = this.players[index];\n            if (!player) {\n                continue; // its fine cos buffer gets out of pos and throws error which is ok\n            }\n            let mask = buf.g1;\n            if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].BIG_UPDATE) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].BIG_UPDATE) {\n                mask += buf.g1 << 8;\n            }\n            this.readPlayerUpdatesBlocks(player, index, mask, buf);\n        }\n    };\n    readPlayerUpdatesBlocks = (player, index, mask, buf) => {\n        player.lastMask = mask;\n        player.lastMaskCycle = this.loopCycle;\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].APPEARANCE) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].APPEARANCE) {\n            const length = buf.g1;\n            const data = new Uint8Array(length);\n            const appearance = new _jagex2_io_Packet__WEBPACK_IMPORTED_MODULE_16__[\"default\"](data);\n            buf.gdata(length, 0, data);\n            this.playerAppearanceBuffer[index] = appearance;\n            player.read(appearance);\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].ANIM) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].ANIM) {\n            let seqId = buf.g2;\n            if (seqId === 65535) {\n                seqId = -1;\n            }\n            if (seqId === player.primarySeqId) {\n                player.primarySeqLoop = 0;\n            }\n            const delay = buf.g1;\n            if (seqId === -1 || player.primarySeqId === -1 || _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[seqId].priority > _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[player.primarySeqId].priority || _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[player.primarySeqId].priority === 0) {\n                player.primarySeqId = seqId;\n                player.primarySeqFrame = 0;\n                player.primarySeqCycle = 0;\n                player.primarySeqDelay = delay;\n                player.primarySeqLoop = 0;\n            }\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_ENTITY) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_ENTITY) {\n            player.targetId = buf.g2;\n            if (player.targetId === 65535) {\n                player.targetId = -1;\n            }\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SAY) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SAY) {\n            player.chat = buf.gjstr;\n            player.chatColor = 0;\n            player.chatStyle = 0;\n            player.chatTimer = 150;\n            if (player.name) {\n                this.addMessage(2, player.chat, player.name);\n            }\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].DAMAGE) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].DAMAGE) {\n            player.damage = buf.g1;\n            player.damageType = buf.g1;\n            player.combatCycle = this.loopCycle + 400;\n            player.health = buf.g1;\n            player.totalHealth = buf.g1;\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_COORD) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].FACE_COORD) {\n            player.targetTileX = buf.g2;\n            player.targetTileZ = buf.g2;\n            player.lastFaceX = player.targetTileX;\n            player.lastFaceZ = player.targetTileZ;\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].CHAT) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].CHAT) {\n            const colorEffect = buf.g2;\n            const type = buf.g1;\n            const length = buf.g1;\n            const start = buf.pos;\n            if (player.name) {\n                const username = _jagex2_datastruct_JString__WEBPACK_IMPORTED_MODULE_29__[\"default\"].toBase37(player.name);\n                let ignored = false;\n                if (type <= 1) {\n                    for (let i = 0; i < this.ignoreCount; i++) {\n                        if (this.ignoreName37[i] === username) {\n                            ignored = true;\n                            break;\n                        }\n                    }\n                }\n                if (!ignored && this.overrideChat === 0) {\n                    try {\n                        const uncompressed = _jagex2_wordenc_WordPack__WEBPACK_IMPORTED_MODULE_24__[\"default\"].unpack(buf, length);\n                        const filtered = _jagex2_wordenc_WordFilter__WEBPACK_IMPORTED_MODULE_23__[\"default\"].filter(uncompressed);\n                        player.chat = filtered;\n                        player.chatColor = colorEffect >> 8;\n                        player.chatStyle = colorEffect & 0xff;\n                        player.chatTimer = 150;\n                        if (type > 1) {\n                            this.addMessage(1, filtered, player.name);\n                        }\n                        else {\n                            this.addMessage(2, filtered, player.name);\n                        }\n                    }\n                    catch (e) {\n                        // signlink.reporterror(\"cde2\");\n                    }\n                }\n            }\n            buf.pos = start + length;\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SPOTANIM) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].SPOTANIM) {\n            player.spotanimId = buf.g2;\n            const heightDelay = buf.g4;\n            player.spotanimOffset = heightDelay >> 16;\n            player.spotanimLastCycle = this.loopCycle + (heightDelay & 0xffff);\n            player.spotanimFrame = 0;\n            player.spotanimCycle = 0;\n            if (player.spotanimLastCycle > this.loopCycle) {\n                player.spotanimFrame = -1;\n            }\n            if (player.spotanimId === 65535) {\n                player.spotanimId = -1;\n            }\n        }\n        if ((mask & _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].EXACT_MOVE) === _jagex2_dash3d_entity_PlayerEntity__WEBPACK_IMPORTED_MODULE_40__[\"default\"].EXACT_MOVE) {\n            player.forceMoveStartSceneTileX = buf.g1;\n            player.forceMoveStartSceneTileZ = buf.g1;\n            player.forceMoveEndSceneTileX = buf.g1;\n            player.forceMoveEndSceneTileZ = buf.g1;\n            player.forceMoveEndCycle = buf.g2 + this.loopCycle;\n            player.forceMoveStartCycle = buf.g2 + this.loopCycle;\n            player.forceMoveFaceDirection = buf.g1;\n            player.pathLength = 0;\n            player.pathTileX[0] = player.forceMoveEndSceneTileX;\n            player.pathTileZ[0] = player.forceMoveEndSceneTileZ;\n        }\n    };\n    readNpcInfo = (buf, size) => {\n        this.entityRemovalCount = 0;\n        this.entityUpdateCount = 0;\n        this.readNpcs(buf);\n        this.readNewNpcs(buf, size);\n        this.readNpcUpdates(buf);\n        for (let i = 0; i < this.entityRemovalCount; i++) {\n            const index = this.entityRemovalIds[i];\n            const npc = this.npcs[index];\n            if (!npc) {\n                continue;\n            }\n            if (npc.cycle !== this.loopCycle) {\n                npc.type = null;\n                this.npcs[index] = null;\n            }\n        }\n        if (buf.pos !== size) {\n            throw new Error(`eek! ${this.username} size mismatch in getnpcpos - pos:${buf.pos} psize:${size}`);\n        }\n        for (let i = 0; i < this.npcCount; i++) {\n            if (!this.npcs[this.npcIds[i]]) {\n                throw new Error(`eek! ${this.username} null entry in npc list - pos:${i} size:${this.npcCount}`);\n            }\n        }\n    };\n    readNpcs = (buf) => {\n        buf.bits();\n        const count = buf.gBit(8);\n        if (count < this.npcCount) {\n            for (let i = count; i < this.npcCount; i++) {\n                this.entityRemovalIds[this.entityRemovalCount++] = this.npcIds[i];\n            }\n        }\n        if (count > this.npcCount) {\n            throw new Error(`eek! ${this.username} Too many npc!`);\n        }\n        this.npcCount = 0;\n        for (let i = 0; i < count; i++) {\n            const index = this.npcIds[i];\n            const npc = this.npcs[index];\n            const hasUpdate = buf.gBit(1);\n            if (hasUpdate === 0) {\n                this.npcIds[this.npcCount++] = index;\n                if (npc) {\n                    npc.cycle = this.loopCycle;\n                }\n            }\n            else {\n                const updateType = buf.gBit(2);\n                if (updateType === 0) {\n                    this.npcIds[this.npcCount++] = index;\n                    if (npc) {\n                        npc.cycle = this.loopCycle;\n                    }\n                    this.entityUpdateIds[this.entityUpdateCount++] = index;\n                }\n                else if (updateType === 1) {\n                    this.npcIds[this.npcCount++] = index;\n                    if (npc) {\n                        npc.cycle = this.loopCycle;\n                    }\n                    const walkDir = buf.gBit(3);\n                    npc?.step(false, walkDir);\n                    const hasMaskUpdate = buf.gBit(1);\n                    if (hasMaskUpdate === 1) {\n                        this.entityUpdateIds[this.entityUpdateCount++] = index;\n                    }\n                }\n                else if (updateType === 2) {\n                    this.npcIds[this.npcCount++] = index;\n                    if (npc) {\n                        npc.cycle = this.loopCycle;\n                    }\n                    const walkDir = buf.gBit(3);\n                    npc?.step(true, walkDir);\n                    const runDir = buf.gBit(3);\n                    npc?.step(true, runDir);\n                    const hasMaskUpdate = buf.gBit(1);\n                    if (hasMaskUpdate === 1) {\n                        this.entityUpdateIds[this.entityUpdateCount++] = index;\n                    }\n                }\n                else if (updateType === 3) {\n                    this.entityRemovalIds[this.entityRemovalCount++] = index;\n                }\n            }\n        }\n    };\n    readNewNpcs = (buf, size) => {\n        while (buf.bitPos + 21 < size * 8) {\n            const index = buf.gBit(13);\n            if (index === 8191) {\n                break;\n            }\n            if (!this.npcs[index]) {\n                this.npcs[index] = new _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"]();\n            }\n            const npc = this.npcs[index];\n            this.npcIds[this.npcCount++] = index;\n            if (npc) {\n                npc.cycle = this.loopCycle;\n                npc.type = _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(buf.gBit(11));\n                npc.size = npc.type.size;\n                npc.seqWalkId = npc.type.walkanim;\n                npc.seqTurnAroundId = npc.type.walkanim_b;\n                npc.seqTurnLeftId = npc.type.walkanim_r;\n                npc.seqTurnRightId = npc.type.walkanim_l;\n                npc.seqStandId = npc.type.readyanim;\n            }\n            else {\n                buf.gBit(11);\n            }\n            let dx = buf.gBit(5);\n            if (dx > 15) {\n                dx -= 32;\n            }\n            let dz = buf.gBit(5);\n            if (dz > 15) {\n                dz -= 32;\n            }\n            if (this.localPlayer) {\n                npc?.move(false, this.localPlayer.pathTileX[0] + dx, this.localPlayer.pathTileZ[0] + dz);\n            }\n            const update = buf.gBit(1);\n            if (update === 1) {\n                this.entityUpdateIds[this.entityUpdateCount++] = index;\n            }\n        }\n        buf.bytes();\n    };\n    readNpcUpdates = (buf) => {\n        for (let i = 0; i < this.entityUpdateCount; i++) {\n            const id = this.entityUpdateIds[i];\n            const npc = this.npcs[id];\n            if (!npc) {\n                continue; // its fine cos buffer gets out of pos and throws error which is ok\n            }\n            const mask = buf.g1;\n            npc.lastMask = mask;\n            npc.lastMaskCycle = this.loopCycle;\n            if ((mask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].ANIM) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].ANIM) {\n                let seqId = buf.g2;\n                if (seqId === 65535) {\n                    seqId = -1;\n                }\n                if (seqId === npc.primarySeqId) {\n                    npc.primarySeqLoop = 0;\n                }\n                const delay = buf.g1;\n                if (seqId === -1 || npc.primarySeqId === -1 || _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[seqId].priority > _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[npc.primarySeqId].priority || _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[npc.primarySeqId].priority === 0) {\n                    npc.primarySeqId = seqId;\n                    npc.primarySeqFrame = 0;\n                    npc.primarySeqCycle = 0;\n                    npc.primarySeqDelay = delay;\n                    npc.primarySeqLoop = 0;\n                }\n            }\n            if ((mask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_ENTITY) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_ENTITY) {\n                npc.targetId = buf.g2;\n                if (npc.targetId === 65535) {\n                    npc.targetId = -1;\n                }\n            }\n            if ((mask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SAY) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SAY) {\n                npc.chat = buf.gjstr;\n                npc.chatTimer = 100;\n            }\n            if ((mask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].DAMAGE) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].DAMAGE) {\n                npc.damage = buf.g1;\n                npc.damageType = buf.g1;\n                npc.combatCycle = this.loopCycle + 400;\n                npc.health = buf.g1;\n                npc.totalHealth = buf.g1;\n            }\n            if ((mask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].CHANGE_TYPE) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].CHANGE_TYPE) {\n                npc.type = _jagex2_config_NpcType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(buf.g2);\n                npc.seqWalkId = npc.type.walkanim;\n                npc.seqTurnAroundId = npc.type.walkanim_b;\n                npc.seqTurnLeftId = npc.type.walkanim_r;\n                npc.seqTurnRightId = npc.type.walkanim_l;\n                npc.seqStandId = npc.type.readyanim;\n            }\n            if ((mask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SPOTANIM) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].SPOTANIM) {\n                npc.spotanimId = buf.g2;\n                const info = buf.g4;\n                npc.spotanimOffset = info >> 16;\n                npc.spotanimLastCycle = this.loopCycle + (info & 0xffff);\n                npc.spotanimFrame = 0;\n                npc.spotanimCycle = 0;\n                if (npc.spotanimLastCycle > this.loopCycle) {\n                    npc.spotanimFrame = -1;\n                }\n                if (npc.spotanimId === 65535) {\n                    npc.spotanimId = -1;\n                }\n            }\n            if ((mask & _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_COORD) === _jagex2_dash3d_entity_NpcEntity__WEBPACK_IMPORTED_MODULE_41__[\"default\"].FACE_COORD) {\n                npc.targetTileX = buf.g2;\n                npc.targetTileZ = buf.g2;\n                npc.lastFaceX = npc.targetTileX;\n                npc.lastFaceZ = npc.targetTileZ;\n            }\n        }\n    };\n    updatePlayers = () => {\n        for (let i = -1; i < this.playerCount; i++) {\n            let index;\n            if (i === -1) {\n                index = this.LOCAL_PLAYER_INDEX;\n            }\n            else {\n                index = this.playerIds[i];\n            }\n            const player = this.players[index];\n            if (player) {\n                this.updateEntity(player);\n            }\n        }\n        _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic6++;\n        if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic6 > 1406) {\n            _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic6 = 0;\n            // ANTICHEAT_CYCLELOGIC6\n            this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_CYCLELOGIC6);\n            this.out.p1(0);\n            const start = this.out.pos;\n            this.out.p1(162);\n            this.out.p1(22);\n            if (((Math.random() * 2.0) | 0) === 0) {\n                this.out.p1(84);\n            }\n            this.out.p2(31824);\n            this.out.p2(13490);\n            if (((Math.random() * 2.0) | 0) === 0) {\n                this.out.p1(123);\n            }\n            if (((Math.random() * 2.0) | 0) === 0) {\n                this.out.p1(134);\n            }\n            this.out.p1(100);\n            this.out.p1(94);\n            this.out.p2(35521);\n            this.out.psize1(this.out.pos - start);\n        }\n    };\n    updateEntity = (entity) => {\n        if (entity.x < 128 || entity.z < 128 || entity.x >= 13184 || entity.z >= 13184) {\n            entity.primarySeqId = -1;\n            entity.spotanimId = -1;\n            entity.forceMoveEndCycle = 0;\n            entity.forceMoveStartCycle = 0;\n            entity.x = entity.pathTileX[0] * 128 + entity.size * 64;\n            entity.z = entity.pathTileZ[0] * 128 + entity.size * 64;\n            entity.pathLength = 0;\n        }\n        if (entity === this.localPlayer && (entity.x < 1536 || entity.z < 1536 || entity.x >= 11776 || entity.z >= 11776)) {\n            entity.primarySeqId = -1;\n            entity.spotanimId = -1;\n            entity.forceMoveEndCycle = 0;\n            entity.forceMoveStartCycle = 0;\n            entity.x = entity.pathTileX[0] * 128 + entity.size * 64;\n            entity.z = entity.pathTileZ[0] * 128 + entity.size * 64;\n            entity.pathLength = 0;\n        }\n        if (entity.forceMoveEndCycle > this.loopCycle) {\n            this.updateForceMovement(entity);\n        }\n        else if (entity.forceMoveStartCycle >= this.loopCycle) {\n            this.startForceMovement(entity);\n        }\n        else {\n            this.updateMovement(entity);\n        }\n        this.updateFacingDirection(entity);\n        this.updateSequences(entity);\n    };\n    pushPlayers = () => {\n        if (!this.localPlayer) {\n            return;\n        }\n        if (this.localPlayer.x >> 7 === this.flagSceneTileX && this.localPlayer.z >> 7 === this.flagSceneTileZ) {\n            this.flagSceneTileX = 0;\n        }\n        for (let i = -1; i < this.playerCount; i++) {\n            let player;\n            let id;\n            if (i === -1) {\n                player = this.localPlayer;\n                id = this.LOCAL_PLAYER_INDEX << 14;\n            }\n            else {\n                player = this.players[this.playerIds[i]];\n                id = this.playerIds[i] << 14;\n            }\n            if (!player || !player.isVisible()) {\n                continue;\n            }\n            player.lowMemory = ((_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory && this.playerCount > 50) || this.playerCount > 200) && i !== -1 && player.secondarySeqId === player.seqStandId;\n            const stx = player.x >> 7;\n            const stz = player.z >> 7;\n            if (stx < 0 || stx >= _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE || stz < 0 || stz >= _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                continue;\n            }\n            if (!player.locModel || this.loopCycle < player.locStartCycle || this.loopCycle >= player.locStopCycle) {\n                if ((player.x & 0x7f) === 64 && (player.z & 0x7f) === 64) {\n                    if (this.tileLastOccupiedCycle[stx][stz] === this.sceneCycle) {\n                        continue;\n                    }\n                    this.tileLastOccupiedCycle[stx][stz] = this.sceneCycle;\n                }\n                player.y = this.getHeightmapY(this.currentLevel, player.x, player.z);\n                this.scene?.addTemporary(this.currentLevel, player.x, player.y, player.z, null, player, id, player.yaw, 60, player.seqStretches);\n            }\n            else {\n                player.lowMemory = false;\n                player.y = this.getHeightmapY(this.currentLevel, player.x, player.z);\n                this.scene?.addTemporary2(this.currentLevel, player.x, player.y, player.z, player.minTileX, player.minTileZ, player.maxTileX, player.maxTileZ, null, player, id, player.yaw);\n            }\n        }\n    };\n    updateNpcs = () => {\n        for (let i = 0; i < this.npcCount; i++) {\n            const id = this.npcIds[i];\n            const npc = this.npcs[id];\n            if (npc && npc.type) {\n                this.updateEntity(npc);\n            }\n        }\n    };\n    pushNpcs = () => {\n        for (let i = 0; i < this.npcCount; i++) {\n            const npc = this.npcs[this.npcIds[i]];\n            const bitset = ((this.npcIds[i] << 14) + 0x20000000) | 0;\n            if (!npc || !npc.isVisible()) {\n                continue;\n            }\n            const x = npc.x >> 7;\n            const z = npc.z >> 7;\n            if (x < 0 || x >= _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE || z < 0 || z >= _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                continue;\n            }\n            if (npc.size === 1 && (npc.x & 0x7f) === 64 && (npc.z & 0x7f) === 64) {\n                if (this.tileLastOccupiedCycle[x][z] === this.sceneCycle) {\n                    continue;\n                }\n                this.tileLastOccupiedCycle[x][z] = this.sceneCycle;\n            }\n            this.scene?.addTemporary(this.currentLevel, npc.x, this.getHeightmapY(this.currentLevel, npc.x, npc.z), npc.z, null, npc, bitset, npc.yaw, (npc.size - 1) * 64 + 60, npc.seqStretches);\n        }\n    };\n    pushProjectiles = () => {\n        for (let proj = this.projectiles.head(); proj; proj = this.projectiles.next()) {\n            if (proj.level !== this.currentLevel || this.loopCycle > proj.lastCycle) {\n                proj.unlink();\n            }\n            else if (this.loopCycle >= proj.startCycle) {\n                if (proj.target > 0) {\n                    const npc = this.npcs[proj.target - 1];\n                    if (npc) {\n                        proj.updateVelocity(npc.x, this.getHeightmapY(proj.level, npc.x, npc.z) - proj.offsetY, npc.z, this.loopCycle);\n                    }\n                }\n                if (proj.target < 0) {\n                    const index = -proj.target - 1;\n                    let player;\n                    if (index === this.localPid) {\n                        player = this.localPlayer;\n                    }\n                    else {\n                        player = this.players[index];\n                    }\n                    if (player) {\n                        proj.updateVelocity(player.x, this.getHeightmapY(proj.level, player.x, player.z) - proj.offsetY, player.z, this.loopCycle);\n                    }\n                }\n                proj.update(this.sceneDelta);\n                this.scene?.addTemporary(this.currentLevel, proj.x | 0, proj.y | 0, proj.z | 0, null, proj, -1, proj.yaw, 60, false);\n            }\n        }\n    };\n    pushSpotanims = () => {\n        for (let entity = this.spotanims.head(); entity; entity = this.spotanims.next()) {\n            if (entity.level !== this.currentLevel || entity.seqComplete) {\n                entity.unlink();\n            }\n            else if (this.loopCycle >= entity.startCycle) {\n                entity.update(this.sceneDelta);\n                if (entity.seqComplete) {\n                    entity.unlink();\n                }\n                else {\n                    this.scene?.addTemporary(entity.level, entity.x, entity.y, entity.z, null, entity, -1, 0, 60, false);\n                }\n            }\n        }\n    };\n    pushLocs = () => {\n        for (let loc = this.locList.head(); loc; loc = this.locList.next()) {\n            let append = false;\n            loc.seqCycle += this.sceneDelta;\n            if (loc.seqFrame === -1) {\n                loc.seqFrame = 0;\n                append = true;\n            }\n            if (loc.seq.delay) {\n                while (loc.seqCycle > loc.seq.delay[loc.seqFrame]) {\n                    loc.seqCycle -= loc.seq.delay[loc.seqFrame] + 1;\n                    loc.seqFrame++;\n                    append = true;\n                    if (loc.seqFrame >= loc.seq.frameCount) {\n                        loc.seqFrame -= loc.seq.replayoff;\n                        if (loc.seqFrame < 0 || loc.seqFrame >= loc.seq.frameCount) {\n                            loc.unlink();\n                            append = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (append && this.scene) {\n                const level = loc.heightmapSW;\n                const x = loc.heightmapNE;\n                const z = loc.heightmapNW;\n                let bitset = 0;\n                if (loc.heightmapSE === 0) {\n                    bitset = this.scene.getWallBitset(level, x, z);\n                }\n                else if (loc.heightmapSE === 1) {\n                    bitset = this.scene.getWallDecorationBitset(level, z, x);\n                }\n                else if (loc.heightmapSE === 2) {\n                    bitset = this.scene.getLocBitset(level, x, z);\n                }\n                else if (loc.heightmapSE === 3) {\n                    bitset = this.scene.getGroundDecorationBitset(level, x, z);\n                }\n                if (this.levelHeightmap && bitset !== 0 && ((bitset >> 14) & 0x7fff) === loc.index) {\n                    const heightmapSW = this.levelHeightmap[level][x][z];\n                    const heightmapSE = this.levelHeightmap[level][x + 1][z];\n                    const heightmapNE = this.levelHeightmap[level][x + 1][z + 1];\n                    const heightmapNW = this.levelHeightmap[level][x][z + 1];\n                    const type = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(loc.index);\n                    let seqId = -1;\n                    if (loc.seqFrame !== -1 && loc.seq.frames) {\n                        seqId = loc.seq.frames[loc.seqFrame];\n                    }\n                    if (loc.heightmapSE === 2) {\n                        const info = this.scene.getInfo(level, x, z, bitset);\n                        let shape = info & 0x1f;\n                        const rotation = info >> 6;\n                        if (shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].CENTREPIECE_DIAGONAL.id) {\n                            shape = _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].CENTREPIECE_STRAIGHT.id;\n                        }\n                        this.scene?.setLocModel(level, x, z, type.getModel(shape, rotation, heightmapSW, heightmapSE, heightmapNE, heightmapNW, seqId));\n                    }\n                    else if (loc.heightmapSE === 1) {\n                        this.scene?.setWallDecorationModel(level, x, z, type.getModel(_jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, 0, heightmapSW, heightmapSE, heightmapNE, heightmapNW, seqId));\n                    }\n                    else if (loc.heightmapSE === 0) {\n                        const info = this.scene.getInfo(level, x, z, bitset);\n                        const shape = info & 0x1f;\n                        const rotation = info >> 6;\n                        if (shape === _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_L.id) {\n                            const nextRotation = (rotation + 1) & 0x3;\n                            this.scene?.setWallModels(x, z, level, type.getModel(_jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_L.id, rotation + 4, heightmapSW, heightmapSE, heightmapNE, heightmapNW, seqId), type.getModel(_jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_L.id, nextRotation, heightmapSW, heightmapSE, heightmapNE, heightmapNW, seqId));\n                        }\n                        else {\n                            this.scene?.setWallModel(level, x, z, type.getModel(shape, rotation, heightmapSW, heightmapSE, heightmapNE, heightmapNW, seqId));\n                        }\n                    }\n                    else if (loc.heightmapSE === 3) {\n                        const info = this.scene.getInfo(level, x, z, bitset);\n                        const rotation = info >> 6;\n                        this.scene?.setGroundDecorationModel(level, x, z, type.getModel(_jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].GROUND_DECOR.id, rotation, heightmapSW, heightmapSE, heightmapNE, heightmapNW, seqId));\n                    }\n                }\n                else {\n                    loc.unlink();\n                }\n            }\n        }\n    };\n    updateEntityChats = () => {\n        for (let i = -1; i < this.playerCount; i++) {\n            let index;\n            if (i === -1) {\n                index = this.LOCAL_PLAYER_INDEX;\n            }\n            else {\n                index = this.playerIds[i];\n            }\n            const player = this.players[index];\n            if (player && player.chatTimer > 0) {\n                player.chatTimer--;\n                if (player.chatTimer === 0) {\n                    player.chat = null;\n                }\n            }\n        }\n        for (let i = 0; i < this.npcCount; i++) {\n            const index = this.npcIds[i];\n            const npc = this.npcs[index];\n            if (npc && npc.chatTimer > 0) {\n                npc.chatTimer--;\n                if (npc.chatTimer === 0) {\n                    npc.chat = null;\n                }\n            }\n        }\n    };\n    updateTemporaryLocs = () => {\n        if (this.sceneState === 2) {\n            for (let loc = this.temporaryLocs.head(); loc; loc = this.temporaryLocs.next()) {\n                if (this.loopCycle >= loc.lastCycle) {\n                    this.addLoc(loc.plane, loc.x, loc.z, loc.locIndex, loc.angle, loc.shape, loc.layer);\n                    loc.unlink();\n                }\n            }\n            _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic5++;\n            if (_client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic5 > 85) {\n                _client__WEBPACK_IMPORTED_MODULE_49__.Client.cyclelogic5 = 0;\n                // ANTICHEAT_CYCLELOGIC5\n                this.out.p1isaac(_jagex2_io_ClientProt__WEBPACK_IMPORTED_MODULE_22__[\"default\"].ANTICHEAT_CYCLELOGIC5);\n            }\n        }\n    };\n    updateForceMovement = (entity) => {\n        const delta = entity.forceMoveEndCycle - this.loopCycle;\n        const dstX = entity.forceMoveStartSceneTileX * 128 + entity.size * 64;\n        const dstZ = entity.forceMoveStartSceneTileZ * 128 + entity.size * 64;\n        entity.x += ((dstX - entity.x) / delta) | 0;\n        entity.z += ((dstZ - entity.z) / delta) | 0;\n        entity.seqTrigger = 0;\n        if (entity.forceMoveFaceDirection === 0) {\n            entity.dstYaw = 1024;\n        }\n        if (entity.forceMoveFaceDirection === 1) {\n            entity.dstYaw = 1536;\n        }\n        if (entity.forceMoveFaceDirection === 2) {\n            entity.dstYaw = 0;\n        }\n        if (entity.forceMoveFaceDirection === 3) {\n            entity.dstYaw = 512;\n        }\n    };\n    startForceMovement = (entity) => {\n        if (entity.forceMoveStartCycle === this.loopCycle || entity.primarySeqId === -1 || entity.primarySeqDelay !== 0 || entity.primarySeqCycle + 1 > _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[entity.primarySeqId].delay[entity.primarySeqFrame]) {\n            const duration = entity.forceMoveStartCycle - entity.forceMoveEndCycle;\n            const delta = this.loopCycle - entity.forceMoveEndCycle;\n            const dx0 = entity.forceMoveStartSceneTileX * 128 + entity.size * 64;\n            const dz0 = entity.forceMoveStartSceneTileZ * 128 + entity.size * 64;\n            const dx1 = entity.forceMoveEndSceneTileX * 128 + entity.size * 64;\n            const dz1 = entity.forceMoveEndSceneTileZ * 128 + entity.size * 64;\n            entity.x = ((dx0 * (duration - delta) + dx1 * delta) / duration) | 0;\n            entity.z = ((dz0 * (duration - delta) + dz1 * delta) / duration) | 0;\n        }\n        entity.seqTrigger = 0;\n        if (entity.forceMoveFaceDirection === 0) {\n            entity.dstYaw = 1024;\n        }\n        if (entity.forceMoveFaceDirection === 1) {\n            entity.dstYaw = 1536;\n        }\n        if (entity.forceMoveFaceDirection === 2) {\n            entity.dstYaw = 0;\n        }\n        if (entity.forceMoveFaceDirection === 3) {\n            entity.dstYaw = 512;\n        }\n        entity.yaw = entity.dstYaw;\n    };\n    updateFacingDirection = (e) => {\n        if (e.targetId !== -1 && e.targetId < 32768) {\n            const npc = this.npcs[e.targetId];\n            if (npc) {\n                const dstX = e.x - npc.x;\n                const dstZ = e.z - npc.z;\n                if (dstX !== 0 || dstZ !== 0) {\n                    e.dstYaw = ((Math.atan2(dstX, dstZ) * 325.949) | 0) & 0x7ff;\n                }\n            }\n        }\n        if (e.targetId >= 32768) {\n            let index = e.targetId - 32768;\n            if (index === this.localPid) {\n                index = this.LOCAL_PLAYER_INDEX;\n            }\n            const player = this.players[index];\n            if (player) {\n                const dstX = e.x - player.x;\n                const dstZ = e.z - player.z;\n                if (dstX !== 0 || dstZ !== 0) {\n                    e.dstYaw = ((Math.atan2(dstX, dstZ) * 325.949) | 0) & 0x7ff;\n                }\n            }\n        }\n        if ((e.targetTileX !== 0 || e.targetTileZ !== 0) && (e.pathLength === 0 || e.seqTrigger > 0)) {\n            const dstX = e.x - (e.targetTileX - this.sceneBaseTileX - this.sceneBaseTileX) * 64;\n            const dstZ = e.z - (e.targetTileZ - this.sceneBaseTileZ - this.sceneBaseTileZ) * 64;\n            if (dstX !== 0 || dstZ !== 0) {\n                e.dstYaw = ((Math.atan2(dstX, dstZ) * 325.949) | 0) & 0x7ff;\n            }\n            e.targetTileX = 0;\n            e.targetTileZ = 0;\n        }\n        const remainingYaw = (e.dstYaw - e.yaw) & 0x7ff;\n        if (remainingYaw !== 0) {\n            if (remainingYaw < 32 || remainingYaw > 2016) {\n                e.yaw = e.dstYaw;\n            }\n            else if (remainingYaw > 1024) {\n                e.yaw -= 32;\n            }\n            else {\n                e.yaw += 32;\n            }\n            e.yaw &= 0x7ff;\n            if (e.secondarySeqId === e.seqStandId && e.yaw !== e.dstYaw) {\n                if (e.seqTurnId !== -1) {\n                    e.secondarySeqId = e.seqTurnId;\n                    return;\n                }\n                e.secondarySeqId = e.seqWalkId;\n            }\n        }\n    };\n    updateSequences = (e) => {\n        e.seqStretches = false;\n        let seq;\n        if (e.secondarySeqId !== -1) {\n            seq = _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[e.secondarySeqId];\n            e.secondarySeqCycle++;\n            if (seq.delay && e.secondarySeqFrame < seq.frameCount && e.secondarySeqCycle > seq.delay[e.secondarySeqFrame]) {\n                e.secondarySeqCycle = 0;\n                e.secondarySeqFrame++;\n            }\n            if (e.secondarySeqFrame >= seq.frameCount) {\n                e.secondarySeqCycle = 0;\n                e.secondarySeqFrame = 0;\n            }\n        }\n        if (e.primarySeqId !== -1 && e.primarySeqDelay === 0) {\n            seq = _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[e.primarySeqId];\n            e.primarySeqCycle++;\n            while (seq.delay && e.primarySeqFrame < seq.frameCount && e.primarySeqCycle > seq.delay[e.primarySeqFrame]) {\n                e.primarySeqCycle -= seq.delay[e.primarySeqFrame];\n                e.primarySeqFrame++;\n            }\n            if (e.primarySeqFrame >= seq.frameCount) {\n                e.primarySeqFrame -= seq.replayoff;\n                e.primarySeqLoop++;\n                if (e.primarySeqLoop >= seq.replaycount) {\n                    e.primarySeqId = -1;\n                }\n                if (e.primarySeqFrame < 0 || e.primarySeqFrame >= seq.frameCount) {\n                    e.primarySeqId = -1;\n                }\n            }\n            e.seqStretches = seq.stretches;\n        }\n        if (e.primarySeqDelay > 0) {\n            e.primarySeqDelay--;\n        }\n        if (e.spotanimId !== -1 && this.loopCycle >= e.spotanimLastCycle) {\n            if (e.spotanimFrame < 0) {\n                e.spotanimFrame = 0;\n            }\n            seq = _jagex2_config_SpotAnimType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instances[e.spotanimId].seq;\n            e.spotanimCycle++;\n            while (seq && seq.delay && e.spotanimFrame < seq.frameCount && e.spotanimCycle > seq.delay[e.spotanimFrame]) {\n                e.spotanimCycle -= seq.delay[e.spotanimFrame];\n                e.spotanimFrame++;\n            }\n            if (seq && e.spotanimFrame >= seq.frameCount) {\n                if (e.spotanimFrame < 0 || e.spotanimFrame >= seq.frameCount) {\n                    e.spotanimId = -1;\n                }\n            }\n        }\n    };\n    updateMovement = (entity) => {\n        entity.secondarySeqId = entity.seqStandId;\n        if (entity.pathLength === 0) {\n            entity.seqTrigger = 0;\n            return;\n        }\n        if (entity.primarySeqId !== -1 && entity.primarySeqDelay === 0) {\n            const seq = _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[entity.primarySeqId];\n            if (!seq.walkmerge) {\n                entity.seqTrigger++;\n                return;\n            }\n        }\n        const x = entity.x;\n        const z = entity.z;\n        const dstX = entity.pathTileX[entity.pathLength - 1] * 128 + entity.size * 64;\n        const dstZ = entity.pathTileZ[entity.pathLength - 1] * 128 + entity.size * 64;\n        if (dstX - x <= 256 && dstX - x >= -256 && dstZ - z <= 256 && dstZ - z >= -256) {\n            if (x < dstX) {\n                if (z < dstZ) {\n                    entity.dstYaw = 1280;\n                }\n                else if (z > dstZ) {\n                    entity.dstYaw = 1792;\n                }\n                else {\n                    entity.dstYaw = 1536;\n                }\n            }\n            else if (x > dstX) {\n                if (z < dstZ) {\n                    entity.dstYaw = 768;\n                }\n                else if (z > dstZ) {\n                    entity.dstYaw = 256;\n                }\n                else {\n                    entity.dstYaw = 512;\n                }\n            }\n            else if (z < dstZ) {\n                entity.dstYaw = 1024;\n            }\n            else {\n                entity.dstYaw = 0;\n            }\n            let deltaYaw = (entity.dstYaw - entity.yaw) & 0x7ff;\n            if (deltaYaw > 1024) {\n                deltaYaw -= 2048;\n            }\n            let seqId = entity.seqTurnAroundId;\n            if (deltaYaw >= -256 && deltaYaw <= 256) {\n                seqId = entity.seqWalkId;\n            }\n            else if (deltaYaw >= 256 && deltaYaw < 768) {\n                seqId = entity.seqTurnRightId;\n            }\n            else if (deltaYaw >= -768 && deltaYaw <= -256) {\n                seqId = entity.seqTurnLeftId;\n            }\n            if (seqId === -1) {\n                seqId = entity.seqWalkId;\n            }\n            entity.secondarySeqId = seqId;\n            let moveSpeed = 4;\n            if (entity.yaw !== entity.dstYaw && entity.targetId === -1) {\n                moveSpeed = 2;\n            }\n            if (entity.pathLength > 2) {\n                moveSpeed = 6;\n            }\n            if (entity.pathLength > 3) {\n                moveSpeed = 8;\n            }\n            if (entity.seqTrigger > 0 && entity.pathLength > 1) {\n                moveSpeed = 8;\n                entity.seqTrigger--;\n            }\n            if (entity.pathRunning[entity.pathLength - 1]) {\n                moveSpeed <<= 0x1;\n            }\n            if (moveSpeed >= 8 && entity.secondarySeqId === entity.seqWalkId && entity.seqRunId !== -1) {\n                entity.secondarySeqId = entity.seqRunId;\n            }\n            if (x < dstX) {\n                entity.x += moveSpeed;\n                if (entity.x > dstX) {\n                    entity.x = dstX;\n                }\n            }\n            else if (x > dstX) {\n                entity.x -= moveSpeed;\n                if (entity.x < dstX) {\n                    entity.x = dstX;\n                }\n            }\n            if (z < dstZ) {\n                entity.z += moveSpeed;\n                if (entity.z > dstZ) {\n                    entity.z = dstZ;\n                }\n            }\n            else if (z > dstZ) {\n                entity.z -= moveSpeed;\n                if (entity.z < dstZ) {\n                    entity.z = dstZ;\n                }\n            }\n            if (entity.x === dstX && entity.z === dstZ) {\n                entity.pathLength--;\n            }\n        }\n        else {\n            entity.x = dstX;\n            entity.z = dstZ;\n        }\n    };\n    getTopLevel = () => {\n        let top = 3;\n        if (this.cameraPitch < 310 && this.localPlayer) {\n            let cameraLocalTileX = this.cameraX >> 7;\n            let cameraLocalTileZ = this.cameraZ >> 7;\n            const playerLocalTileX = this.localPlayer.x >> 7;\n            const playerLocalTileZ = this.localPlayer.z >> 7;\n            if (this.levelTileFlags && (this.levelTileFlags[this.currentLevel][cameraLocalTileX][cameraLocalTileZ] & 0x4) !== 0) {\n                top = this.currentLevel;\n            }\n            let tileDeltaX;\n            if (playerLocalTileX > cameraLocalTileX) {\n                tileDeltaX = playerLocalTileX - cameraLocalTileX;\n            }\n            else {\n                tileDeltaX = cameraLocalTileX - playerLocalTileX;\n            }\n            let tileDeltaZ;\n            if (playerLocalTileZ > cameraLocalTileZ) {\n                tileDeltaZ = playerLocalTileZ - cameraLocalTileZ;\n            }\n            else {\n                tileDeltaZ = cameraLocalTileZ - playerLocalTileZ;\n            }\n            let delta;\n            let accumulator;\n            if (tileDeltaX > tileDeltaZ) {\n                delta = ((tileDeltaZ * 65536) / tileDeltaX) | 0;\n                accumulator = 32768;\n                while (cameraLocalTileX !== playerLocalTileX) {\n                    if (cameraLocalTileX < playerLocalTileX) {\n                        cameraLocalTileX++;\n                    }\n                    else if (cameraLocalTileX > playerLocalTileX) {\n                        cameraLocalTileX--;\n                    }\n                    if (this.levelTileFlags && (this.levelTileFlags[this.currentLevel][cameraLocalTileX][cameraLocalTileZ] & 0x4) !== 0) {\n                        top = this.currentLevel;\n                    }\n                    accumulator += delta;\n                    if (accumulator >= 65536) {\n                        accumulator -= 65536;\n                        if (cameraLocalTileZ < playerLocalTileZ) {\n                            cameraLocalTileZ++;\n                        }\n                        else if (cameraLocalTileZ > playerLocalTileZ) {\n                            cameraLocalTileZ--;\n                        }\n                        if (this.levelTileFlags && (this.levelTileFlags[this.currentLevel][cameraLocalTileX][cameraLocalTileZ] & 0x4) !== 0) {\n                            top = this.currentLevel;\n                        }\n                    }\n                }\n            }\n            else {\n                delta = ((tileDeltaX * 65536) / tileDeltaZ) | 0;\n                accumulator = 32768;\n                while (cameraLocalTileZ !== playerLocalTileZ) {\n                    if (cameraLocalTileZ < playerLocalTileZ) {\n                        cameraLocalTileZ++;\n                    }\n                    else if (cameraLocalTileZ > playerLocalTileZ) {\n                        cameraLocalTileZ--;\n                    }\n                    if (this.levelTileFlags && (this.levelTileFlags[this.currentLevel][cameraLocalTileX][cameraLocalTileZ] & 0x4) !== 0) {\n                        top = this.currentLevel;\n                    }\n                    accumulator += delta;\n                    if (accumulator >= 65536) {\n                        accumulator -= 65536;\n                        if (cameraLocalTileX < playerLocalTileX) {\n                            cameraLocalTileX++;\n                        }\n                        else if (cameraLocalTileX > playerLocalTileX) {\n                            cameraLocalTileX--;\n                        }\n                        if (this.levelTileFlags && (this.levelTileFlags[this.currentLevel][cameraLocalTileX][cameraLocalTileZ] & 0x4) !== 0) {\n                            top = this.currentLevel;\n                        }\n                    }\n                }\n            }\n        }\n        if (this.localPlayer && this.levelTileFlags && (this.levelTileFlags[this.currentLevel][this.localPlayer.x >> 7][this.localPlayer.z >> 7] & 0x4) !== 0) {\n            top = this.currentLevel;\n        }\n        return top;\n    };\n    getTopLevelCutscene = () => {\n        if (!this.levelTileFlags) {\n            return 0; // custom\n        }\n        const y = this.getHeightmapY(this.currentLevel, this.cameraX, this.cameraZ);\n        return y - this.cameraY >= 800 || (this.levelTileFlags[this.currentLevel][this.cameraX >> 7][this.cameraZ >> 7] & 0x4) === 0 ? 3 : this.currentLevel;\n    };\n    getHeightmapY = (level, sceneX, sceneZ) => {\n        if (!this.levelHeightmap) {\n            return 0; // custom\n        }\n        const tileX = Math.min(sceneX >> 7, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1);\n        const tileZ = Math.min(sceneZ >> 7, _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE - 1);\n        let realLevel = level;\n        if (level < 3 && this.levelTileFlags && (this.levelTileFlags[1][tileX][tileZ] & 0x2) === 2) {\n            realLevel = level + 1;\n        }\n        const tileLocalX = sceneX & 0x7f;\n        const tileLocalZ = sceneZ & 0x7f;\n        const y00 = (this.levelHeightmap[realLevel][tileX][tileZ] * (128 - tileLocalX) + this.levelHeightmap[realLevel][tileX + 1][tileZ] * tileLocalX) >> 7;\n        const y11 = (this.levelHeightmap[realLevel][tileX][tileZ + 1] * (128 - tileLocalX) + this.levelHeightmap[realLevel][tileX + 1][tileZ + 1] * tileLocalX) >> 7;\n        return (y00 * (128 - tileLocalZ) + y11 * tileLocalZ) >> 7;\n    };\n    orbitCamera = (targetX, targetY, targetZ, yaw, pitch, distance) => {\n        const invPitch = (2048 - pitch) & 0x7ff;\n        const invYaw = (2048 - yaw) & 0x7ff;\n        let x = 0;\n        let z = 0;\n        let y = distance;\n        let sin;\n        let cos;\n        let tmp;\n        if (invPitch !== 0) {\n            sin = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].sin[invPitch];\n            cos = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].cos[invPitch];\n            tmp = (z * cos - distance * sin) >> 16;\n            y = (z * sin + distance * cos) >> 16;\n            z = tmp;\n        }\n        if (invYaw !== 0) {\n            sin = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].sin[invYaw];\n            cos = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].cos[invYaw];\n            tmp = (y * sin + x * cos) >> 16;\n            y = (y * cos - x * sin) >> 16;\n            x = tmp;\n        }\n        this.cameraX = targetX - x;\n        this.cameraY = targetY - z;\n        this.cameraZ = targetZ - y;\n        this.cameraPitch = pitch;\n        this.cameraYaw = yaw;\n    };\n    updateOrbitCamera = () => {\n        if (!this.localPlayer) {\n            return; // custom\n        }\n        const orbitX = this.localPlayer.x + this.cameraAnticheatOffsetX;\n        const orbitZ = this.localPlayer.z + this.cameraAnticheatOffsetZ;\n        if (this.orbitCameraX - orbitX < -500 || this.orbitCameraX - orbitX > 500 || this.orbitCameraZ - orbitZ < -500 || this.orbitCameraZ - orbitZ > 500) {\n            this.orbitCameraX = orbitX;\n            this.orbitCameraZ = orbitZ;\n        }\n        if (this.orbitCameraX !== orbitX) {\n            this.orbitCameraX += ((orbitX - this.orbitCameraX) / 16) | 0;\n        }\n        if (this.orbitCameraZ !== orbitZ) {\n            this.orbitCameraZ += ((orbitZ - this.orbitCameraZ) / 16) | 0;\n        }\n        if (this.actionKey[1] === 1) {\n            this.orbitCameraYawVelocity += ((-this.orbitCameraYawVelocity - 24) / 2) | 0;\n        }\n        else if (this.actionKey[2] === 1) {\n            this.orbitCameraYawVelocity += ((24 - this.orbitCameraYawVelocity) / 2) | 0;\n        }\n        else {\n            this.orbitCameraYawVelocity = (this.orbitCameraYawVelocity / 2) | 0;\n        }\n        if (this.actionKey[3] === 1) {\n            this.orbitCameraPitchVelocity += ((12 - this.orbitCameraPitchVelocity) / 2) | 0;\n        }\n        else if (this.actionKey[4] === 1) {\n            this.orbitCameraPitchVelocity += ((-this.orbitCameraPitchVelocity - 12) / 2) | 0;\n        }\n        else {\n            this.orbitCameraPitchVelocity = (this.orbitCameraPitchVelocity / 2) | 0;\n        }\n        this.orbitCameraYaw = ((this.orbitCameraYaw + this.orbitCameraYawVelocity / 2) | 0) & 0x7ff;\n        this.orbitCameraPitch += (this.orbitCameraPitchVelocity / 2) | 0;\n        if (this.orbitCameraPitch < 128) {\n            this.orbitCameraPitch = 128;\n        }\n        if (this.orbitCameraPitch > 383) {\n            this.orbitCameraPitch = 383;\n        }\n        const orbitTileX = this.orbitCameraX >> 7;\n        const orbitTileZ = this.orbitCameraZ >> 7;\n        const orbitY = this.getHeightmapY(this.currentLevel, this.orbitCameraX, this.orbitCameraZ);\n        let maxY = 0;\n        if (this.levelHeightmap) {\n            if (orbitTileX > 3 && orbitTileZ > 3 && orbitTileX < 100 && orbitTileZ < 100) {\n                for (let x = orbitTileX - 4; x <= orbitTileX + 4; x++) {\n                    for (let z = orbitTileZ - 4; z <= orbitTileZ + 4; z++) {\n                        let level = this.currentLevel;\n                        if (level < 3 && this.levelTileFlags && (this.levelTileFlags[1][x][z] & 0x2) === 2) {\n                            level++;\n                        }\n                        const y = orbitY - this.levelHeightmap[level][x][z];\n                        if (y > maxY) {\n                            maxY = y;\n                        }\n                    }\n                }\n            }\n        }\n        let clamp = maxY * 192;\n        if (clamp > 98048) {\n            clamp = 98048;\n        }\n        if (clamp < 32768) {\n            clamp = 32768;\n        }\n        if (clamp > this.cameraPitchClamp) {\n            this.cameraPitchClamp += ((clamp - this.cameraPitchClamp) / 24) | 0;\n        }\n        else if (clamp < this.cameraPitchClamp) {\n            this.cameraPitchClamp += ((clamp - this.cameraPitchClamp) / 80) | 0;\n        }\n    };\n    applyCutscene = () => {\n        let x = this.cutsceneSrcLocalTileX * 128 + 64;\n        let z = this.cutsceneSrcLocalTileZ * 128 + 64;\n        let y = this.getHeightmapY(this.currentLevel, this.cutsceneSrcLocalTileX, this.cutsceneSrcLocalTileZ) - this.cutsceneSrcHeight;\n        if (this.cameraX < x) {\n            this.cameraX += this.cutsceneMoveSpeed + ((((x - this.cameraX) * this.cutsceneMoveAcceleration) / 1000) | 0);\n            if (this.cameraX > x) {\n                this.cameraX = x;\n            }\n        }\n        if (this.cameraX > x) {\n            this.cameraX -= this.cutsceneMoveSpeed + ((((this.cameraX - x) * this.cutsceneMoveAcceleration) / 1000) | 0);\n            if (this.cameraX < x) {\n                this.cameraX = x;\n            }\n        }\n        if (this.cameraY < y) {\n            this.cameraY += this.cutsceneMoveSpeed + ((((y - this.cameraY) * this.cutsceneMoveAcceleration) / 1000) | 0);\n            if (this.cameraY > y) {\n                this.cameraY = y;\n            }\n        }\n        if (this.cameraY > y) {\n            this.cameraY -= this.cutsceneMoveSpeed + ((((this.cameraY - y) * this.cutsceneMoveAcceleration) / 1000) | 0);\n            if (this.cameraY < y) {\n                this.cameraY = y;\n            }\n        }\n        if (this.cameraZ < z) {\n            this.cameraZ += this.cutsceneMoveSpeed + ((((z - this.cameraZ) * this.cutsceneMoveAcceleration) / 1000) | 0);\n            if (this.cameraZ > z) {\n                this.cameraZ = z;\n            }\n        }\n        if (this.cameraZ > z) {\n            this.cameraZ -= this.cutsceneMoveSpeed + ((((this.cameraZ - z) * this.cutsceneMoveAcceleration) / 1000) | 0);\n            if (this.cameraZ < z) {\n                this.cameraZ = z;\n            }\n        }\n        x = this.cutsceneDstLocalTileX * 128 + 64;\n        z = this.cutsceneDstLocalTileZ * 128 + 64;\n        y = this.getHeightmapY(this.currentLevel, this.cutsceneDstLocalTileX, this.cutsceneDstLocalTileZ) - this.cutsceneDstHeight;\n        const deltaX = x - this.cameraX;\n        const deltaY = y - this.cameraY;\n        const deltaZ = z - this.cameraZ;\n        const distance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ) | 0;\n        let pitch = ((Math.atan2(deltaY, distance) * 325.949) | 0) & 0x7ff;\n        const yaw = ((Math.atan2(deltaX, deltaZ) * -325.949) | 0) & 0x7ff;\n        if (pitch < 128) {\n            pitch = 128;\n        }\n        if (pitch > 383) {\n            pitch = 383;\n        }\n        if (this.cameraPitch < pitch) {\n            this.cameraPitch += this.cutsceneRotateSpeed + ((((pitch - this.cameraPitch) * this.cutsceneRotateAcceleration) / 1000) | 0);\n            if (this.cameraPitch > pitch) {\n                this.cameraPitch = pitch;\n            }\n        }\n        if (this.cameraPitch > pitch) {\n            this.cameraPitch -= this.cutsceneRotateSpeed + ((((this.cameraPitch - pitch) * this.cutsceneRotateAcceleration) / 1000) | 0);\n            if (this.cameraPitch < pitch) {\n                this.cameraPitch = pitch;\n            }\n        }\n        let deltaYaw = yaw - this.cameraYaw;\n        if (deltaYaw > 1024) {\n            deltaYaw -= 2048;\n        }\n        if (deltaYaw < -1024) {\n            deltaYaw += 2048;\n        }\n        if (deltaYaw > 0) {\n            this.cameraYaw += this.cutsceneRotateSpeed + (((deltaYaw * this.cutsceneRotateAcceleration) / 1000) | 0);\n            this.cameraYaw &= 0x7ff;\n        }\n        if (deltaYaw < 0) {\n            this.cameraYaw -= this.cutsceneRotateSpeed + (((-deltaYaw * this.cutsceneRotateAcceleration) / 1000) | 0);\n            this.cameraYaw &= 0x7ff;\n        }\n        let tmp = yaw - this.cameraYaw;\n        if (tmp > 1024) {\n            tmp -= 2048;\n        }\n        if (tmp < -1024) {\n            tmp += 2048;\n        }\n        if ((tmp < 0 && deltaYaw > 0) || (tmp > 0 && deltaYaw < 0)) {\n            this.cameraYaw = yaw;\n        }\n    };\n    readZonePacket = (buf, opcode) => {\n        const pos = buf.g1;\n        let x = this.baseX + ((pos >> 4) & 0x7);\n        let z = this.baseZ + (pos & 0x7);\n        if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_ADD_CHANGE || opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_DEL) {\n            // LOC_ADD_CHANGE || LOC_DEL\n            const info = buf.g1;\n            const shape = info >> 2;\n            const angle = info & 0x3;\n            const layer = _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].of(shape).layer;\n            let id;\n            if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_DEL) {\n                id = -1;\n            }\n            else {\n                id = buf.g2;\n            }\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                let loc = null;\n                for (let next = this.spawnedLocations.head(); next; next = this.spawnedLocations.next()) {\n                    if (next.plane === this.currentLevel && next.x === x && next.z === z && next.layer === layer) {\n                        loc = next;\n                        break;\n                    }\n                }\n                if (!loc && this.scene) {\n                    let bitset = 0;\n                    let otherId = -1;\n                    let otherShape = 0;\n                    let otherAngle = 0;\n                    if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL) {\n                        bitset = this.scene.getWallBitset(this.currentLevel, x, z);\n                    }\n                    else if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL_DECOR) {\n                        bitset = this.scene.getWallDecorationBitset(this.currentLevel, z, x);\n                    }\n                    else if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND) {\n                        bitset = this.scene.getLocBitset(this.currentLevel, x, z);\n                    }\n                    else if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND_DECOR) {\n                        bitset = this.scene.getGroundDecorationBitset(this.currentLevel, x, z);\n                    }\n                    if (bitset !== 0) {\n                        const otherInfo = this.scene.getInfo(this.currentLevel, x, z, bitset);\n                        otherId = (bitset >> 14) & 0x7fff;\n                        otherShape = otherInfo & 0x1f;\n                        otherAngle = otherInfo >> 6;\n                    }\n                    loc = new _jagex2_dash3d_type_LocTemporary__WEBPACK_IMPORTED_MODULE_36__[\"default\"](this.currentLevel, layer, x, z, 0, _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].WEST, _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].WALL_STRAIGHT.id, otherId, otherAngle, otherShape);\n                    this.spawnedLocations.addTail(loc);\n                }\n                if (loc) {\n                    loc.locIndex = id;\n                    loc.shape = shape;\n                    loc.angle = angle;\n                }\n                this.addLoc(this.currentLevel, x, z, id, angle, shape, layer);\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_ANIM) {\n            // LOC_ANIM\n            const info = buf.g1;\n            const shape = info >> 2;\n            const layer = _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].of(shape).layer;\n            const id = buf.g2;\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && this.scene) {\n                let bitset = 0;\n                if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL) {\n                    bitset = this.scene.getWallBitset(this.currentLevel, x, z);\n                }\n                else if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].WALL_DECOR) {\n                    bitset = this.scene.getWallDecorationBitset(this.currentLevel, z, x);\n                }\n                else if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND) {\n                    bitset = this.scene.getLocBitset(this.currentLevel, x, z);\n                }\n                else if (layer === _jagex2_dash3d_LocLayer__WEBPACK_IMPORTED_MODULE_33__[\"default\"].GROUND_DECOR) {\n                    bitset = this.scene.getGroundDecorationBitset(this.currentLevel, x, z);\n                }\n                if (bitset !== 0) {\n                    const loc = new _jagex2_dash3d_entity_LocEntity__WEBPACK_IMPORTED_MODULE_43__[\"default\"]((bitset >> 14) & 0x7fff, this.currentLevel, layer, x, z, _jagex2_config_SeqType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[id], false);\n                    this.locList.addTail(loc);\n                }\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_ADD) {\n            // OBJ_ADD\n            const id = buf.g2;\n            const count = buf.g2;\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                const obj = new _jagex2_dash3d_entity_ObjStackEntity__WEBPACK_IMPORTED_MODULE_42__[\"default\"](id, count);\n                if (!this.levelObjStacks[this.currentLevel][x][z]) {\n                    this.levelObjStacks[this.currentLevel][x][z] = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_28__[\"default\"]();\n                }\n                this.levelObjStacks[this.currentLevel][x][z]?.addTail(obj);\n                this.sortObjStacks(x, z);\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_DEL) {\n            // OBJ_DEL\n            const id = buf.g2;\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                const list = this.levelObjStacks[this.currentLevel][x][z];\n                if (list) {\n                    for (let next = list.head(); next; next = list.next()) {\n                        if (next.index === (id & 0x7fff)) {\n                            next.unlink();\n                            break;\n                        }\n                    }\n                    if (!list.head()) {\n                        this.levelObjStacks[this.currentLevel][x][z] = null;\n                    }\n                    this.sortObjStacks(x, z);\n                }\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MAP_PROJANIM) {\n            // MAP_PROJANIM\n            let dx = x + buf.g1b;\n            let dz = z + buf.g1b;\n            const target = buf.g2b;\n            const spotanim = buf.g2;\n            const srcHeight = buf.g1;\n            const dstHeight = buf.g1;\n            const startDelay = buf.g2;\n            const endDelay = buf.g2;\n            const peak = buf.g1;\n            const arc = buf.g1;\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && dx >= 0 && dz >= 0 && dx < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && dz < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                x = x * 128 + 64;\n                z = z * 128 + 64;\n                dx = dx * 128 + 64;\n                dz = dz * 128 + 64;\n                const proj = new _jagex2_dash3d_entity_ProjectileEntity__WEBPACK_IMPORTED_MODULE_44__[\"default\"](spotanim, this.currentLevel, x, this.getHeightmapY(this.currentLevel, x, z) - srcHeight, z, startDelay + this.loopCycle, endDelay + this.loopCycle, peak, arc, target, dstHeight);\n                proj.updateVelocity(dx, this.getHeightmapY(this.currentLevel, dx, dz) - dstHeight, dz, startDelay + this.loopCycle);\n                this.projectiles.addTail(proj);\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].MAP_ANIM) {\n            // MAP_ANIM\n            const id = buf.g2;\n            const height = buf.g1;\n            const delay = buf.g2;\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                x = x * 128 + 64;\n                z = z * 128 + 64;\n                const spotanim = new _jagex2_dash3d_entity_SpotAnimEntity__WEBPACK_IMPORTED_MODULE_45__[\"default\"](id, this.currentLevel, x, z, this.getHeightmapY(this.currentLevel, x, z) - height, this.loopCycle, delay);\n                this.spotanims.addTail(spotanim);\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_REVEAL) {\n            // OBJ_REVEAL\n            const id = buf.g2;\n            const count = buf.g2;\n            const receiver = buf.g2;\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && receiver !== this.localPid) {\n                const obj = new _jagex2_dash3d_entity_ObjStackEntity__WEBPACK_IMPORTED_MODULE_42__[\"default\"](id, count);\n                if (!this.levelObjStacks[this.currentLevel][x][z]) {\n                    this.levelObjStacks[this.currentLevel][x][z] = new _jagex2_datastruct_LinkList__WEBPACK_IMPORTED_MODULE_28__[\"default\"]();\n                }\n                this.levelObjStacks[this.currentLevel][x][z]?.addTail(obj);\n                this.sortObjStacks(x, z);\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].LOC_MERGE) {\n            // LOC_MERGE\n            const info = buf.g1;\n            const shape = info >> 2;\n            const angle = info & 0x3;\n            const layer = _jagex2_dash3d_LocShape__WEBPACK_IMPORTED_MODULE_34__[\"default\"].of(shape).layer;\n            const id = buf.g2;\n            const start = buf.g2;\n            const end = buf.g2;\n            const pid = buf.g2;\n            let east = buf.g1b;\n            let south = buf.g1b;\n            let west = buf.g1b;\n            let north = buf.g1b;\n            let player;\n            if (pid === this.localPid) {\n                player = this.localPlayer;\n            }\n            else {\n                player = this.players[pid];\n            }\n            if (player && this.levelHeightmap) {\n                const loc1 = new _jagex2_dash3d_type_LocSpawned__WEBPACK_IMPORTED_MODULE_37__[\"default\"](this.currentLevel, layer, x, z, -1, angle, shape, start + this.loopCycle);\n                this.temporaryLocs.addTail(loc1);\n                const loc2 = new _jagex2_dash3d_type_LocSpawned__WEBPACK_IMPORTED_MODULE_37__[\"default\"](this.currentLevel, layer, x, z, id, angle, shape, end + this.loopCycle);\n                this.temporaryLocs.addTail(loc2);\n                const y0 = this.levelHeightmap[this.currentLevel][x][z];\n                const y1 = this.levelHeightmap[this.currentLevel][x + 1][z];\n                const y2 = this.levelHeightmap[this.currentLevel][x + 1][z + 1];\n                const y3 = this.levelHeightmap[this.currentLevel][x][z + 1];\n                const loc = _jagex2_config_LocType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(id);\n                player.locStartCycle = start + this.loopCycle;\n                player.locStopCycle = end + this.loopCycle;\n                player.locModel = loc.getModel(shape, angle, y0, y1, y2, y3, -1);\n                let width = loc.width;\n                let height = loc.length;\n                if (angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].NORTH || angle === _jagex2_dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_35__[\"default\"].SOUTH) {\n                    width = loc.length;\n                    height = loc.width;\n                }\n                player.locOffsetX = x * 128 + width * 64;\n                player.locOffsetZ = z * 128 + height * 64;\n                player.locOffsetY = this.getHeightmapY(this.currentLevel, player.locOffsetX, player.locOffsetZ);\n                let tmp;\n                if (east > west) {\n                    tmp = east;\n                    east = west;\n                    west = tmp;\n                }\n                if (south > north) {\n                    tmp = south;\n                    south = north;\n                    north = tmp;\n                }\n                player.minTileX = x + east;\n                player.maxTileX = x + west;\n                player.minTileZ = z + south;\n                player.maxTileZ = z + north;\n            }\n        }\n        else if (opcode === _jagex2_io_ServerProt__WEBPACK_IMPORTED_MODULE_21__[\"default\"].OBJ_COUNT) {\n            // OBJ_COUNT\n            const id = buf.g2;\n            const oldCount = buf.g2;\n            const newCount = buf.g2;\n            if (x >= 0 && z >= 0 && x < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE && z < _jagex2_dash3d_CollisionMap__WEBPACK_IMPORTED_MODULE_38__[\"default\"].SIZE) {\n                const list = this.levelObjStacks[this.currentLevel][x][z];\n                if (list) {\n                    for (let next = list.head(); next; next = list.next()) {\n                        if (next.index === (id & 0x7fff) && next.count === oldCount) {\n                            next.count = newCount;\n                            break;\n                        }\n                    }\n                    this.sortObjStacks(x, z);\n                }\n            }\n        }\n    };\n    updateTextures = (cycle) => {\n        if (!_client__WEBPACK_IMPORTED_MODULE_49__.Client.lowMemory) {\n            if (_jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].textureCycle[17] >= cycle) {\n                const texture = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].textures[17];\n                if (!texture) {\n                    return;\n                }\n                const bottom = texture.width * texture.height - 1;\n                const adjustment = texture.width * this.sceneDelta * 2;\n                const src = texture.pixels;\n                const dst = this.textureBuffer;\n                for (let i = 0; i <= bottom; i++) {\n                    dst[i] = src[(i - adjustment) & bottom];\n                }\n                texture.pixels = dst;\n                this.textureBuffer = src;\n                _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].pushTexture(17);\n            }\n            if (_jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].textureCycle[24] >= cycle) {\n                const texture = _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].textures[24];\n                if (!texture) {\n                    return;\n                }\n                const bottom = texture.width * texture.height - 1;\n                const adjustment = texture.width * this.sceneDelta * 2;\n                const src = texture.pixels;\n                const dst = this.textureBuffer;\n                for (let i = 0; i <= bottom; i++) {\n                    dst[i] = src[(i - adjustment) & bottom];\n                }\n                texture.pixels = dst;\n                this.textureBuffer = src;\n                _jagex2_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_10__[\"default\"].pushTexture(24);\n            }\n        }\n    };\n    updateFlames = () => {\n        if (!this.flameBuffer3 || !this.flameBuffer2 || !this.flameBuffer0 || !this.flameLineOffset) {\n            return;\n        }\n        const height = 256;\n        for (let x = 10; x < 117; x++) {\n            const rand = (Math.random() * 100.0) | 0;\n            if (rand < 50)\n                this.flameBuffer3[x + ((height - 2) << 7)] = 255;\n        }\n        for (let l = 0; l < 100; l++) {\n            const x = ((Math.random() * 124.0) | 0) + 2;\n            const y = ((Math.random() * 128.0) | 0) + 128;\n            const index = x + (y << 7);\n            this.flameBuffer3[index] = 192;\n        }\n        for (let y = 1; y < height - 1; y++) {\n            for (let x = 1; x < 127; x++) {\n                const index = x + (y << 7);\n                this.flameBuffer2[index] = ((this.flameBuffer3[index - 1] + this.flameBuffer3[index + 1] + this.flameBuffer3[index - 128] + this.flameBuffer3[index + 128]) / 4) | 0;\n            }\n        }\n        this.flameCycle0 += 128;\n        if (this.flameCycle0 > this.flameBuffer0.length) {\n            this.flameCycle0 -= this.flameBuffer0.length;\n            this.updateFlameBuffer(this.imageRunes[(Math.random() * 12.0) | 0]);\n        }\n        for (let y = 1; y < height - 1; y++) {\n            for (let x = 1; x < 127; x++) {\n                const index = x + (y << 7);\n                let intensity = this.flameBuffer2[index + 128] - ((this.flameBuffer0[(index + this.flameCycle0) & (this.flameBuffer0.length - 1)] / 5) | 0);\n                if (intensity < 0) {\n                    intensity = 0;\n                }\n                this.flameBuffer3[index] = intensity;\n            }\n        }\n        for (let y = 0; y < height - 1; y++) {\n            this.flameLineOffset[y] = this.flameLineOffset[y + 1];\n        }\n        this.flameLineOffset[height - 1] = (Math.sin(this.loopCycle / 14.0) * 16.0 + Math.sin(this.loopCycle / 15.0) * 14.0 + Math.sin(this.loopCycle / 16.0) * 12.0) | 0;\n        if (this.flameGradientCycle0 > 0) {\n            this.flameGradientCycle0 -= 4;\n        }\n        if (this.flameGradientCycle1 > 0) {\n            this.flameGradientCycle1 -= 4;\n        }\n        if (this.flameGradientCycle0 === 0 && this.flameGradientCycle1 === 0) {\n            const rand = (Math.random() * 2000.0) | 0;\n            if (rand === 0) {\n                this.flameGradientCycle0 = 1024;\n            }\n            else if (rand === 1) {\n                this.flameGradientCycle1 = 1024;\n            }\n        }\n    };\n    mix = (src, alpha, dst) => {\n        const invAlpha = 256 - alpha;\n        return ((((src & 0xff00ff) * invAlpha + (dst & 0xff00ff) * alpha) & 0xff00ff00) + (((src & 0xff00) * invAlpha + (dst & 0xff00) * alpha) & 0xff0000)) >> 8;\n    };\n    drawFlames = () => {\n        if (!this.flameGradient || !this.flameGradient0 || !this.flameGradient1 || !this.flameGradient2 || !this.flameLineOffset || !this.flameBuffer3) {\n            return;\n        }\n        const height = 256;\n        // just colors\n        if (this.flameGradientCycle0 > 0) {\n            for (let i = 0; i < 256; i++) {\n                if (this.flameGradientCycle0 > 768) {\n                    this.flameGradient[i] = this.mix(this.flameGradient0[i], 1024 - this.flameGradientCycle0, this.flameGradient1[i]);\n                }\n                else if (this.flameGradientCycle0 > 256) {\n                    this.flameGradient[i] = this.flameGradient1[i];\n                }\n                else {\n                    this.flameGradient[i] = this.mix(this.flameGradient1[i], 256 - this.flameGradientCycle0, this.flameGradient0[i]);\n                }\n            }\n        }\n        else if (this.flameGradientCycle1 > 0) {\n            for (let i = 0; i < 256; i++) {\n                if (this.flameGradientCycle1 > 768) {\n                    this.flameGradient[i] = this.mix(this.flameGradient0[i], 1024 - this.flameGradientCycle1, this.flameGradient2[i]);\n                }\n                else if (this.flameGradientCycle1 > 256) {\n                    this.flameGradient[i] = this.flameGradient2[i];\n                }\n                else {\n                    this.flameGradient[i] = this.mix(this.flameGradient2[i], 256 - this.flameGradientCycle1, this.flameGradient0[i]);\n                }\n            }\n        }\n        else {\n            for (let i = 0; i < 256; i++) {\n                this.flameGradient[i] = this.flameGradient0[i];\n            }\n        }\n        for (let i = 0; i < 33920; i++) {\n            if (this.imageTitle0 && this.imageFlamesLeft)\n                this.imageTitle0.pixels[i] = this.imageFlamesLeft.pixels[i];\n        }\n        let srcOffset = 0;\n        let dstOffset = 1152;\n        for (let y = 1; y < height - 1; y++) {\n            const offset = ((this.flameLineOffset[y] * (height - y)) / height) | 0;\n            let step = offset + 22;\n            if (step < 0) {\n                step = 0;\n            }\n            srcOffset += step;\n            for (let x = step; x < 128; x++) {\n                let value = this.flameBuffer3[srcOffset++];\n                if (value === 0) {\n                    dstOffset++;\n                }\n                else {\n                    const alpha = value;\n                    const invAlpha = 256 - value;\n                    value = this.flameGradient[value];\n                    if (this.imageTitle0) {\n                        const background = this.imageTitle0.pixels[dstOffset];\n                        this.imageTitle0.pixels[dstOffset++] = ((((value & 0xff00ff) * alpha + (background & 0xff00ff) * invAlpha) & 0xff00ff00) + (((value & 0xff00) * alpha + (background & 0xff00) * invAlpha) & 0xff0000)) >> 8;\n                    }\n                }\n            }\n            dstOffset += step;\n        }\n        this.imageTitle0?.draw(0, 0);\n        for (let i = 0; i < 33920; i++) {\n            if (this.imageTitle1 && this.imageFlamesRight) {\n                this.imageTitle1.pixels[i] = this.imageFlamesRight.pixels[i];\n            }\n        }\n        srcOffset = 0;\n        dstOffset = 1176;\n        for (let y = 1; y < height - 1; y++) {\n            const offset = ((this.flameLineOffset[y] * (height - y)) / height) | 0;\n            const step = 103 - offset;\n            dstOffset += offset;\n            for (let x = 0; x < step; x++) {\n                let value = this.flameBuffer3[srcOffset++];\n                if (value === 0) {\n                    dstOffset++;\n                }\n                else {\n                    const alpha = value;\n                    const invAlpha = 256 - value;\n                    value = this.flameGradient[value];\n                    if (this.imageTitle1) {\n                        const background = this.imageTitle1.pixels[dstOffset];\n                        this.imageTitle1.pixels[dstOffset++] = ((((value & 0xff00ff) * alpha + (background & 0xff00ff) * invAlpha) & 0xff00ff00) + (((value & 0xff00) * alpha + (background & 0xff00) * invAlpha) & 0xff0000)) >> 8;\n                    }\n                }\n            }\n            srcOffset += 128 - step;\n            dstOffset += 128 - step - offset;\n        }\n        this.imageTitle1?.draw(661, 0);\n    };\n}\nconsole.log(`RS2 user client - release #${_client__WEBPACK_IMPORTED_MODULE_49__.Client.clientversion}`);\nawait (0,_configuration__WEBPACK_IMPORTED_MODULE_53__.setupConfiguration)();\nnew Game().run().then(() => { });\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://2004scape-client/./src/js/game.ts?");

/***/ }),

/***/ "./src/js/jagex2/client/GameShell.ts":
/*!*******************************************!*\
  !*** ./src/js/jagex2/client/GameShell.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GameShell)\n/* harmony export */ });\n/* harmony import */ var _graphics_PixMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/PixMap */ \"./src/js/jagex2/graphics/PixMap.ts\");\n/* harmony import */ var _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graphics/Draw3D */ \"./src/js/jagex2/graphics/Draw3D.ts\");\n/* harmony import */ var _util_JsUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/JsUtil */ \"./src/js/jagex2/util/JsUtil.ts\");\n/* harmony import */ var _KeyCodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KeyCodes */ \"./src/js/jagex2/client/KeyCodes.ts\");\n/* harmony import */ var _InputTracking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./InputTracking */ \"./src/js/jagex2/client/InputTracking.ts\");\n/* harmony import */ var _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../graphics/Canvas */ \"./src/js/jagex2/graphics/Canvas.ts\");\n\n\n\n\n\n\nclass GameShell {\n    static getParameter(name) {\n        const urlParams = new URLSearchParams(window.location.search);\n        return urlParams.get(name) ?? '';\n    }\n    static setParameter(name, value) {\n        const url = new URL(window.location.toString());\n        url.searchParams.set(name, value);\n        window.history.pushState(null, '', url.toString());\n    }\n    slowestMS = 0.0; // custom\n    averageMS = []; // custom\n    averageIndexMS = 0; // custom\n    drawArea = null;\n    state = 0;\n    deltime = 20;\n    mindel = 1;\n    otim = [];\n    fps = 0;\n    fpos = 0;\n    frameTime = [];\n    redrawScreen = true;\n    resizeToFit = false;\n    tfps = 50; // custom\n    hasFocus = true; // mapview applet\n    ingame = false;\n    idleCycles = 0;\n    mouseButton = 0;\n    mouseX = 0;\n    mouseY = 0;\n    mouseClickButton = 0;\n    mouseClickX = 0;\n    mouseClickY = 0;\n    actionKey = [];\n    keyQueue = [];\n    keyQueueReadPos = 0;\n    keyQueueWritePos = 0;\n    // touch controls\n    input = null;\n    touching = false;\n    startedInViewport = false;\n    startedInTabArea = false;\n    time = -1;\n    sx = 0;\n    sy = 0;\n    mx = 0;\n    my = 0;\n    nx = 0;\n    ny = 0;\n    constructor(resizetoFit = false) {\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.tabIndex = -1;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillStyle = 'black';\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillRect(0, 0, _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.width, _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.height);\n        this.resizeToFit = resizetoFit;\n        if (this.resizeToFit) {\n            this.resize(window.innerWidth, window.innerHeight);\n        }\n        else {\n            this.resize(_graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.width, _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.height);\n        }\n    }\n    get width() {\n        return _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.width;\n    }\n    get height() {\n        return _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.height;\n    }\n    resize = (width, height) => {\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.width = width;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.height = height;\n        this.drawArea = new _graphics_PixMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"](width, height);\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].init2D();\n    };\n    run = async () => {\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.addEventListener('resize', () => {\n            if (this.resizeToFit) {\n                this.resize(window.innerWidth, window.innerHeight);\n            }\n        }, false);\n        // pc\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onmousedown = this.onmousedown;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onmouseup = this.onmouseup;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onmouseenter = this.onmouseenter;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onmouseleave = this.onmouseleave;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onmousemove = this.onmousemove;\n        window.onbeforeunload = this.unload;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onfocus = this.onfocus;\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onblur = this.onblur;\n        if (this.isMobile) {\n            _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.ontouchstart = this.ontouchstart;\n            _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.ontouchend = this.ontouchend;\n            _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.ontouchmove = this.ontouchmove;\n        }\n        else {\n            _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onkeydown = this.onkeydown;\n            _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.onkeyup = this.onkeyup;\n        }\n        // Preventing mouse events from bubbling up to the context menu in the browser for our canvas.\n        // This may need to be hooked up to our own context menu in the future.\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.oncontextmenu = (e) => {\n            e.preventDefault();\n        };\n        window.oncontextmenu = (e) => {\n            e.preventDefault();\n        };\n        // force set mobile on low detail mode to 30 fps as default.\n        if (this.isMobile && GameShell.getParameter('detail') === 'low') {\n            this.tfps = 30;\n        }\n        await this.showProgress(0, 'Loading...');\n        await this.load();\n        for (let i = 0; i < 10; i++) {\n            this.otim[i] = performance.now();\n        }\n        let ntime;\n        let opos = 0;\n        let ratio = 256;\n        let delta = 1;\n        let count = 0;\n        while (this.state >= 0) {\n            if (this.state > 0) {\n                this.state--;\n                if (this.state === 0) {\n                    this.shutdown();\n                    return;\n                }\n            }\n            const lastRatio = ratio;\n            const lastDelta = delta;\n            ratio = 300;\n            delta = 1;\n            ntime = performance.now();\n            const otim = this.otim[opos];\n            if (otim === 0) {\n                ratio = lastRatio;\n                delta = lastDelta;\n            }\n            else if (ntime > otim) {\n                ratio = ((this.deltime * 2560) / (ntime - otim)) | 0;\n            }\n            if (ratio < 25) {\n                ratio = 25;\n            }\n            else if (ratio > 256) {\n                ratio = 256;\n                delta = (this.deltime - (ntime - otim) / 10) | 0;\n            }\n            this.otim[opos] = ntime;\n            opos = (opos + 1) % 10;\n            if (delta > 1) {\n                for (let i = 0; i < 10; i++) {\n                    if (this.otim[i] !== 0) {\n                        this.otim[i] += delta;\n                    }\n                }\n            }\n            if (delta < this.mindel) {\n                delta = this.mindel;\n            }\n            await (0,_util_JsUtil__WEBPACK_IMPORTED_MODULE_2__.sleep)(delta);\n            while (count < 256) {\n                await this.update();\n                this.mouseClickButton = 0;\n                this.keyQueueReadPos = this.keyQueueWritePos;\n                count += ratio;\n            }\n            count &= 0xff;\n            if (this.deltime > 0) {\n                this.fps = ((ratio * 1000) / (this.deltime * 256)) | 0;\n            }\n            const time = performance.now();\n            if (this.redrawScreen) {\n                this.refresh();\n            }\n            await this.draw();\n            this.frameTime[this.fpos] = (performance.now() - time) / 1000;\n            this.fpos = (this.fpos + 1) % this.frameTime.length;\n            // this is custom for targeting specific fps (on mobile).\n            if (this.tfps < 50) {\n                const tfps = 1000 / this.tfps - (performance.now() - ntime);\n                if (tfps > 0) {\n                    await (0,_util_JsUtil__WEBPACK_IMPORTED_MODULE_2__.sleep)(tfps);\n                }\n            }\n        }\n        if (this.state === -1) {\n            this.shutdown();\n        }\n    };\n    shutdown = () => {\n        this.state = -2;\n        this.unload();\n    };\n    setFramerate = (rate) => {\n        this.deltime = (1000 / rate) | 0;\n    };\n    setTargetedFramerate = (rate) => {\n        this.tfps = Math.max(Math.min(50, rate | 0), 0);\n    };\n    start = () => {\n        if (this.state >= 0) {\n            this.state = 0;\n        }\n    };\n    stop = () => {\n        if (this.state >= 0) {\n            this.state = (4000 / this.deltime) | 0;\n        }\n    };\n    destroy = () => {\n        this.state = -1;\n    };\n    load = async () => { };\n    update = async () => { };\n    unload = () => { };\n    draw = async () => { };\n    refresh = () => { };\n    async showProgress(progress, message) {\n        const width = this.width;\n        const height = this.height;\n        if (this.redrawScreen) {\n            _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillStyle = 'black';\n            _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillRect(0, 0, width, height);\n            this.redrawScreen = false;\n        }\n        const y = height / 2 - 18;\n        // draw full progress bar\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillStyle = 'rgb(140, 17, 17)';\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.rect(((width / 2) | 0) - 152, y, 304, 34);\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillRect(((width / 2) | 0) - 150, y + 2, progress * 3, 30);\n        // cover up progress bar\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillStyle = 'black';\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillRect(((width / 2) | 0) - 150 + progress * 3, y + 2, 300 - progress * 3, 30);\n        // draw text\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.font = 'bold 13px helvetica, sans-serif';\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.textAlign = 'center';\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillStyle = 'white';\n        _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas2d.fillText(message, (width / 2) | 0, y + 22);\n        await (0,_util_JsUtil__WEBPACK_IMPORTED_MODULE_2__.sleep)(5); // return a slice of time to the main loop so it can update the progress bar\n    }\n    pollKey = () => {\n        let key = -1;\n        if (this.keyQueueWritePos !== this.keyQueueReadPos) {\n            key = this.keyQueue[this.keyQueueReadPos];\n            this.keyQueueReadPos = (this.keyQueueReadPos + 1) & 0x7f;\n        }\n        return key;\n    };\n    get ms() {\n        const length = this.frameTime.length;\n        let ft = 0;\n        for (let index = 0; index < length; index++) {\n            ft += this.frameTime[index];\n        }\n        const ms = (ft / length) * 1000;\n        if (ms > this.slowestMS) {\n            this.slowestMS = ms;\n        }\n        this.averageMS[this.averageIndexMS] = ms;\n        this.averageIndexMS = (this.averageIndexMS + 1) % 250; // 250 circular limit\n        return ms;\n    }\n    get msAvg() {\n        return this.averageMS.reduce((accumulator, currentValue) => accumulator + currentValue, 0) / 250; // 250 circular limit\n    }\n    // ----\n    onkeydown = (e) => {\n        const key = e.key;\n        if (_KeyCodes__WEBPACK_IMPORTED_MODULE_3__.CANVAS_PREVENTED.includes(key)) {\n            // prevent canvas from using tab and other blacklisted keys. no function in 225?\n            e.preventDefault();\n        }\n        this.idleCycles = 0;\n        const mappedKey = _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES[key];\n        if (!mappedKey || (e.code.length === 0 && !e.isTrusted)) {\n            console.warn(`Unhandled key: ${key}`);\n            return;\n        }\n        const code = mappedKey.code;\n        let ch = mappedKey.ch;\n        if (e.ctrlKey) {\n            if ((ch >= 'A'.charCodeAt(0) && ch <= ']'.charCodeAt(0)) || ch == '_'.charCodeAt(0)) {\n                ch -= 'A'.charCodeAt(0) - 1;\n            }\n            else if (ch >= 'a'.charCodeAt(0) && ch <= 'z'.charCodeAt(0)) {\n                ch -= 'a'.charCodeAt(0) - 1;\n            }\n        }\n        if (ch < 30) {\n            ch = 0;\n        }\n        if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowLeft'].code) {\n            ch = 1;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowRight'].code) {\n            ch = 2;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowUp'].code) {\n            ch = 3;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowDown'].code) {\n            ch = 4;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Control'].code) {\n            ch = 5;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Shift'].code) {\n            ch = 6; // (custom)\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Alt'].code) {\n            ch = 7; // (custom)\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Backspace'].code) {\n            ch = 8;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Delete'].code) {\n            ch = 8;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Tab'].code) {\n            ch = 9;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Enter'].code) {\n            ch = 10;\n        }\n        else if (code >= _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['F1'].code && code <= _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['F12'].code) {\n            ch = code + 1008 - _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['F1'].code;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Home'].code) {\n            ch = 1000;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['End'].code) {\n            ch = 1001;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['PageUp'].code) {\n            ch = 1002;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['PageDown'].code) {\n            ch = 1003;\n        }\n        if (ch > 0 && ch < 128) {\n            this.actionKey[ch] = 1;\n        }\n        if (ch > 4) {\n            this.keyQueue[this.keyQueueWritePos] = ch;\n            this.keyQueueWritePos = (this.keyQueueWritePos + 1) & 0x7f;\n        }\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].keyPressed(ch);\n        }\n    };\n    onkeyup = (e) => {\n        const key = e.key;\n        if (_KeyCodes__WEBPACK_IMPORTED_MODULE_3__.CANVAS_PREVENTED.includes(key)) {\n            // prevent canvas from using tab and other blacklisted keys. no function in 225?\n            e.preventDefault();\n        }\n        this.idleCycles = 0;\n        const mappedKey = _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES[key];\n        if (!mappedKey || (e.code.length === 0 && !e.isTrusted)) {\n            console.warn(`Unhandled key: ${key}`);\n            return;\n        }\n        const code = mappedKey.code;\n        let ch = mappedKey.ch;\n        if (ch < 30) {\n            ch = 0;\n        }\n        if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowLeft'].code) {\n            ch = 1;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowRight'].code) {\n            ch = 2;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowUp'].code) {\n            ch = 3;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['ArrowDown'].code) {\n            ch = 4;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Control'].code) {\n            ch = 5;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Shift'].code) {\n            ch = 6; // (custom)\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Alt'].code) {\n            ch = 7; // (custom)\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Backspace'].code) {\n            ch = 8;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Delete'].code) {\n            ch = 8;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Tab'].code) {\n            ch = 9;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Enter'].code) {\n            ch = 10;\n        }\n        else if (code >= _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['F1'].code && code <= _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['F12'].code) {\n            ch = code + 1008 - _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['F1'].code;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['Home'].code) {\n            ch = 1000;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['End'].code) {\n            ch = 1001;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['PageUp'].code) {\n            ch = 1002;\n        }\n        else if (code === _KeyCodes__WEBPACK_IMPORTED_MODULE_3__.KEY_CODES['PageDown'].code) {\n            ch = 1003;\n        }\n        if (ch > 0 && ch < 128) {\n            this.actionKey[ch] = 0;\n        }\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].keyReleased(ch);\n        }\n    };\n    onmousedown = (e) => {\n        this.touching = false;\n        //Don't 'reset' position (This fixes right click in Android)\n        if (e.clientX > 0 || e.clientY > 0)\n            this.setMousePosition(e);\n        this.idleCycles = 0;\n        this.mouseClickX = this.mouseX;\n        this.mouseClickY = this.mouseY;\n        if (this.isMobile && !this.isCapacitor) {\n            if (this.insideChatInputArea() || this.insideUsernameArea() || this.inPasswordArea()) {\n                this.mouseClickButton = 1;\n                this.mouseButton = 1;\n                return;\n            }\n            const eventTime = e.timeStamp;\n            if (eventTime >= this.time + 500) {\n                this.mouseClickButton = 2;\n                this.mouseButton = 2;\n            }\n            else {\n                this.mouseClickButton = 1;\n                this.mouseButton = 1;\n            }\n        }\n        else {\n            if (e.button === 2) {\n                this.mouseClickButton = 2;\n                this.mouseButton = 2;\n            }\n            else {\n                this.mouseClickButton = 1;\n                this.mouseButton = 1;\n            }\n        }\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].mousePressed(this.mouseClickX, this.mouseClickY, e.buttons);\n        }\n    };\n    onmouseup = (e) => {\n        this.setMousePosition(e);\n        this.idleCycles = 0;\n        this.mouseButton = 0;\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].mouseReleased(e.buttons);\n        }\n    };\n    onmouseenter = (e) => {\n        this.setMousePosition(e);\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].mouseEntered();\n        }\n    };\n    onmouseleave = (e) => {\n        this.setMousePosition(e);\n        // mapview applet\n        this.idleCycles = 0;\n        this.mouseX = -1;\n        this.mouseY = -1;\n        // custom (prevent mouse click from being stuck)\n        this.mouseButton = 0;\n        this.mouseClickX = -1;\n        this.mouseClickY = -1;\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].mouseExited();\n        }\n    };\n    onmousemove = (e) => {\n        this.setMousePosition(e);\n        this.idleCycles = 0;\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].mouseMoved(this.mouseX, this.mouseY);\n        }\n    };\n    onfocus = (e) => {\n        this.hasFocus = true; // mapview applet\n        this.redrawScreen = true;\n        this.refresh();\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].focusGained();\n        }\n    };\n    onblur = (e) => {\n        this.hasFocus = false; // mapview applet\n        if (_InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].enabled) {\n            _InputTracking__WEBPACK_IMPORTED_MODULE_4__[\"default\"].focusLost();\n        }\n    };\n    ontouchstart = (e) => {\n        if (!this.isMobile) {\n            return;\n        }\n        if (this.input !== null) {\n            this.input.parentNode?.removeChild(this.input);\n            this.input = null;\n        }\n        this.touching = true;\n        const touch = e.changedTouches[0];\n        const clientX = touch.clientX | 0;\n        const clientY = touch.clientY | 0;\n        this.onmousemove(new MouseEvent('mousemove', { clientX: clientX, clientY: clientY }));\n        this.sx = this.nx = this.mx = touch.screenX | 0;\n        this.sy = this.ny = this.my = touch.screenY | 0;\n        this.time = e.timeStamp;\n        this.startedInViewport = this.insideViewportArea();\n        this.startedInTabArea = this.insideTabArea();\n    };\n    ontouchend = (e) => {\n        if (!this.isMobile || !this.touching) {\n            return;\n        }\n        const touch = e.changedTouches[0];\n        const clientX = touch.clientX | 0;\n        const clientY = touch.clientY | 0;\n        this.onmousemove(new MouseEvent('mousemove', { clientX: clientX, clientY: clientY }));\n        this.nx = touch.screenX | 0;\n        this.ny = touch.screenY | 0;\n        this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowLeft', code: 'ArrowLeft' }));\n        this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowUp', code: 'ArrowUp' }));\n        this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowRight', code: 'ArrowRight' }));\n        this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowDown', code: 'ArrowDown' }));\n        if (this.startedInViewport && !this.insideViewportArea()) {\n            this.touching = false;\n            return;\n        }\n        else if (this.startedInTabArea && !this.insideTabArea()) {\n            this.touching = false;\n            return;\n        }\n        else if (this.insideChatInputArea() || this.insideChatPopupArea() || this.insideUsernameArea() || this.inPasswordArea()) {\n            if (this.input !== null) {\n                if (this.input.parentNode?.contains(this.input)) {\n                    this.input.parentNode?.removeChild(this.input);\n                }\n                this.input = null;\n            }\n            const input = document.createElement('input');\n            if (this.insideUsernameArea()) {\n                input.setAttribute('id', 'username');\n                input.setAttribute('placeholder', 'Username');\n            }\n            else if (this.inPasswordArea()) {\n                input.setAttribute('id', 'password');\n                input.setAttribute('placeholder', 'Password');\n            }\n            else if (this.insideChatInputArea()) {\n                input.setAttribute('id', 'chatinput');\n                input.setAttribute('placeholder', 'Chatinput');\n            }\n            else if (this.insideChatPopupArea()) {\n                input.setAttribute('id', 'chatpopup');\n                input.setAttribute('placeholder', 'Chatpopup');\n            }\n            if (this.isAndroid) {\n                // this forces android to not use compose text for oninput. its good enough.\n                input.setAttribute('type', 'password');\n            }\n            else {\n                input.setAttribute('type', this.inPasswordArea() ? 'password' : 'text');\n            }\n            input.setAttribute('autofocus', 'autofocus');\n            input.setAttribute('spellcheck', 'false');\n            input.setAttribute('autocomplete', 'off');\n            input.setAttribute('style', `position: fixed; left: ${clientX}px; top: ${clientY}px; width: 1px; height: 1px; opacity: 0;`);\n            document.body.appendChild(input);\n            input.focus();\n            input.click();\n            if (this.isAndroid) {\n                input.oninput = (e) => {\n                    if (!(e instanceof InputEvent)) {\n                        return;\n                    }\n                    const input = e;\n                    const data = input.data;\n                    if (data === null) {\n                        return;\n                    }\n                    if (input.inputType !== 'insertText') {\n                        return;\n                    }\n                    this.onkeydown(new KeyboardEvent('keydown', { key: data, code: data }));\n                };\n            }\n            input.onkeydown = (e) => {\n                if (this.isAndroid) {\n                    if (e.key === 'Enter' || e.key === 'Backspace') {\n                        this.onkeydown(new KeyboardEvent('keydown', { key: e.key, code: e.key }));\n                    }\n                    return;\n                }\n                this.onkeydown(new KeyboardEvent('keydown', { key: e.key, code: e.key }));\n            };\n            input.onkeyup = (e) => {\n                if (this.isAndroid) {\n                    if (e.key === 'Enter' || e.key === 'Backspace') {\n                        this.onkeyup(new KeyboardEvent('keyup', { key: e.key, code: e.key }));\n                    }\n                    return;\n                }\n                this.onkeyup(new KeyboardEvent('keyup', { key: e.key, code: e.key }));\n            };\n            input.onfocus = (e) => {\n                this.input?.parentNode?.removeChild(this.input);\n                this.input = null;\n                this.onfocus(e);\n            };\n            this.input = input;\n            this.touching = false;\n            return;\n        }\n        const eventTime = e.timeStamp;\n        const longPress = eventTime >= this.time + 500;\n        const moved = Math.abs(this.sx - this.nx) > 16 || Math.abs(this.sy - this.ny) > 16;\n        if (longPress && !moved) {\n            this.touching = true;\n            this.onmousedown(new MouseEvent('mousedown', { buttons: 2 }));\n        }\n        else {\n            this.mouseButton = 0;\n            this.touching = false;\n        }\n    };\n    ontouchmove = (e) => {\n        if (!this.isMobile || !this.touching) {\n            return;\n        }\n        const touch = e.changedTouches[0];\n        const clientX = touch.clientX | 0;\n        const clientY = touch.clientY | 0;\n        this.onmousemove(new MouseEvent('mousemove', { clientX: clientX, clientY: clientY }));\n        this.nx = touch.screenX | 0;\n        this.ny = touch.screenY | 0;\n        if (this.startedInViewport && this.getViewportInterfaceId() === -1) {\n            // Camera panning\n            if (this.mx - this.nx > 0) {\n                this.rotate(2);\n            }\n            else if (this.mx - this.nx < 0) {\n                this.rotate(0);\n            }\n            if (this.my - this.ny > 0) {\n                this.rotate(3);\n            }\n            else if (this.my - this.ny < 0) {\n                this.rotate(1);\n            }\n        }\n        else if (this.startedInTabArea || this.getViewportInterfaceId() !== -1) {\n            // Drag and drop\n            this.onmousedown(new MouseEvent('mousedown', { buttons: 1 }));\n        }\n        this.mx = this.nx;\n        this.my = this.ny;\n    };\n    get isMobile() {\n        const keywords = ['Android', 'webOS', 'iPhone', 'iPad', 'iPod', 'BlackBerry', 'Windows Phone'];\n        return keywords.some((keyword) => navigator.userAgent.includes(keyword));\n    }\n    get isAndroid() {\n        const keywords = ['Android'];\n        return keywords.some((keyword) => navigator.userAgent.includes(keyword));\n    }\n    get isCapacitor() {\n        const keywords = ['Capacitor'];\n        return keywords.some((keyword) => navigator.userAgent.includes(keyword));\n    }\n    insideViewportArea = () => {\n        // 512 x 334\n        const viewportAreaX1 = 8;\n        const viewportAreaY1 = 11;\n        const viewportAreaX2 = viewportAreaX1 + 512;\n        const viewportAreaY2 = viewportAreaY1 + 334;\n        return this.ingame && this.mouseX >= viewportAreaX1 && this.mouseX <= viewportAreaX2 && this.mouseY >= viewportAreaY1 && this.mouseY <= viewportAreaY2;\n    };\n    insideChatInputArea = () => {\n        // 495 x 33\n        const chatInputAreaX1 = 11;\n        const chatInputAreaY1 = 449;\n        const chatInputAreaX2 = chatInputAreaX1 + 495;\n        const chatInputAreaY2 = chatInputAreaY1 + 33;\n        return (this.ingame &&\n            this.getChatInterfaceId() === -1 &&\n            !this.isChatBackInputOpen() &&\n            !this.isShowSocialInput() &&\n            this.mouseX >= chatInputAreaX1 &&\n            this.mouseX <= chatInputAreaX2 &&\n            this.mouseY >= chatInputAreaY1 &&\n            this.mouseY <= chatInputAreaY2);\n    };\n    insideChatPopupArea = () => {\n        // 495 x 99\n        const chatInputAreaX1 = 11;\n        const chatInputAreaY1 = 383;\n        const chatInputAreaX2 = chatInputAreaX1 + 495;\n        const chatInputAreaY2 = chatInputAreaY1 + 99;\n        return this.ingame && (this.isChatBackInputOpen() || this.isShowSocialInput()) && this.mouseX >= chatInputAreaX1 && this.mouseX <= chatInputAreaX2 && this.mouseY >= chatInputAreaY1 && this.mouseY <= chatInputAreaY2;\n    };\n    insideTabArea = () => {\n        // 190 x 261\n        const tabAreaX1 = 562;\n        const tabAreaY1 = 231;\n        const tabAreaX2 = tabAreaX1 + 190;\n        const tabAreaY2 = tabAreaY1 + 261;\n        return this.ingame && this.mouseX >= tabAreaX1 && this.mouseX <= tabAreaX2 && this.mouseY >= tabAreaY1 && this.mouseY <= tabAreaY2;\n    };\n    insideUsernameArea = () => {\n        // 261 x 17\n        const usernameAreaX1 = 301;\n        const usernameAreaY1 = 262;\n        const usernameAreaX2 = usernameAreaX1 + 261;\n        const usernameAreaY2 = usernameAreaY1 + 17;\n        return !this.ingame && this.getTitleScreenState() === 2 && this.mouseX >= usernameAreaX1 && this.mouseX <= usernameAreaX2 && this.mouseY >= usernameAreaY1 && this.mouseY <= usernameAreaY2;\n    };\n    inPasswordArea = () => {\n        // 261 x 17\n        const passwordAreaX1 = 301;\n        const passwordAreaY1 = 279;\n        const passwordAreaX2 = passwordAreaX1 + 261;\n        const passwordAreaY2 = passwordAreaY1 + 17;\n        return !this.ingame && this.getTitleScreenState() === 2 && this.mouseX >= passwordAreaX1 && this.mouseX <= passwordAreaX2 && this.mouseY >= passwordAreaY1 && this.mouseY <= passwordAreaY2;\n    };\n    rotate = (direction) => {\n        if (direction === 0) {\n            this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowRight', code: 'ArrowRight' }));\n            this.onkeydown(new KeyboardEvent('keydown', { key: 'ArrowLeft', code: 'ArrowLeft' }));\n        }\n        else if (direction === 1) {\n            this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowDown', code: 'ArrowDown' }));\n            this.onkeydown(new KeyboardEvent('keydown', { key: 'ArrowUp', code: 'ArrowUp' }));\n        }\n        else if (direction === 2) {\n            this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowLeft', code: 'ArrowLeft' }));\n            this.onkeydown(new KeyboardEvent('keydown', { key: 'ArrowRight', code: 'ArrowRight' }));\n        }\n        else if (direction === 3) {\n            this.onkeyup(new KeyboardEvent('keyup', { key: 'ArrowUp', code: 'ArrowUp' }));\n            this.onkeydown(new KeyboardEvent('keydown', { key: 'ArrowDown', code: 'ArrowDown' }));\n        }\n    };\n    isFullScreen = () => {\n        return document.fullscreenElement !== null;\n    };\n    setMousePosition = (e) => {\n        const fixedWidth = 789;\n        const fixedHeight = 532;\n        if (this.isFullScreen()) {\n            const element = e.target;\n            const br = element.getBoundingClientRect();\n            const ratio = window.innerHeight / _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.height;\n            const offset = (window.innerWidth - _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.width * ratio) / 2.0;\n            this.mouseX = this.mapCoord(e.clientX - br.left - offset, 0, _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.width * ratio, 0, fixedWidth) | 0;\n            this.mouseY = this.mapCoord(e.clientY - br.top, 0, _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.height * ratio, 0, fixedHeight) | 0;\n        }\n        else {\n            const rect = _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.getBoundingClientRect();\n            const scaleX = _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.width / rect.width;\n            const scaleY = _graphics_Canvas__WEBPACK_IMPORTED_MODULE_5__.canvas.height / rect.height;\n            this.mouseX = ((e.clientX - rect.left) * scaleX) | 0;\n            this.mouseY = ((e.clientY - rect.top) * scaleY) | 0;\n        }\n        if (this.mouseX < 0) {\n            this.mouseX = 0;\n        }\n        if (this.mouseY < 0) {\n            this.mouseY = 0;\n        }\n        if (this.mouseX > fixedWidth) {\n            this.mouseX = fixedWidth;\n        }\n        if (this.mouseY > fixedHeight) {\n            this.mouseY = fixedHeight;\n        }\n    };\n    mapCoord = (v, n1, n2, m1, m2) => {\n        return ((v - n1) * (m2 - m1)) / (n2 - n1) + m1;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/client/GameShell.ts?");

/***/ }),

/***/ "./src/js/jagex2/client/InputTracking.ts":
/*!***********************************************!*\
  !*** ./src/js/jagex2/client/InputTracking.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InputTracking)\n/* harmony export */ });\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n\nclass InputTracking {\n    static enabled = false;\n    static outBuffer = null;\n    static oldBuffer = null;\n    static lastTime = 0;\n    static trackedCount = 0;\n    static lastMoveTime = 0;\n    static lastX = 0;\n    static lastY = 0;\n    static setEnabled = () => {\n        this.outBuffer = _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"].alloc(1);\n        this.oldBuffer = null;\n        this.lastTime = performance.now();\n        this.enabled = true;\n    };\n    static setDisabled = () => {\n        this.enabled = false;\n        this.outBuffer = null;\n    };\n    static flush = () => {\n        let buffer = null;\n        if (this.oldBuffer && this.enabled) {\n            buffer = this.oldBuffer;\n        }\n        this.oldBuffer = null;\n        return buffer;\n    };\n    static stop = () => {\n        let buffer = null;\n        if (this.outBuffer && this.outBuffer.pos > 0 && this.enabled) {\n            buffer = this.outBuffer;\n        }\n        this.setDisabled();\n        return buffer;\n    };\n    static mousePressed = (x, y, button) => {\n        if (!(this.enabled && x >= 0 && x < 789 && y >= 0 && y < 532)) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        this.ensureCapacity(5);\n        if (button === 1) {\n            this.outBuffer?.p1(1);\n        }\n        else {\n            this.outBuffer?.p1(2);\n        }\n        this.outBuffer?.p1(delta);\n        this.outBuffer?.p3(x + (y << 10));\n    };\n    static mouseReleased = (button) => {\n        if (!this.enabled) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        this.ensureCapacity(2);\n        if (button === 1) {\n            this.outBuffer?.p1(3);\n        }\n        else {\n            this.outBuffer?.p1(4);\n        }\n        this.outBuffer?.p1(delta);\n    };\n    static mouseMoved = (x, y) => {\n        if (!(this.enabled && x >= 0 && x < 789 && y >= 0 && y < 532)) {\n            return;\n        }\n        const now = performance.now();\n        if (now - this.lastMoveTime >= 50) {\n            this.lastMoveTime = now;\n            this.trackedCount++;\n            let delta = ((now - this.lastTime) / 10) | 0;\n            if (delta > 250) {\n                delta = 250;\n            }\n            this.lastTime = now;\n            if (x - this.lastX < 8 && x - this.lastX >= -8 && y - this.lastY < 8 && y - this.lastY >= -8) {\n                this.ensureCapacity(3);\n                this.outBuffer?.p1(5);\n                this.outBuffer?.p1(delta);\n                this.outBuffer?.p1(x + ((y - this.lastY + 8) << 4) + 8 - this.lastX);\n            }\n            else if (x - this.lastX < 128 && x - this.lastX >= -128 && y - this.lastY < 128 && y - this.lastY >= -128) {\n                this.ensureCapacity(4);\n                this.outBuffer?.p1(6);\n                this.outBuffer?.p1(delta);\n                this.outBuffer?.p1(x + 128 - this.lastX);\n                this.outBuffer?.p1(y + 128 - this.lastY);\n            }\n            else {\n                this.ensureCapacity(5);\n                this.outBuffer?.p1(7);\n                this.outBuffer?.p1(delta);\n                this.outBuffer?.p3(x + (y << 10));\n            }\n            this.lastX = x;\n            this.lastY = y;\n        }\n    };\n    static keyPressed = (key) => {\n        if (!this.enabled) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        if (key === 1000) {\n            key = 11;\n        }\n        else if (key === 1001) {\n            key = 12;\n        }\n        else if (key === 1002) {\n            key = 14;\n        }\n        else if (key === 1003) {\n            key = 15;\n        }\n        else if (key >= 1008) {\n            key -= 992;\n        }\n        this.ensureCapacity(3);\n        this.outBuffer?.p1(8);\n        this.outBuffer?.p1(delta);\n        this.outBuffer?.p1(key);\n    };\n    static keyReleased = (key) => {\n        if (!this.enabled) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        if (key === 1000) {\n            key = 11;\n        }\n        else if (key === 1001) {\n            key = 12;\n        }\n        else if (key === 1002) {\n            key = 14;\n        }\n        else if (key === 1003) {\n            key = 15;\n        }\n        else if (key >= 1008) {\n            key -= 992;\n        }\n        this.ensureCapacity(3);\n        this.outBuffer?.p1(9);\n        this.outBuffer?.p1(delta);\n        this.outBuffer?.p1(key);\n    };\n    static focusGained = () => {\n        if (!this.enabled) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        this.ensureCapacity(2);\n        this.outBuffer?.p1(10);\n        this.outBuffer?.p1(delta);\n    };\n    static focusLost = () => {\n        if (!this.enabled) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        this.ensureCapacity(2);\n        this.outBuffer?.p1(11);\n        this.outBuffer?.p1(delta);\n    };\n    static mouseEntered = () => {\n        if (!this.enabled) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        this.ensureCapacity(2);\n        this.outBuffer?.p1(12);\n        this.outBuffer?.p1(delta);\n    };\n    static mouseExited = () => {\n        if (!this.enabled) {\n            return;\n        }\n        this.trackedCount++;\n        const now = performance.now();\n        let delta = ((now - this.lastTime) / 10) | 0;\n        if (delta > 250) {\n            delta = 250;\n        }\n        this.lastTime = now;\n        this.ensureCapacity(2);\n        this.outBuffer?.p1(13);\n        this.outBuffer?.p1(delta);\n    };\n    static ensureCapacity = (n) => {\n        if (!this.outBuffer) {\n            return;\n        }\n        if (this.outBuffer.pos + n >= 500) {\n            const buffer = this.outBuffer;\n            this.outBuffer = _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"].alloc(1);\n            this.oldBuffer = buffer;\n        }\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/client/InputTracking.ts?");

/***/ }),

/***/ "./src/js/jagex2/client/KeyCodes.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/client/KeyCodes.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CANVAS_PREVENTED: () => (/* binding */ CANVAS_PREVENTED),\n/* harmony export */   KEY_CODES: () => (/* binding */ KEY_CODES)\n/* harmony export */ });\n// prettier-ignore\nconst KEY_CODES = {\n    'Backspace': { code: 8, ch: 8 },\n    'Enter': { code: 10, ch: 10 },\n    'Shift': { code: 16, ch: 65535 },\n    'Escape': { code: 27, ch: 27 },\n    'Tab': { code: 9, ch: 9 },\n    'CapsLock': { code: 20, ch: 65535 },\n    ' ': { code: 32, ch: 32 },\n    'Control': { code: 17, ch: 65535 },\n    'Alt': { code: 18, ch: 65535 },\n    'Meta': { code: 524, ch: 65535 },\n    'ArrowLeft': { code: 37, ch: 65535 },\n    'ArrowRight': { code: 39, ch: 65535 },\n    'ArrowUp': { code: 38, ch: 65535 },\n    'ArrowDown': { code: 40, ch: 65535 },\n    'Insert': { code: 155, ch: 65535 },\n    'Home': { code: 36, ch: 65535 },\n    'PageUp': { code: 33, ch: 65535 },\n    'Delete': { code: 127, ch: 127 },\n    'End': { code: 35, ch: 65535 },\n    'PageDown': { code: 34, ch: 65535 },\n    '`': { code: 192, ch: 96 },\n    '~': { code: 192, ch: 126 },\n    '!': { code: 49, ch: 33 },\n    '@': { code: 50, ch: 64 },\n    '#': { code: 51, ch: 35 },\n    '$': { code: 52, ch: 36 },\n    '%': { code: 53, ch: 37 },\n    '^': { code: 54, ch: 94 },\n    '&': { code: 55, ch: 38 },\n    '*': { code: 56, ch: 42 },\n    '(': { code: 57, ch: 40 },\n    ')': { code: 48, ch: 41 },\n    '-': { code: 45, ch: 45 },\n    '_': { code: 45, ch: 95 },\n    '=': { code: 61, ch: 61 },\n    '+': { code: 61, ch: 43 },\n    '[': { code: 91, ch: 91 },\n    '{': { code: 91, ch: 123 },\n    ']': { code: 93, ch: 93 },\n    '}': { code: 93, ch: 125 },\n    '\\\\': { code: 92, ch: 92 },\n    '|': { code: 92, ch: 124 },\n    ';': { code: 59, ch: 59 },\n    ':': { code: 59, ch: 58 },\n    \"'\": { code: 222, ch: 39 },\n    '\"': { code: 222, ch: 34 },\n    ',': { code: 44, ch: 44 },\n    '<': { code: 44, ch: 60 },\n    '.': { code: 46, ch: 46 },\n    '>': { code: 46, ch: 62 },\n    '/': { code: 47, ch: 47 },\n    '?': { code: 47, ch: 63 },\n    'F1': { code: 112, ch: 65535 },\n    'F2': { code: 113, ch: 65535 },\n    'F3': { code: 114, ch: 65535 },\n    'F4': { code: 115, ch: 65535 },\n    'F5': { code: 116, ch: 65535 },\n    'F6': { code: 117, ch: 65535 },\n    'F7': { code: 118, ch: 65535 },\n    'F8': { code: 119, ch: 65535 },\n    'F9': { code: 120, ch: 65535 },\n    'F10': { code: 121, ch: 65535 },\n    'F11': { code: 122, ch: 65535 },\n    'F12': { code: 123, ch: 65535 },\n    '0': { code: 48, ch: 48 },\n    '1': { code: 49, ch: 49 },\n    '2': { code: 50, ch: 50 },\n    '3': { code: 51, ch: 51 },\n    '4': { code: 52, ch: 52 },\n    '5': { code: 53, ch: 53 },\n    '6': { code: 54, ch: 54 },\n    '7': { code: 55, ch: 55 },\n    '8': { code: 56, ch: 56 },\n    '9': { code: 57, ch: 57 },\n    'a': { code: 65, ch: 97 },\n    'b': { code: 66, ch: 98 },\n    'c': { code: 67, ch: 99 },\n    'd': { code: 68, ch: 100 },\n    'e': { code: 69, ch: 101 },\n    'f': { code: 70, ch: 102 },\n    'g': { code: 71, ch: 103 },\n    'h': { code: 72, ch: 104 },\n    'i': { code: 73, ch: 105 },\n    'j': { code: 74, ch: 106 },\n    'k': { code: 75, ch: 107 },\n    'l': { code: 76, ch: 108 },\n    'm': { code: 77, ch: 109 },\n    'n': { code: 78, ch: 110 },\n    'o': { code: 79, ch: 111 },\n    'p': { code: 80, ch: 112 },\n    'q': { code: 81, ch: 113 },\n    'r': { code: 82, ch: 114 },\n    's': { code: 83, ch: 115 },\n    't': { code: 84, ch: 116 },\n    'u': { code: 85, ch: 117 },\n    'v': { code: 86, ch: 118 },\n    'w': { code: 87, ch: 119 },\n    'x': { code: 88, ch: 120 },\n    'y': { code: 89, ch: 121 },\n    'z': { code: 90, ch: 122 },\n    'A': { code: 65, ch: 65 },\n    'B': { code: 66, ch: 66 },\n    'C': { code: 67, ch: 67 },\n    'D': { code: 68, ch: 68 },\n    'E': { code: 69, ch: 69 },\n    'F': { code: 70, ch: 70 },\n    'G': { code: 71, ch: 71 },\n    'H': { code: 72, ch: 72 },\n    'I': { code: 73, ch: 73 },\n    'J': { code: 74, ch: 74 },\n    'K': { code: 75, ch: 75 },\n    'L': { code: 76, ch: 76 },\n    'M': { code: 77, ch: 77 },\n    'N': { code: 78, ch: 78 },\n    'O': { code: 79, ch: 79 },\n    'P': { code: 80, ch: 80 },\n    'Q': { code: 81, ch: 81 },\n    'R': { code: 82, ch: 82 },\n    'S': { code: 83, ch: 83 },\n    'T': { code: 84, ch: 84 },\n    'U': { code: 85, ch: 85 },\n    'V': { code: 86, ch: 86 },\n    'W': { code: 87, ch: 87 },\n    'X': { code: 88, ch: 88 },\n    'Y': { code: 89, ch: 89 },\n    'Z': { code: 90, ch: 90 }\n};\nconst CANVAS_PREVENTED = ['Tab', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/client/KeyCodes.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/Component.ts":
/*!*******************************************!*\
  !*** ./src/js/jagex2/config/Component.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Component)\n/* harmony export */ });\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../datastruct/LruCache */ \"./src/js/jagex2/datastruct/LruCache.ts\");\n/* harmony import */ var _graphics_Pix24__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/Pix24 */ \"./src/js/jagex2/graphics/Pix24.ts\");\n/* harmony import */ var _datastruct_JString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datastruct/JString */ \"./src/js/jagex2/datastruct/JString.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n/* harmony import */ var _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../graphics/Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n\n\n\n\n\n\n\nclass Component {\n    static instances = [];\n    static imageCache = null;\n    static modelCache = null;\n    // com types\n    static TYPE_LAYER = 0;\n    static TYPE_UNUSED = 1; // TODO\n    static TYPE_INV = 2;\n    static TYPE_RECT = 3;\n    static TYPE_TEXT = 4;\n    static TYPE_GRAPHIC = 5;\n    static TYPE_MODEL = 6;\n    static TYPE_INV_TEXT = 7;\n    // button types\n    static BUTTON_OK = 1;\n    static BUTTON_TARGET = 2;\n    static BUTTON_CLOSE = 3;\n    static BUTTON_TOGGLE = 4;\n    static BUTTON_SELECT = 5;\n    static BUTTON_CONTINUE = 6;\n    // client codes\n    //// friends (1-203)\n    static CC_FRIENDS_START = 1;\n    static CC_FRIENDS_END = 100;\n    static CC_FRIENDS_UPDATE_START = 101;\n    static CC_FRIENDS_UPDATE_END = 200;\n    static CC_ADD_FRIEND = 201;\n    static CC_DEL_FRIEND = 202;\n    static CC_FRIENDS_SIZE = 203;\n    //// logout\n    static CC_LOGOUT = 205;\n    //// player design (300-327)\n    static CC_CHANGE_HEAD_L = 300;\n    static CC_CHANGE_HEAD_R = 301;\n    static CC_CHANGE_JAW_L = 302;\n    static CC_CHANGE_JAW_R = 303;\n    static CC_CHANGE_TORSO_L = 304;\n    static CC_CHANGE_TORSO_R = 305;\n    static CC_CHANGE_ARMS_L = 306;\n    static CC_CHANGE_ARMS_R = 307;\n    static CC_CHANGE_HANDS_L = 308;\n    static CC_CHANGE_HANDS_R = 309;\n    static CC_CHANGE_LEGS_L = 310;\n    static CC_CHANGE_LEGS_R = 311;\n    static CC_CHANGE_FEET_L = 312;\n    static CC_CHANGE_FEET_R = 313;\n    static CC_RECOLOUR_HAIR_L = 314;\n    static CC_RECOLOUR_HAIR_R = 315;\n    static CC_RECOLOUR_TORSO_L = 316;\n    static CC_RECOLOUR_TORSO_R = 317;\n    static CC_RECOLOUR_LEGS_L = 318;\n    static CC_RECOLOUR_LEGS_R = 319;\n    static CC_RECOLOUR_FEET_L = 320;\n    static CC_RECOLOUR_FEET_R = 321;\n    static CC_RECOLOUR_SKIN_L = 322;\n    static CC_RECOLOUR_SKIN_R = 323;\n    static CC_SWITCH_TO_MALE = 324;\n    static CC_SWITCH_TO_FEMALE = 325;\n    static CC_ACCEPT_DESIGN = 326;\n    static CC_DESIGN_PREVIEW = 327;\n    //// ignores (401-503)\n    static CC_IGNORES_START = 401;\n    static CC_IGNORES_END = 500;\n    static CC_ADD_IGNORE = 501;\n    static CC_DEL_IGNORE = 502;\n    static CC_IGNORES_SIZE = 503;\n    //// reportabuse (600-613)\n    static CC_REPORT_INPUT = 600;\n    static CC_REPORT_RULE1 = 601;\n    static CC_REPORT_RULE2 = 602;\n    static CC_REPORT_RULE3 = 603;\n    static CC_REPORT_RULE4 = 604;\n    static CC_REPORT_RULE5 = 605;\n    static CC_REPORT_RULE6 = 606;\n    static CC_REPORT_RULE7 = 607;\n    static CC_REPORT_RULE8 = 608;\n    static CC_REPORT_RULE9 = 609;\n    static CC_REPORT_RULE10 = 610;\n    static CC_REPORT_RULE11 = 611;\n    static CC_REPORT_RULE12 = 612;\n    static CC_MOD_MUTE = 613;\n    //// welcome_screen/welcome_screen2 (650-655)?\n    static CC_LAST_LOGIN_INFO = 650; // has recovery questions\n    static CC_UNREAD_MESSAGES = 651;\n    static CC_RECOVERY1 = 652;\n    static CC_RECOVERY2 = 653;\n    static CC_RECOVERY3 = 654;\n    static CC_LAST_LOGIN_INFO2 = 655; // has no recovery questions\n    static unpack = (interfaces, media, fonts) => {\n        this.imageCache = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__[\"default\"](50000);\n        this.modelCache = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__[\"default\"](50000);\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](interfaces.read('data'));\n        let layer = -1;\n        dat.pos += 2; // const count = dat.g2;\n        while (dat.pos < dat.length) {\n            let id = dat.g2;\n            if (id === 65535) {\n                layer = dat.g2;\n                id = dat.g2;\n            }\n            const com = (this.instances[id] = new Component());\n            com.id = id;\n            com.layer = layer;\n            com.type = dat.g1;\n            com.buttonType = dat.g1;\n            com.clientCode = dat.g2;\n            com.width = dat.g2;\n            com.height = dat.g2;\n            com.overLayer = dat.g1;\n            if (com.overLayer === 0) {\n                com.overLayer = -1;\n            }\n            else {\n                com.overLayer = ((com.overLayer - 1) << 8) + dat.g1;\n            }\n            const comparatorCount = dat.g1;\n            if (comparatorCount > 0) {\n                com.scriptComparator = new Uint8Array(comparatorCount);\n                com.scriptOperand = new Uint16Array(comparatorCount);\n                for (let i = 0; i < comparatorCount; i++) {\n                    com.scriptComparator[i] = dat.g1;\n                    com.scriptOperand[i] = dat.g2;\n                }\n            }\n            const scriptCount = dat.g1;\n            if (scriptCount > 0) {\n                com.scripts = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(scriptCount, null);\n                for (let i = 0; i < scriptCount; i++) {\n                    const opcodeCount = dat.g2;\n                    const scripts = new Uint16Array(opcodeCount);\n                    com.scripts[i] = scripts;\n                    for (let j = 0; j < opcodeCount; j++) {\n                        scripts[j] = dat.g2;\n                    }\n                }\n            }\n            if (com.type === Component.TYPE_LAYER) {\n                com.scroll = dat.g2;\n                com.hide = dat.g1 === 1;\n                const childCount = dat.g1;\n                com.childId = new Array(childCount);\n                com.childX = new Array(childCount);\n                com.childY = new Array(childCount);\n                for (let i = 0; i < childCount; i++) {\n                    com.childId[i] = dat.g2;\n                    com.childX[i] = dat.g2b;\n                    com.childY[i] = dat.g2b;\n                }\n            }\n            if (com.type === Component.TYPE_UNUSED) {\n                dat.pos += 3;\n            }\n            if (com.type === Component.TYPE_INV) {\n                com.invSlotObjId = new Int32Array(com.width * com.height);\n                com.invSlotObjCount = new Int32Array(com.width * com.height);\n                com.draggable = dat.g1 === 1;\n                com.interactable = dat.g1 === 1;\n                com.usable = dat.g1 === 1;\n                com.marginX = dat.g1;\n                com.marginY = dat.g1;\n                com.invSlotOffsetX = new Int16Array(20);\n                com.invSlotOffsetY = new Int16Array(20);\n                com.invSlotSprite = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(20, null);\n                for (let i = 0; i < 20; i++) {\n                    if (dat.g1 === 1) {\n                        com.invSlotOffsetX[i] = dat.g2b;\n                        com.invSlotOffsetY[i] = dat.g2b;\n                        const sprite = dat.gjstr;\n                        if (sprite.length > 0) {\n                            const spriteIndex = sprite.lastIndexOf(',');\n                            // com.inventorySlotImage[i] = {name: sprite.substring(0, spriteIndex), sprite: parseInt(sprite.substring(spriteIndex + 1), 10)}; // Pix24.fromArchive(media, sprite.substring(0, spriteIndex), parseInt(sprite.substring(spriteIndex + 1), 10));\n                            com.invSlotSprite[i] = this.getImage(media, sprite.substring(0, spriteIndex), parseInt(sprite.substring(spriteIndex + 1), 10));\n                        }\n                    }\n                }\n                com.iops = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(5, null);\n                for (let i = 0; i < 5; i++) {\n                    const iop = dat.gjstr;\n                    com.iops[i] = iop;\n                    if (iop.length === 0) {\n                        com.iops[i] = null;\n                    }\n                }\n            }\n            if (com.type === Component.TYPE_RECT) {\n                com.fill = dat.g1 === 1;\n            }\n            if (com.type === Component.TYPE_TEXT || com.type === Component.TYPE_UNUSED) {\n                com.center = dat.g1 === 1;\n                const fontId = dat.g1;\n                if (fonts) {\n                    com.font = fonts[fontId];\n                }\n                com.shadowed = dat.g1 === 1;\n            }\n            if (com.type === Component.TYPE_TEXT) {\n                com.text = dat.gjstr;\n                com.activeText = dat.gjstr;\n            }\n            if (com.type === Component.TYPE_UNUSED || com.type === Component.TYPE_RECT || com.type === Component.TYPE_TEXT) {\n                com.colour = dat.g4;\n            }\n            if (com.type === Component.TYPE_RECT || com.type === Component.TYPE_TEXT) {\n                com.activeColour = dat.g4;\n                com.overColour = dat.g4;\n            }\n            if (com.type === Component.TYPE_GRAPHIC) {\n                const graphic = dat.gjstr;\n                if (graphic.length > 0) {\n                    const index = graphic.lastIndexOf(',');\n                    // com.image = {name: image.substring(0, spriteIndex), sprite: parseInt(image.substring(spriteIndex + 1), 10)}; // Pix24.fromArchive(media, image.substring(0, spriteIndex), parseInt(image.substring(spriteIndex + 1), 10));\n                    com.graphic = this.getImage(media, graphic.substring(0, index), parseInt(graphic.substring(index + 1), 10));\n                }\n                const activeGraphic = dat.gjstr;\n                if (activeGraphic.length > 0) {\n                    const index = activeGraphic.lastIndexOf(',');\n                    // com.activeImage = {name: activeImage.substring(0, spriteIndex), sprite: parseInt(activeImage.substring(spriteIndex + 1), 10)}; // Pix24.fromArchive(media, activeImage.substring(0, spriteIndex), parseInt(activeImage.substring(spriteIndex + 1), 10));\n                    com.activeGraphic = this.getImage(media, activeGraphic.substring(0, index), parseInt(activeGraphic.substring(index + 1), 10));\n                }\n            }\n            if (com.type === Component.TYPE_MODEL) {\n                const model = dat.g1;\n                if (model !== 0) {\n                    com.model = this.getModel(((model - 1) << 8) + dat.g1);\n                }\n                const activeModel = dat.g1;\n                if (activeModel !== 0) {\n                    com.activeModel = this.getModel(((activeModel - 1) << 8) + dat.g1);\n                }\n                com.anim = dat.g1;\n                if (com.anim === 0) {\n                    com.anim = -1;\n                }\n                else {\n                    com.anim = ((com.anim - 1) << 8) + dat.g1;\n                }\n                com.activeAnim = dat.g1;\n                if (com.activeAnim === 0) {\n                    com.activeAnim = -1;\n                }\n                else {\n                    com.activeAnim = ((com.activeAnim - 1) << 8) + dat.g1;\n                }\n                com.zoom = dat.g2;\n                com.xan = dat.g2;\n                com.yan = dat.g2;\n            }\n            if (com.type === Component.TYPE_INV_TEXT) {\n                com.invSlotObjId = new Int32Array(com.width * com.height);\n                com.invSlotObjCount = new Int32Array(com.width * com.height);\n                com.center = dat.g1 === 1;\n                const fontId = dat.g1;\n                if (fonts) {\n                    com.font = fonts[fontId];\n                }\n                com.shadowed = dat.g1 === 1;\n                com.colour = dat.g4;\n                com.marginX = dat.g2b;\n                com.marginY = dat.g2b;\n                com.interactable = dat.g1 === 1;\n                com.iops = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(5, null);\n                for (let i = 0; i < 5; i++) {\n                    const iop = dat.gjstr;\n                    com.iops[i] = iop;\n                    if (iop.length === 0) {\n                        com.iops[i] = null;\n                    }\n                }\n            }\n            if (com.buttonType === Component.BUTTON_TARGET || com.type === Component.TYPE_INV) {\n                com.actionVerb = dat.gjstr;\n                com.action = dat.gjstr;\n                com.actionTarget = dat.g2;\n            }\n            if (com.buttonType === Component.BUTTON_OK || com.buttonType === Component.BUTTON_TOGGLE || com.buttonType === Component.BUTTON_SELECT || com.buttonType === Component.BUTTON_CONTINUE) {\n                com.option = dat.gjstr;\n                if (com.option.length === 0) {\n                    if (com.buttonType === Component.BUTTON_OK) {\n                        com.option = 'Ok';\n                    }\n                    else if (com.buttonType === Component.BUTTON_TOGGLE) {\n                        com.option = 'Select';\n                    }\n                    else if (com.buttonType === Component.BUTTON_SELECT) {\n                        com.option = 'Select';\n                    }\n                    else if (com.buttonType === Component.BUTTON_CONTINUE) {\n                        com.option = 'Continue';\n                    }\n                }\n            }\n        }\n        this.imageCache = null;\n        this.modelCache = null;\n    };\n    static getImage = (media, sprite, spriteId) => {\n        const uid = (_datastruct_JString__WEBPACK_IMPORTED_MODULE_4__[\"default\"].hashCode(sprite) << 8n) | BigInt(spriteId);\n        if (this.imageCache) {\n            const image = this.imageCache.get(uid);\n            if (image) {\n                return image;\n            }\n        }\n        let image;\n        try {\n            image = _graphics_Pix24__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromArchive(media, sprite, spriteId);\n            this.imageCache?.put(uid, image);\n        }\n        catch (e) {\n            return null;\n        }\n        return image;\n    };\n    static getModel = (id) => {\n        if (this.modelCache) {\n            const model = this.modelCache.get(BigInt(id));\n            if (model) {\n                return model;\n            }\n        }\n        const model = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].model(id);\n        this.modelCache?.put(BigInt(id), model);\n        return model;\n    };\n    /* Client codes:\n     * ---- friends\n     * 1-200: friends list\n     * 201: add friend\n     * 202: delete friend\n     * 203: friends list scrollbar size\n     * ---- logout\n     * 205: logout\n     * ---- player_design\n     * 300: change head (left)\n     * 301: change head (right)\n     * 302: change jaw (left)\n     * 303: change jaw (right)\n     * 304: change torso (left)\n     * 305: change torso (right)\n     * 306: change arms (left)\n     * 307: change arms (right)\n     * 308: change hands (left)\n     * 309: change hands (right)\n     * 310: change legs (left)\n     * 311: change legs (right)\n     * 312: change feet (left)\n     * 313: change feet (right)\n     * 314: recolour hair (left)\n     * 315: recolour hair (right)\n     * 316: recolour torso (left)\n     * 317: recolour torso (right)\n     * 318: recolour legs (left)\n     * 319: recolour legs (right)\n     * 320: recolour feet (left)\n     * 321: recolour feet (right)\n     * 322: recolour skin (left)\n     * 323: recolour skin (right)\n     * 324: switch to male\n     * 325: switch to female\n     * 326: accept design\n     * 327: design preview\n     * ---- ignore\n     * 401-500: ignore list\n     * 501: add ignore\n     * 502: delete ignore\n     * 503: ignore list scrollbar size\n     * ---- reportabuse\n     * 601: rule 1\n     * 602: rule 2\n     * 603: rule 3\n     * 604: rule 4\n     * 605: rule 5\n     * 606: rule 6\n     * 607: rule 7\n     * 608: rule 8\n     * 609: rule 9\n     * 610: rule 10\n     * 611: rule 11\n     * 612: rule 12\n     * 613: moderator mute\n     * ---- welcome_screen / welcome_screen2\n     * 650: last login info (has recovery questions set)\n     * 651: unread messages\n     * 655: last login info (no recovery questions set)\n     */\n    // ----\n    id = -1;\n    layer = -1;\n    type = -1;\n    buttonType = -1;\n    clientCode = 0;\n    width = 0;\n    height = 0;\n    overLayer = -1;\n    scriptComparator = null;\n    scriptOperand = null;\n    scripts = null;\n    scroll = 0;\n    hide = false;\n    draggable = false;\n    interactable = false;\n    usable = false;\n    marginX = 0;\n    marginY = 0;\n    invSlotOffsetX = null;\n    invSlotOffsetY = null;\n    invSlotSprite = null;\n    iops = null;\n    fill = false;\n    center = false;\n    font = null;\n    shadowed = false;\n    text = null;\n    activeText = null;\n    colour = 0;\n    activeColour = 0;\n    overColour = 0;\n    graphic = null;\n    activeGraphic = null;\n    model = null;\n    activeModel = null;\n    anim = -1;\n    activeAnim = -1;\n    zoom = 0;\n    xan = 0;\n    yan = 0;\n    actionVerb = null;\n    action = null;\n    actionTarget = -1;\n    option = null;\n    childId = null;\n    childX = null;\n    childY = null;\n    // other\n    x = 0;\n    y = 0;\n    scrollPosition = 0;\n    invSlotObjId = null;\n    invSlotObjCount = null;\n    seqFrame = 0;\n    seqCycle = 0;\n    getModel(primaryFrame, secondaryFrame, active) {\n        let model = this.model;\n        if (active) {\n            model = this.activeModel;\n        }\n        if (!model) {\n            return null;\n        }\n        if (primaryFrame === -1 && secondaryFrame === -1 && !model.faceColor) {\n            return model;\n        }\n        const tmp = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelShareColored(model, true, true, false);\n        if (primaryFrame !== -1 || secondaryFrame !== -1) {\n            tmp.createLabelReferences();\n        }\n        if (primaryFrame !== -1) {\n            tmp.applyTransform(primaryFrame);\n        }\n        if (secondaryFrame !== -1) {\n            tmp.applyTransform(secondaryFrame);\n        }\n        tmp.calculateNormals(64, 768, -50, -10, -50, true);\n        return tmp;\n    }\n    getAbsoluteX() {\n        if (this.layer === this.id) {\n            return this.x;\n        }\n        let parent = Component.instances[this.layer];\n        if (!parent.childId || !parent.childX || !parent.childY) {\n            return this.x;\n        }\n        let childIndex = parent.childId.indexOf(this.id);\n        if (childIndex === -1) {\n            return this.x;\n        }\n        let x = parent.childX[childIndex];\n        while (parent.layer !== parent.id) {\n            const grandParent = Component.instances[parent.layer];\n            if (grandParent.childId && grandParent.childX && grandParent.childY) {\n                childIndex = grandParent.childId.indexOf(parent.id);\n                if (childIndex !== -1) {\n                    x += grandParent.childX[childIndex];\n                }\n            }\n            parent = grandParent;\n        }\n        return x;\n    }\n    getAbsoluteY() {\n        if (this.layer === this.id) {\n            return this.y;\n        }\n        let parent = Component.instances[this.layer];\n        if (!parent.childId || !parent.childX || !parent.childY) {\n            return this.y;\n        }\n        let childIndex = parent.childId.indexOf(this.id);\n        if (childIndex === -1) {\n            return this.y;\n        }\n        let y = parent.childY[childIndex];\n        while (parent.layer !== parent.id) {\n            const grandParent = Component.instances[parent.layer];\n            if (grandParent.childId && grandParent.childX && grandParent.childY) {\n                childIndex = grandParent.childId.indexOf(parent.id);\n                if (childIndex !== -1) {\n                    y += grandParent.childY[childIndex];\n                }\n            }\n            parent = grandParent;\n        }\n        return y;\n    }\n    outline(color) {\n        const x = this.getAbsoluteX();\n        const y = this.getAbsoluteY();\n        _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawRect(x, y, this.width, this.height, color);\n    }\n    move(x, y) {\n        if (this.layer === this.id) {\n            return;\n        }\n        this.x = 0;\n        this.y = 0;\n        const parent = Component.instances[this.layer];\n        if (parent.childId && parent.childX && parent.childY) {\n            const childIndex = parent.childId.indexOf(this.id);\n            if (childIndex !== -1) {\n                parent.childX[childIndex] = x;\n                parent.childY[childIndex] = y;\n            }\n        }\n    }\n    delete() {\n        if (this.layer === this.id) {\n            return;\n        }\n        const parent = Component.instances[this.layer];\n        if (parent.childId && parent.childX && parent.childY) {\n            const childIndex = parent.childId.indexOf(this.id);\n            if (childIndex !== -1) {\n                parent.childId.splice(childIndex, 1);\n                parent.childX.splice(childIndex, 1);\n                parent.childY.splice(childIndex, 1);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/Component.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/ConfigType.ts":
/*!********************************************!*\
  !*** ./src/js/jagex2/config/ConfigType.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConfigType: () => (/* binding */ ConfigType)\n/* harmony export */ });\nclass ConfigType {\n    id;\n    debugname = null;\n    constructor(id) {\n        this.id = id;\n    }\n    decodeType(dat) {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const opcode = dat.g1;\n            if (opcode === 0) {\n                break;\n            }\n            this.decode(opcode, dat);\n        }\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/ConfigType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/FloType.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/config/FloType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FloType)\n/* harmony export */ });\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n\n\nclass FloType extends _ConfigType__WEBPACK_IMPORTED_MODULE_1__.ConfigType {\n    static count = 0;\n    static instances = [];\n    static unpack = (config) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](config.read('flo.dat'));\n        this.count = dat.g2;\n        for (let i = 0; i < this.count; i++) {\n            this.instances[i] = new FloType(i).decodeType(dat);\n        }\n    };\n    static hsl24to16 = (hue, saturation, lightness) => {\n        if (lightness > 179) {\n            saturation = (saturation / 2) | 0;\n        }\n        if (lightness > 192) {\n            saturation = (saturation / 2) | 0;\n        }\n        if (lightness > 217) {\n            saturation = (saturation / 2) | 0;\n        }\n        if (lightness > 243) {\n            saturation = (saturation / 2) | 0;\n        }\n        return (((hue / 4) | 0) << 10) + (((saturation / 32) | 0) << 7) + ((lightness / 2) | 0);\n    };\n    static mulHSL = (hsl, lightness) => {\n        if (hsl === -1) {\n            return 12345678;\n        }\n        lightness = ((lightness * (hsl & 0x7f)) / 128) | 0;\n        if (lightness < 2) {\n            lightness = 2;\n        }\n        else if (lightness > 126) {\n            lightness = 126;\n        }\n        return (hsl & 0xff80) + lightness;\n    };\n    static adjustLightness = (hsl, scalar) => {\n        if (hsl === -2) {\n            return 12345678;\n        }\n        if (hsl === -1) {\n            if (scalar < 0) {\n                scalar = 0;\n            }\n            else if (scalar > 127) {\n                scalar = 127;\n            }\n            return 127 - scalar;\n        }\n        else {\n            scalar = ((scalar * (hsl & 0x7f)) / 128) | 0;\n            if (scalar < 2) {\n                scalar = 2;\n            }\n            else if (scalar > 126) {\n                scalar = 126;\n            }\n            return (hsl & 0xff80) + scalar;\n        }\n    };\n    // ----\n    rgb = 0;\n    texture = -1;\n    opcode3 = false;\n    occlude = true;\n    // runtime\n    hue = 0;\n    saturation = 0;\n    lightness = 0;\n    luminance = 0;\n    chroma = 0;\n    hsl = 0;\n    decode(code, dat) {\n        if (code === 1) {\n            this.rgb = dat.g3;\n            this.setColor(this.rgb);\n        }\n        else if (code === 2) {\n            this.texture = dat.g1;\n        }\n        else if (code === 3) {\n            this.opcode3 = true;\n        }\n        else if (code === 5) {\n            this.occlude = false;\n        }\n        else if (code === 6) {\n            this.debugname = dat.gjstr;\n        }\n        else {\n            console.log('Error unrecognised config code: ', code);\n        }\n    }\n    setColor(rgb) {\n        const red = ((rgb >> 16) & 0xff) / 256.0;\n        const green = ((rgb >> 8) & 0xff) / 256.0;\n        const blue = (rgb & 0xff) / 256.0;\n        let min = red;\n        if (green < red) {\n            min = green;\n        }\n        if (blue < min) {\n            min = blue;\n        }\n        let max = red;\n        if (green > red) {\n            max = green;\n        }\n        if (blue > max) {\n            max = blue;\n        }\n        let h = 0.0;\n        let s = 0.0;\n        const l = (min + max) / 2.0;\n        if (min !== max) {\n            if (l < 0.5) {\n                s = (max - min) / (max + min);\n            }\n            if (l >= 0.5) {\n                s = (max - min) / (2.0 - max - min);\n            }\n            if (red === max) {\n                h = (green - blue) / (max - min);\n            }\n            else if (green === max) {\n                h = (blue - red) / (max - min) + 2.0;\n            }\n            else if (blue === max) {\n                h = (red - green) / (max - min) + 4.0;\n            }\n        }\n        h /= 6.0;\n        this.hue = (h * 256.0) | 0;\n        this.saturation = (s * 256.0) | 0;\n        this.lightness = (l * 256.0) | 0;\n        if (this.saturation < 0) {\n            this.saturation = 0;\n        }\n        else if (this.saturation > 255) {\n            this.saturation = 255;\n        }\n        if (this.lightness < 0) {\n            this.lightness = 0;\n        }\n        else if (this.lightness > 255) {\n            this.lightness = 255;\n        }\n        if (l > 0.5) {\n            this.luminance = ((1.0 - l) * s * 512.0) | 0;\n        }\n        else {\n            this.luminance = (l * s * 512.0) | 0;\n        }\n        if (this.luminance < 1) {\n            this.luminance = 1;\n        }\n        this.chroma = (h * this.luminance) | 0;\n        let hue = this.hue + ((Math.random() * 16.0) | 0) - 8;\n        if (hue < 0) {\n            hue = 0;\n        }\n        else if (hue > 255) {\n            hue = 255;\n        }\n        let saturation = this.saturation + ((Math.random() * 48.0) | 0) - 24;\n        if (saturation < 0) {\n            saturation = 0;\n        }\n        else if (saturation > 255) {\n            saturation = 255;\n        }\n        let lightness = this.lightness + ((Math.random() * 48.0) | 0) - 24;\n        if (lightness < 0) {\n            lightness = 0;\n        }\n        else if (lightness > 255) {\n            lightness = 255;\n        }\n        this.hsl = FloType.hsl24to16(hue, saturation, lightness);\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/FloType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/IdkType.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/config/IdkType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ IdkType)\n/* harmony export */ });\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n\nclass IdkType extends _ConfigType__WEBPACK_IMPORTED_MODULE_1__.ConfigType {\n    static count = 0;\n    static instances = [];\n    static unpack = (config) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](config.read('idk.dat'));\n        this.count = dat.g2;\n        for (let i = 0; i < this.count; i++) {\n            this.instances[i] = new IdkType(i).decodeType(dat);\n        }\n    };\n    // ----\n    type = -1;\n    models = null;\n    heads = new Int32Array(5).fill(-1);\n    recol_s = new Int32Array(6);\n    recol_d = new Int32Array(6);\n    disable = false;\n    decode(code, dat) {\n        if (code === 1) {\n            this.type = dat.g1;\n        }\n        else if (code === 2) {\n            const count = dat.g1;\n            this.models = new Int32Array(count);\n            for (let i = 0; i < count; i++) {\n                this.models[i] = dat.g2;\n            }\n        }\n        else if (code === 3) {\n            this.disable = true;\n        }\n        else if (code >= 40 && code < 50) {\n            this.recol_s[code - 40] = dat.g2;\n        }\n        else if (code >= 50 && code < 60) {\n            this.recol_d[code - 50] = dat.g2;\n        }\n        else if (code >= 60 && code < 70) {\n            this.heads[code - 60] = dat.g2;\n        }\n        else {\n            throw new Error(`Unrecognized idk config code: ${code}`);\n        }\n    }\n    getModel() {\n        if (!this.models) {\n            return null;\n        }\n        const models = new _util_Arrays__WEBPACK_IMPORTED_MODULE_3__.TypedArray1d(this.models.length, null);\n        for (let i = 0; i < this.models.length; i++) {\n            models[i] = _graphics_Model__WEBPACK_IMPORTED_MODULE_2__[\"default\"].model(this.models[i]);\n        }\n        let model;\n        if (models.length === 1) {\n            model = models[0];\n        }\n        else {\n            model = _graphics_Model__WEBPACK_IMPORTED_MODULE_2__[\"default\"].modelFromModels(models, models.length);\n        }\n        for (let i = 0; i < 6 && this.recol_s[i] !== 0; i++) {\n            model?.recolor(this.recol_s[i], this.recol_d[i]);\n        }\n        return model;\n    }\n    getHeadModel() {\n        let count = 0;\n        const models = new _util_Arrays__WEBPACK_IMPORTED_MODULE_3__.TypedArray1d(5, null);\n        for (let i = 0; i < 5; i++) {\n            if (this.heads[i] !== -1) {\n                models[count++] = _graphics_Model__WEBPACK_IMPORTED_MODULE_2__[\"default\"].model(this.heads[i]);\n            }\n        }\n        const model = _graphics_Model__WEBPACK_IMPORTED_MODULE_2__[\"default\"].modelFromModels(models, count);\n        for (let i = 0; i < 6 && this.recol_s[i] !== 0; i++) {\n            model.recolor(this.recol_s[i], this.recol_d[i]);\n        }\n        return model;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/IdkType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/LocType.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/config/LocType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocType)\n/* harmony export */ });\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../datastruct/LruCache */ \"./src/js/jagex2/datastruct/LruCache.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _dash3d_LocShape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dash3d/LocShape */ \"./src/js/jagex2/dash3d/LocShape.ts\");\n/* harmony import */ var _dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dash3d/LocAngle */ \"./src/js/jagex2/dash3d/LocAngle.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n\n\n\n\nclass LocType extends _ConfigType__WEBPACK_IMPORTED_MODULE_0__.ConfigType {\n    static count = 0;\n    static cache = null;\n    static dat = null;\n    static offsets = null;\n    static cachePos = 0;\n    static modelCacheStatic = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__[\"default\"](500);\n    static modelCacheDynamic = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__[\"default\"](30);\n    static unpack = (config) => {\n        this.dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('loc.dat'));\n        const idx = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('loc.idx'));\n        this.count = idx.g2;\n        this.offsets = new Int32Array(this.count);\n        let offset = 2;\n        for (let id = 0; id < this.count; id++) {\n            this.offsets[id] = offset;\n            offset += idx.g2;\n        }\n        this.cache = new _util_Arrays__WEBPACK_IMPORTED_MODULE_6__.TypedArray1d(10, null);\n        for (let id = 0; id < 10; id++) {\n            this.cache[id] = new LocType(-1);\n        }\n    };\n    static get = (id) => {\n        if (!this.cache || !this.offsets || !this.dat) {\n            throw new Error('LocType not loaded!!!');\n        }\n        for (let i = 0; i < 10; i++) {\n            const type = this.cache[i];\n            if (!type) {\n                continue;\n            }\n            if (type.id === id) {\n                return type;\n            }\n        }\n        this.cachePos = (this.cachePos + 1) % 10;\n        const loc = this.cache[this.cachePos];\n        this.dat.pos = this.offsets[id];\n        loc.id = id;\n        loc.reset();\n        loc.decodeType(this.dat);\n        if (!loc.shapes) {\n            loc.shapes = new Int32Array(1);\n        }\n        if (loc.active2 === -1 && loc.shapes) {\n            loc.active = loc.shapes.length > 0 && loc.shapes[0] === _dash3d_LocShape__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CENTREPIECE_STRAIGHT.id;\n            if (loc.op) {\n                loc.active = true;\n            }\n        }\n        return loc;\n    };\n    static unload = () => {\n        this.modelCacheStatic = null;\n        this.modelCacheDynamic = null;\n        this.offsets = null;\n        this.cache = null;\n        this.dat = null;\n    };\n    // ----\n    models = null;\n    shapes = null;\n    name = null;\n    desc = null;\n    recol_s = null;\n    recol_d = null;\n    width = 1;\n    length = 1;\n    blockwalk = true;\n    blockrange = true;\n    active = false;\n    active2 = -1;\n    hillskew = false;\n    sharelight = false;\n    occlude = false;\n    anim = -1;\n    disposeAlpha = false;\n    wallwidth = 16;\n    ambient = 0;\n    contrast = 0;\n    op = null;\n    mapfunction = -1;\n    mapscene = -1;\n    mirror = false;\n    shadow = true;\n    resizex = 128;\n    resizey = 128;\n    resizez = 128;\n    forceapproach = 0;\n    offsetx = 0;\n    offsety = 0;\n    offsetz = 0;\n    forcedecor = false;\n    decode(code, dat) {\n        if (code === 1) {\n            const count = dat.g1;\n            this.models = new Int32Array(count);\n            this.shapes = new Int32Array(count);\n            for (let i = 0; i < count; i++) {\n                this.models[i] = dat.g2;\n                this.shapes[i] = dat.g1;\n            }\n        }\n        else if (code === 2) {\n            this.name = dat.gjstr;\n        }\n        else if (code === 3) {\n            this.desc = dat.gjstr;\n        }\n        else if (code === 14) {\n            this.width = dat.g1;\n        }\n        else if (code === 15) {\n            this.length = dat.g1;\n        }\n        else if (code === 17) {\n            this.blockwalk = false;\n        }\n        else if (code === 18) {\n            this.blockrange = false;\n        }\n        else if (code === 19) {\n            this.active2 = dat.g1;\n            if (this.active2 === 1) {\n                this.active = true;\n            }\n        }\n        else if (code === 21) {\n            this.hillskew = true;\n        }\n        else if (code === 22) {\n            this.sharelight = true;\n        }\n        else if (code === 23) {\n            this.occlude = true;\n        }\n        else if (code === 24) {\n            this.anim = dat.g2;\n            if (this.anim === 65535) {\n                this.anim = -1;\n            }\n        }\n        else if (code === 25) {\n            this.disposeAlpha = true;\n        }\n        else if (code === 28) {\n            this.wallwidth = dat.g1;\n        }\n        else if (code === 29) {\n            this.ambient = dat.g1b;\n        }\n        else if (code === 39) {\n            this.contrast = dat.g1b;\n        }\n        else if (code >= 30 && code < 39) {\n            if (!this.op) {\n                this.op = new _util_Arrays__WEBPACK_IMPORTED_MODULE_6__.TypedArray1d(5, null);\n            }\n            this.op[code - 30] = dat.gjstr;\n            if (this.op[code - 30]?.toLowerCase() === 'hidden') {\n                this.op[code - 30] = null;\n            }\n        }\n        else if (code === 40) {\n            const count = dat.g1;\n            this.recol_s = new Uint16Array(count);\n            this.recol_d = new Uint16Array(count);\n            for (let i = 0; i < count; i++) {\n                this.recol_s[i] = dat.g2;\n                this.recol_d[i] = dat.g2;\n            }\n        }\n        else if (code === 60) {\n            this.mapfunction = dat.g2;\n        }\n        else if (code === 62) {\n            this.mirror = true;\n        }\n        else if (code === 64) {\n            this.shadow = false;\n        }\n        else if (code === 65) {\n            this.resizex = dat.g2;\n        }\n        else if (code === 66) {\n            this.resizey = dat.g2;\n        }\n        else if (code === 67) {\n            this.resizez = dat.g2;\n        }\n        else if (code === 68) {\n            this.mapscene = dat.g2;\n        }\n        else if (code === 69) {\n            this.forceapproach = dat.g1;\n        }\n        else if (code === 70) {\n            this.offsetx = dat.g2b;\n        }\n        else if (code === 71) {\n            this.offsety = dat.g2b;\n        }\n        else if (code === 72) {\n            this.offsetz = dat.g2b;\n        }\n        else if (code === 73) {\n            this.forcedecor = true;\n        }\n    }\n    getModel(shape, angle, heightmapSW, heightmapSE, heightmapNE, heightmapNW, transformId) {\n        if (!this.shapes) {\n            return null;\n        }\n        let shapeIndex = -1;\n        for (let i = 0; i < this.shapes.length; i++) {\n            if (this.shapes[i] === shape) {\n                shapeIndex = i;\n                break;\n            }\n        }\n        if (shapeIndex === -1) {\n            return null;\n        }\n        const bitset = BigInt(BigInt(this.id) << 6n) + BigInt(BigInt(shapeIndex) << 3n) + BigInt(angle) + BigInt((BigInt(transformId) + 1n) << 32n);\n        /*if (reset) {\n            bitset = 0L;\n        }*/\n        let cached = LocType.modelCacheDynamic?.get(bitset);\n        if (cached) {\n            /*if (reset) {\n                return cached;\n            }*/\n            if (this.hillskew || this.sharelight) {\n                cached = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].modelCopyFaces(cached, this.hillskew, this.sharelight);\n            }\n            if (this.hillskew) {\n                const groundY = ((heightmapSW + heightmapSE + heightmapNE + heightmapNW) / 4) | 0;\n                for (let i = 0; i < cached.vertexCount; i++) {\n                    const x = cached.vertexX[i];\n                    const z = cached.vertexZ[i];\n                    const heightS = heightmapSW + ((((heightmapSE - heightmapSW) * (x + 64)) / 128) | 0);\n                    const heightN = heightmapNW + ((((heightmapNE - heightmapNW) * (x + 64)) / 128) | 0);\n                    const y = heightS + ((((heightN - heightS) * (z + 64)) / 128) | 0);\n                    cached.vertexY[i] += y - groundY;\n                }\n                cached.calculateBoundsY();\n            }\n            return cached;\n        }\n        if (!this.models) {\n            return null;\n        }\n        if (shapeIndex >= this.models.length) {\n            return null;\n        }\n        let modelId = this.models[shapeIndex];\n        if (modelId === -1) {\n            return null;\n        }\n        const flipped = this.mirror !== angle > 3;\n        if (flipped) {\n            modelId += 65536;\n        }\n        let model = LocType.modelCacheStatic?.get(BigInt(modelId));\n        if (!model) {\n            model = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].model(modelId & 0xffff);\n            if (flipped) {\n                model.rotateY180();\n            }\n            LocType.modelCacheStatic?.put(BigInt(modelId), model);\n        }\n        const scaled = this.resizex !== 128 || this.resizey !== 128 || this.resizez !== 128;\n        const translated = this.offsetx !== 0 || this.offsety !== 0 || this.offsetz !== 0;\n        let modified = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].modelShareColored(model, !this.recol_s, !this.disposeAlpha, angle === _dash3d_LocAngle__WEBPACK_IMPORTED_MODULE_5__[\"default\"].WEST && transformId === -1 && !scaled && !translated);\n        if (transformId !== -1) {\n            modified.createLabelReferences();\n            modified.applyTransform(transformId);\n            modified.labelFaces = null;\n            modified.labelVertices = null;\n        }\n        while (angle-- > 0) {\n            modified.rotateY90();\n        }\n        if (this.recol_s && this.recol_d) {\n            for (let i = 0; i < this.recol_s.length; i++) {\n                modified.recolor(this.recol_s[i], this.recol_d[i]);\n            }\n        }\n        if (scaled) {\n            modified.scale(this.resizex, this.resizey, this.resizez);\n        }\n        if (translated) {\n            modified.translate(this.offsety, this.offsetx, this.offsetz);\n        }\n        modified.calculateNormals((this.ambient & 0xff) + 64, (this.contrast & 0xff) * 5 + 768, -50, -10, -50, !this.sharelight);\n        if (this.blockwalk) {\n            modified.objRaise = modified.maxY;\n        }\n        LocType.modelCacheDynamic?.put(bitset, modified);\n        if (this.hillskew || this.sharelight) {\n            modified = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].modelCopyFaces(modified, this.hillskew, this.sharelight);\n        }\n        if (this.hillskew) {\n            const groundY = ((heightmapSW + heightmapSE + heightmapNE + heightmapNW) / 4) | 0;\n            for (let i = 0; i < modified.vertexCount; i++) {\n                const x = modified.vertexX[i];\n                const z = modified.vertexZ[i];\n                const heightS = heightmapSW + ((((heightmapSE - heightmapSW) * (x + 64)) / 128) | 0);\n                const heightN = heightmapNW + ((((heightmapNE - heightmapNW) * (x + 64)) / 128) | 0);\n                const y = heightS + ((((heightN - heightS) * (z + 64)) / 128) | 0);\n                modified.vertexY[i] += y - groundY;\n            }\n            modified.calculateBoundsY();\n        }\n        return modified;\n    }\n    reset() {\n        this.models = null;\n        this.shapes = null;\n        this.name = null;\n        this.desc = null;\n        this.recol_s = null;\n        this.recol_d = null;\n        this.width = 1;\n        this.length = 1;\n        this.blockwalk = true;\n        this.blockrange = true;\n        this.active = false;\n        this.active2 = -1;\n        this.hillskew = false;\n        this.sharelight = false;\n        this.occlude = false;\n        this.anim = -1;\n        this.wallwidth = 16;\n        this.ambient = 0;\n        this.contrast = 0;\n        this.op = null;\n        this.disposeAlpha = false;\n        this.mapfunction = -1;\n        this.mapscene = -1;\n        this.mirror = false;\n        this.shadow = true;\n        this.resizex = 128;\n        this.resizey = 128;\n        this.resizez = 128;\n        this.forceapproach = 0;\n        this.offsetx = 0;\n        this.offsety = 0;\n        this.offsetz = 0;\n        this.forcedecor = false;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/LocType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/NpcType.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/config/NpcType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NpcType)\n/* harmony export */ });\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../datastruct/LruCache */ \"./src/js/jagex2/datastruct/LruCache.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n\n\nclass NpcType extends _ConfigType__WEBPACK_IMPORTED_MODULE_0__.ConfigType {\n    static count = 0;\n    static cache = null;\n    static dat = null;\n    static offsets = null;\n    static cachePos = 0;\n    static modelCache = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__[\"default\"](30);\n    static unpack = (config) => {\n        this.dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('npc.dat'));\n        const idx = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('npc.idx'));\n        this.count = idx.g2;\n        this.offsets = new Int32Array(this.count);\n        let offset = 2;\n        for (let id = 0; id < this.count; id++) {\n            this.offsets[id] = offset;\n            offset += idx.g2;\n        }\n        this.cache = new _util_Arrays__WEBPACK_IMPORTED_MODULE_4__.TypedArray1d(20, null);\n        for (let id = 0; id < 20; id++) {\n            this.cache[id] = new NpcType(-1);\n        }\n    };\n    static get = (id) => {\n        if (!this.cache || !this.offsets || !this.dat) {\n            throw new Error('NpcType not loaded!!!');\n        }\n        for (let i = 0; i < 20; i++) {\n            const type = this.cache[i];\n            if (!type) {\n                continue;\n            }\n            if (type.id === id) {\n                return type;\n            }\n        }\n        this.cachePos = (this.cachePos + 1) % 20;\n        const loc = (this.cache[this.cachePos] = new NpcType(id));\n        this.dat.pos = this.offsets[id];\n        loc.decodeType(this.dat);\n        return loc;\n    };\n    static unload = () => {\n        this.modelCache = null;\n        this.offsets = null;\n        this.cache = null;\n        this.dat = null;\n    };\n    // ----\n    name = null;\n    desc = null;\n    size = 1;\n    models = null;\n    heads = null;\n    disposeAlpha = false;\n    readyanim = -1;\n    walkanim = -1;\n    walkanim_b = -1;\n    walkanim_r = -1;\n    walkanim_l = -1;\n    recol_s = null;\n    recol_d = null;\n    op = null;\n    resizex = -1;\n    resizey = -1;\n    resizez = -1;\n    minimap = true;\n    vislevel = -1;\n    resizeh = 128;\n    resizev = 128;\n    decode(code, dat) {\n        if (code === 1) {\n            const count = dat.g1;\n            this.models = new Uint16Array(count);\n            for (let i = 0; i < count; i++) {\n                this.models[i] = dat.g2;\n            }\n        }\n        else if (code === 2) {\n            this.name = dat.gjstr;\n        }\n        else if (code === 3) {\n            this.desc = dat.gjstr;\n        }\n        else if (code === 12) {\n            this.size = dat.g1b;\n        }\n        else if (code === 13) {\n            this.readyanim = dat.g2;\n        }\n        else if (code === 14) {\n            this.walkanim = dat.g2;\n        }\n        else if (code === 16) {\n            this.disposeAlpha = true;\n        }\n        else if (code === 17) {\n            this.walkanim = dat.g2;\n            this.walkanim_b = dat.g2;\n            this.walkanim_r = dat.g2;\n            this.walkanim_l = dat.g2;\n        }\n        else if (code >= 30 && code < 40) {\n            if (!this.op) {\n                this.op = new _util_Arrays__WEBPACK_IMPORTED_MODULE_4__.TypedArray1d(5, null);\n            }\n            this.op[code - 30] = dat.gjstr;\n            if (this.op[code - 30]?.toLowerCase() === 'hidden') {\n                this.op[code - 30] = null;\n            }\n        }\n        else if (code === 40) {\n            const count = dat.g1;\n            this.recol_s = new Uint16Array(count);\n            this.recol_d = new Uint16Array(count);\n            for (let i = 0; i < count; i++) {\n                this.recol_s[i] = dat.g2;\n                this.recol_d[i] = dat.g2;\n            }\n        }\n        else if (code === 60) {\n            const count = dat.g1;\n            this.heads = new Uint16Array(count);\n            for (let i = 0; i < count; i++) {\n                this.heads[i] = dat.g2;\n            }\n        }\n        else if (code === 90) {\n            this.resizex = dat.g2;\n        }\n        else if (code === 91) {\n            this.resizey = dat.g2;\n        }\n        else if (code === 92) {\n            this.resizez = dat.g2;\n        }\n        else if (code === 93) {\n            this.minimap = false;\n        }\n        else if (code === 95) {\n            this.vislevel = dat.g2;\n        }\n        else if (code === 97) {\n            this.resizeh = dat.g2;\n        }\n        else if (code === 98) {\n            this.resizev = dat.g2;\n        }\n    }\n    getSequencedModel(primaryTransformId, secondaryTransformId, seqMask) {\n        let tmp = null;\n        let model = null;\n        if (NpcType.modelCache) {\n            model = NpcType.modelCache.get(BigInt(this.id));\n            if (!model && this.models) {\n                const models = new _util_Arrays__WEBPACK_IMPORTED_MODULE_4__.TypedArray1d(this.models.length, null);\n                for (let i = 0; i < this.models.length; i++) {\n                    models[i] = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].model(this.models[i]);\n                }\n                if (models.length === 1) {\n                    model = models[0];\n                }\n                else {\n                    model = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].modelFromModels(models, models.length);\n                }\n                if (this.recol_s && this.recol_d) {\n                    for (let i = 0; i < this.recol_s.length; i++) {\n                        model?.recolor(this.recol_s[i], this.recol_d[i]);\n                    }\n                }\n                model?.createLabelReferences();\n                model?.calculateNormals(64, 850, -30, -50, -30, true);\n                if (model) {\n                    NpcType.modelCache.put(BigInt(this.id), model);\n                }\n            }\n        }\n        if (model) {\n            tmp = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].modelShareAlpha(model, !this.disposeAlpha);\n            if (primaryTransformId !== -1 && secondaryTransformId !== -1) {\n                tmp.applyTransforms(primaryTransformId, secondaryTransformId, seqMask);\n            }\n            else if (primaryTransformId !== -1) {\n                tmp.applyTransform(primaryTransformId);\n            }\n            if (this.resizeh !== 128 || this.resizev !== 128) {\n                tmp.scale(this.resizeh, this.resizev, this.resizeh);\n            }\n            tmp.calculateBoundsCylinder();\n            tmp.labelFaces = null;\n            tmp.labelVertices = null;\n            if (this.size === 1) {\n                tmp.pickable = true;\n            }\n            return tmp;\n        }\n        return null;\n    }\n    getHeadModel() {\n        if (!this.heads) {\n            return null;\n        }\n        const models = new _util_Arrays__WEBPACK_IMPORTED_MODULE_4__.TypedArray1d(this.heads.length, null);\n        for (let i = 0; i < this.heads.length; i++) {\n            models[i] = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].model(this.heads[i]);\n        }\n        let model;\n        if (models.length === 1) {\n            model = models[0];\n        }\n        else {\n            model = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].modelFromModels(models, models.length);\n        }\n        if (this.recol_s && this.recol_d) {\n            for (let i = 0; i < this.recol_s.length; i++) {\n                model?.recolor(this.recol_s[i], this.recol_d[i]);\n            }\n        }\n        return model;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/NpcType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/ObjType.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/config/ObjType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ObjType)\n/* harmony export */ });\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _graphics_Pix24__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graphics/Pix24 */ \"./src/js/jagex2/graphics/Pix24.ts\");\n/* harmony import */ var _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../datastruct/LruCache */ \"./src/js/jagex2/datastruct/LruCache.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../graphics/Draw3D */ \"./src/js/jagex2/graphics/Draw3D.ts\");\n/* harmony import */ var _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../graphics/Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _graphics_Colors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../graphics/Colors */ \"./src/js/jagex2/graphics/Colors.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n\n\n\n\n\n\nclass ObjType extends _ConfigType__WEBPACK_IMPORTED_MODULE_0__.ConfigType {\n    static count = 0;\n    static cache = null;\n    static dat = null;\n    static offsets = null;\n    static cachePos = 0;\n    static membersWorld = true;\n    static modelCache = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_3__[\"default\"](50);\n    static iconCache = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_3__[\"default\"](200);\n    static unpack = (config, members) => {\n        this.membersWorld = members;\n        this.dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('obj.dat'));\n        const idx = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('obj.idx'));\n        this.count = idx.g2;\n        this.offsets = new Int32Array(this.count);\n        let offset = 2;\n        for (let id = 0; id < this.count; id++) {\n            this.offsets[id] = offset;\n            offset += idx.g2;\n        }\n        this.cache = new _util_Arrays__WEBPACK_IMPORTED_MODULE_8__.TypedArray1d(10, null);\n        for (let id = 0; id < 10; id++) {\n            this.cache[id] = new ObjType(-1);\n        }\n    };\n    static get = (id) => {\n        if (!this.cache || !this.offsets || !this.dat) {\n            throw new Error('ObjType not loaded!!!');\n        }\n        for (let i = 0; i < 10; i++) {\n            const type = this.cache[i];\n            if (!type) {\n                continue;\n            }\n            if (type.id === id) {\n                return type;\n            }\n        }\n        this.cachePos = (this.cachePos + 1) % 10;\n        const obj = this.cache[this.cachePos];\n        this.dat.pos = this.offsets[id];\n        obj.id = id;\n        obj.reset();\n        obj.decodeType(this.dat);\n        if (obj.certtemplate !== -1) {\n            obj.toCertificate();\n        }\n        if (!this.membersWorld && obj.members) {\n            obj.name = 'Members Object';\n            obj.desc = \"Login to a members' server to use this object.\";\n            obj.op = null;\n            obj.iop = null;\n        }\n        return obj;\n    };\n    static unload = () => {\n        this.modelCache = null;\n        this.iconCache = null;\n        this.offsets = null;\n        this.cache = null;\n        this.dat = null;\n    };\n    static getIcon = (id, count) => {\n        if (ObjType.iconCache) {\n            let icon = ObjType.iconCache.get(BigInt(id));\n            if (icon && icon.cropH !== count && icon.cropH !== -1) {\n                icon.unlink();\n                icon = null;\n            }\n            if (icon) {\n                return icon;\n            }\n        }\n        let obj = ObjType.get(id);\n        if (!obj.countobj) {\n            count = -1;\n        }\n        if (obj.countobj && obj.countco && count > 1) {\n            let countobj = -1;\n            for (let i = 0; i < 10; i++) {\n                if (count >= obj.countco[i] && obj.countco[i] !== 0) {\n                    countobj = obj.countobj[i];\n                }\n            }\n            if (countobj !== -1) {\n                obj = ObjType.get(countobj);\n            }\n        }\n        const icon = new _graphics_Pix24__WEBPACK_IMPORTED_MODULE_2__[\"default\"](32, 32);\n        const _cx = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].centerX;\n        const _cy = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].centerY;\n        const _loff = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].lineOffset;\n        const _data = _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].pixels;\n        const _w = _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].width2d;\n        const _h = _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].height2d;\n        const _l = _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].left;\n        const _r = _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].right;\n        const _t = _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].top;\n        const _b = _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].bottom;\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].jagged = false;\n        _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].bind(icon.pixels, 32, 32);\n        _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fillRect(0, 0, 32, 32, _graphics_Colors__WEBPACK_IMPORTED_MODULE_7__[\"default\"].BLACK);\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].init2D();\n        const iModel = obj.getInterfaceModel(1);\n        const sinPitch = (_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].sin[obj.xan2d] * obj.zoom2d) >> 16;\n        const cosPitch = (_graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].cos[obj.xan2d] * obj.zoom2d) >> 16;\n        iModel.drawSimple(0, obj.yan2d, obj.zan2d, obj.xan2d, obj.xof2d, sinPitch + ((iModel.maxY / 2) | 0) + obj.yof2d, cosPitch + obj.yof2d);\n        // draw outline\n        for (let x = 31; x >= 0; x--) {\n            for (let y = 31; y >= 0; y--) {\n                if (icon.pixels[x + y * 32] !== 0) {\n                    continue;\n                }\n                if (x > 0 && icon.pixels[x + y * 32 - 1] > 1) {\n                    icon.pixels[x + y * 32] = 1;\n                }\n                else if (y > 0 && icon.pixels[x + (y - 1) * 32] > 1) {\n                    icon.pixels[x + y * 32] = 1;\n                }\n                else if (x < 31 && icon.pixels[x + y * 32 + 1] > 1) {\n                    icon.pixels[x + y * 32] = 1;\n                }\n                else if (y < 31 && icon.pixels[x + (y + 1) * 32] > 1) {\n                    icon.pixels[x + y * 32] = 1;\n                }\n            }\n        }\n        // draw shadow\n        for (let x = 31; x >= 0; x--) {\n            for (let y = 31; y >= 0; y--) {\n                if (icon.pixels[x + y * 32] === 0 && x > 0 && y > 0 && icon.pixels[x + (y - 1) * 32 - 1] > 0) {\n                    icon.pixels[x + y * 32] = 3153952;\n                }\n            }\n        }\n        if (obj.certtemplate !== -1) {\n            const linkedIcon = this.getIcon(obj.certlink, 10);\n            const w = linkedIcon.cropW;\n            const h = linkedIcon.cropH;\n            linkedIcon.cropW = 32;\n            linkedIcon.cropH = 32;\n            linkedIcon.crop(5, 5, 22, 22);\n            linkedIcon.cropW = w;\n            linkedIcon.cropH = h;\n        }\n        ObjType.iconCache?.put(BigInt(id), icon);\n        _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].bind(_data, _w, _h);\n        _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setBounds(_l, _t, _r, _b);\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].centerX = _cx;\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].centerY = _cy;\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].lineOffset = _loff;\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_5__[\"default\"].jagged = true;\n        if (obj.stackable) {\n            icon.cropW = 33;\n        }\n        else {\n            icon.cropW = 32;\n        }\n        icon.cropH = count;\n        return icon;\n    };\n    // ----\n    model = 0;\n    name = null;\n    desc = null;\n    recol_s = null;\n    recol_d = null;\n    zoom2d = 2000;\n    xan2d = 0;\n    yan2d = 0;\n    zan2d = 0;\n    xof2d = 0;\n    yof2d = 0;\n    code9 = false;\n    code10 = -1;\n    stackable = false;\n    cost = 1;\n    members = false;\n    op = null;\n    iop = null;\n    manwear = -1;\n    manwear2 = -1;\n    manwearOffsetY = 0;\n    womanwear = -1;\n    womanwear2 = -1;\n    womanwearOffsetY = 0;\n    manwear3 = -1;\n    womanwear3 = -1;\n    manhead = -1;\n    manhead2 = -1;\n    womanhead = -1;\n    womanhead2 = -1;\n    countobj = null;\n    countco = null;\n    certlink = -1;\n    certtemplate = -1;\n    decode(code, dat) {\n        if (code === 1) {\n            this.model = dat.g2;\n        }\n        else if (code === 2) {\n            this.name = dat.gjstr;\n        }\n        else if (code === 3) {\n            this.desc = dat.gjstr;\n        }\n        else if (code === 4) {\n            this.zoom2d = dat.g2;\n        }\n        else if (code === 5) {\n            this.xan2d = dat.g2;\n        }\n        else if (code === 6) {\n            this.yan2d = dat.g2;\n        }\n        else if (code === 7) {\n            this.xof2d = dat.g2b;\n            if (this.xof2d > 32767) {\n                this.xof2d -= 65536;\n            }\n        }\n        else if (code === 8) {\n            this.yof2d = dat.g2b;\n            if (this.yof2d > 32767) {\n                this.yof2d -= 65536;\n            }\n        }\n        else if (code === 9) {\n            this.code9 = true;\n        }\n        else if (code === 10) {\n            this.code10 = dat.g2;\n        }\n        else if (code === 11) {\n            this.stackable = true;\n        }\n        else if (code === 12) {\n            this.cost = dat.g4;\n        }\n        else if (code === 16) {\n            this.members = true;\n        }\n        else if (code === 23) {\n            this.manwear = dat.g2;\n            this.manwearOffsetY = dat.g1b;\n        }\n        else if (code === 24) {\n            this.manwear2 = dat.g2;\n        }\n        else if (code === 25) {\n            this.womanwear = dat.g2;\n            this.womanwearOffsetY = dat.g1b;\n        }\n        else if (code === 26) {\n            this.womanwear2 = dat.g2;\n        }\n        else if (code >= 30 && code < 35) {\n            if (!this.op) {\n                this.op = new _util_Arrays__WEBPACK_IMPORTED_MODULE_8__.TypedArray1d(5, null);\n            }\n            this.op[code - 30] = dat.gjstr;\n            if (this.op[code - 30]?.toLowerCase() === 'hidden') {\n                this.op[code - 30] = null;\n            }\n        }\n        else if (code >= 35 && code < 40) {\n            if (!this.iop) {\n                this.iop = new _util_Arrays__WEBPACK_IMPORTED_MODULE_8__.TypedArray1d(5, null);\n            }\n            this.iop[code - 35] = dat.gjstr;\n        }\n        else if (code === 40) {\n            const count = dat.g1;\n            this.recol_s = new Uint16Array(count);\n            this.recol_d = new Uint16Array(count);\n            for (let i = 0; i < count; i++) {\n                this.recol_s[i] = dat.g2;\n                this.recol_d[i] = dat.g2;\n            }\n        }\n        else if (code === 78) {\n            this.manwear3 = dat.g2;\n        }\n        else if (code === 79) {\n            this.womanwear3 = dat.g2;\n        }\n        else if (code === 90) {\n            this.manhead = dat.g2;\n        }\n        else if (code === 91) {\n            this.womanhead = dat.g2;\n        }\n        else if (code === 92) {\n            this.manhead2 = dat.g2;\n        }\n        else if (code === 93) {\n            this.womanhead2 = dat.g2;\n        }\n        else if (code === 95) {\n            this.zan2d = dat.g2;\n        }\n        else if (code === 97) {\n            this.certlink = dat.g2;\n        }\n        else if (code === 98) {\n            this.certtemplate = dat.g2;\n        }\n        else if (code >= 100 && code < 110) {\n            if (!this.countobj || !this.countco) {\n                this.countobj = new Uint16Array(10);\n                this.countco = new Uint16Array(10);\n            }\n            this.countobj[code - 100] = dat.g2;\n            this.countco[code - 100] = dat.g2;\n        }\n    }\n    getWornModel(gender) {\n        let id1 = this.manwear;\n        if (gender === 1) {\n            id1 = this.womanwear;\n        }\n        if (id1 === -1) {\n            return null;\n        }\n        let id2 = this.manwear2;\n        let id3 = this.manwear3;\n        if (gender === 1) {\n            id2 = this.womanwear2;\n            id3 = this.womanwear3;\n        }\n        let model = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].model(id1);\n        if (id2 !== -1) {\n            const model2 = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].model(id2);\n            if (id3 === -1) {\n                const models = [model, model2];\n                model = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].modelFromModels(models, 2);\n            }\n            else {\n                const model3 = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].model(id3);\n                const models = [model, model2, model3];\n                model = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].modelFromModels(models, 3);\n            }\n        }\n        if (gender === 0 && this.manwearOffsetY !== 0) {\n            model.translate(this.manwearOffsetY, 0, 0);\n        }\n        if (gender === 1 && this.womanwearOffsetY !== 0) {\n            model.translate(this.womanwearOffsetY, 0, 0);\n        }\n        if (this.recol_s && this.recol_d) {\n            for (let i = 0; i < this.recol_s.length; i++) {\n                model.recolor(this.recol_s[i], this.recol_d[i]);\n            }\n        }\n        return model;\n    }\n    getHeadModel(gender) {\n        let head1 = this.manhead;\n        if (gender === 1) {\n            head1 = this.womanhead;\n        }\n        if (head1 === -1) {\n            return null;\n        }\n        let head2 = this.manhead2;\n        if (gender === 1) {\n            head2 = this.womanhead2;\n        }\n        let model = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].model(head1);\n        if (head2 !== -1) {\n            const model2 = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].model(head2);\n            const models = [model, model2];\n            model = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].modelFromModels(models, 2);\n        }\n        if (this.recol_s && this.recol_d) {\n            for (let i = 0; i < this.recol_s.length; i++) {\n                model.recolor(this.recol_s[i], this.recol_d[i]);\n            }\n        }\n        return model;\n    }\n    getInterfaceModel(count) {\n        if (this.countobj && this.countco && count > 1) {\n            let id = -1;\n            for (let i = 0; i < 10; i++) {\n                if (count >= this.countco[i] && this.countco[i] !== 0) {\n                    id = this.countobj[i];\n                }\n            }\n            if (id !== -1) {\n                return ObjType.get(id).getInterfaceModel(1);\n            }\n        }\n        if (ObjType.modelCache) {\n            const model = ObjType.modelCache.get(BigInt(this.id));\n            if (model) {\n                return model;\n            }\n        }\n        const model = _graphics_Model__WEBPACK_IMPORTED_MODULE_4__[\"default\"].model(this.model);\n        if (this.recol_s && this.recol_d) {\n            for (let i = 0; i < this.recol_s.length; i++) {\n                model.recolor(this.recol_s[i], this.recol_d[i]);\n            }\n        }\n        model.calculateNormals(64, 768, -50, -10, -50, true);\n        model.pickable = true;\n        ObjType.modelCache?.put(BigInt(this.id), model);\n        return model;\n    }\n    toCertificate() {\n        const template = ObjType.get(this.certtemplate);\n        this.model = template.model;\n        this.zoom2d = template.zoom2d;\n        this.xan2d = template.xan2d;\n        this.yan2d = template.yan2d;\n        this.zan2d = template.zan2d;\n        this.xof2d = template.xof2d;\n        this.yof2d = template.yof2d;\n        this.recol_s = template.recol_s;\n        this.recol_d = template.recol_d;\n        const link = ObjType.get(this.certlink);\n        this.name = link.name;\n        this.members = link.members;\n        this.cost = link.cost;\n        let article = 'a';\n        const c = (link.name || '').toLowerCase().charAt(0);\n        if (c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u') {\n            article = 'an';\n        }\n        this.desc = `Swap this note at any bank for ${article} ${link.name}.`;\n        this.stackable = true;\n    }\n    reset() {\n        this.model = 0;\n        this.name = null;\n        this.desc = null;\n        this.recol_s = null;\n        this.recol_d = null;\n        this.zoom2d = 2000;\n        this.xan2d = 0;\n        this.yan2d = 0;\n        this.zan2d = 0;\n        this.xof2d = 0;\n        this.yof2d = 0;\n        this.code9 = false;\n        this.code10 = -1;\n        this.stackable = false;\n        this.cost = 1;\n        this.members = false;\n        this.op = null;\n        this.iop = null;\n        this.manwear = -1;\n        this.manwear2 = -1;\n        this.manwearOffsetY = 0;\n        this.womanwear = -1;\n        this.womanwear2 = -1;\n        this.womanwearOffsetY = 0;\n        this.manwear3 = -1;\n        this.womanwear3 = -1;\n        this.manhead = -1;\n        this.manhead2 = -1;\n        this.womanhead = -1;\n        this.womanhead2 = -1;\n        this.countobj = null;\n        this.countco = null;\n        this.certlink = -1;\n        this.certtemplate = -1;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/ObjType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/SeqType.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/config/SeqType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SeqType)\n/* harmony export */ });\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _graphics_AnimFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graphics/AnimFrame */ \"./src/js/jagex2/graphics/AnimFrame.ts\");\n\n\n\nclass SeqType extends _ConfigType__WEBPACK_IMPORTED_MODULE_0__.ConfigType {\n    static count = 0;\n    static instances = [];\n    static unpack = (config) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('seq.dat'));\n        this.count = dat.g2;\n        for (let i = 0; i < this.count; i++) {\n            const seq = new SeqType(i).decodeType(dat);\n            if (seq.frameCount === 0) {\n                seq.frameCount = 1;\n                seq.frames = new Int16Array(1);\n                seq.frames[0] = -1;\n                seq.iframes = new Int16Array(1);\n                seq.iframes[0] = -1;\n                seq.delay = new Int16Array(1);\n                seq.delay[0] = -1;\n            }\n            this.instances[i] = seq;\n        }\n    };\n    // ----\n    frameCount = 0;\n    frames = null;\n    iframes = null;\n    delay = null;\n    replayoff = -1;\n    walkmerge = null;\n    stretches = false;\n    priority = 5;\n    righthand = -1;\n    lefthand = -1;\n    replaycount = 99;\n    duration = 0;\n    decode(code, dat) {\n        if (code === 1) {\n            this.frameCount = dat.g1;\n            this.frames = new Int16Array(this.frameCount);\n            this.iframes = new Int16Array(this.frameCount);\n            this.delay = new Int16Array(this.frameCount);\n            for (let i = 0; i < this.frameCount; i++) {\n                this.frames[i] = dat.g2;\n                this.iframes[i] = dat.g2;\n                if (this.iframes[i] === 65535) {\n                    this.iframes[i] = -1;\n                }\n                this.delay[i] = dat.g2;\n                if (this.delay[i] === 0) {\n                    this.delay[i] = _graphics_AnimFrame__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instances[this.frames[i]].delay;\n                }\n                if (this.delay[i] === 0) {\n                    this.delay[i] = 1;\n                }\n                this.duration += this.delay[i];\n            }\n        }\n        else if (code === 2) {\n            this.replayoff = dat.g2;\n        }\n        else if (code === 3) {\n            const count = dat.g1;\n            this.walkmerge = new Int32Array(count + 1);\n            for (let i = 0; i < count; i++) {\n                this.walkmerge[i] = dat.g1;\n            }\n            this.walkmerge[count] = 9999999;\n        }\n        else if (code === 4) {\n            this.stretches = true;\n        }\n        else if (code === 5) {\n            this.priority = dat.g1;\n        }\n        else if (code === 6) {\n            // later RS (think RS3) this becomes mainhand\n            this.righthand = dat.g2;\n        }\n        else if (code === 7) {\n            // later RS (think RS3) this becomes offhand\n            this.lefthand = dat.g2;\n        }\n        else if (code === 8) {\n            this.replaycount = dat.g1;\n        }\n        else {\n            throw new Error(`Unrecognized seq config code: ${code}`);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/SeqType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/SpotAnimType.ts":
/*!**********************************************!*\
  !*** ./src/js/jagex2/config/SpotAnimType.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SpotAnimType)\n/* harmony export */ });\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _SeqType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SeqType */ \"./src/js/jagex2/config/SeqType.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datastruct/LruCache */ \"./src/js/jagex2/datastruct/LruCache.ts\");\n\n\n\n\n\nclass SpotAnimType extends _ConfigType__WEBPACK_IMPORTED_MODULE_0__.ConfigType {\n    static count = 0;\n    static instances = [];\n    static modelCache = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_4__[\"default\"](30);\n    static unpack = (config) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('spotanim.dat'));\n        this.count = dat.g2;\n        for (let i = 0; i < this.count; i++) {\n            this.instances[i] = new SpotAnimType(i).decodeType(dat);\n        }\n    };\n    // ----\n    model = 0;\n    anim = -1;\n    seq = null;\n    disposeAlpha = false;\n    recol_s = new Uint16Array(6);\n    recol_d = new Uint16Array(6);\n    resizeh = 128;\n    resizev = 128;\n    orientation = 0;\n    ambient = 0;\n    contrast = 0;\n    decode(code, dat) {\n        if (code === 1) {\n            this.model = dat.g2;\n        }\n        else if (code === 2) {\n            this.anim = dat.g2;\n            if (_SeqType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instances) {\n                this.seq = _SeqType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instances[this.anim];\n            }\n        }\n        else if (code === 3) {\n            this.disposeAlpha = true;\n        }\n        else if (code === 4) {\n            this.resizeh = dat.g2;\n        }\n        else if (code === 5) {\n            this.resizev = dat.g2;\n        }\n        else if (code === 6) {\n            this.orientation = dat.g2;\n        }\n        else if (code === 7) {\n            this.ambient = dat.g1;\n        }\n        else if (code === 8) {\n            this.contrast = dat.g1;\n        }\n        else if (code >= 40 && code < 50) {\n            this.recol_s[code - 40] = dat.g2;\n        }\n        else if (code >= 50 && code < 60) {\n            this.recol_d[code - 50] = dat.g2;\n        }\n        else {\n            throw new Error(`Unrecognized spotanim config code: ${code}`);\n        }\n    }\n    getModel() {\n        let model = SpotAnimType.modelCache?.get(BigInt(this.id));\n        if (model) {\n            return model;\n        }\n        model = _graphics_Model__WEBPACK_IMPORTED_MODULE_3__[\"default\"].model(this.model);\n        for (let i = 0; i < 6; i++) {\n            if (this.recol_s[0] !== 0) {\n                model.recolor(this.recol_s[i], this.recol_d[i]);\n            }\n        }\n        SpotAnimType.modelCache?.put(BigInt(this.id), model);\n        return model;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/SpotAnimType.ts?");

/***/ }),

/***/ "./src/js/jagex2/config/VarpType.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/config/VarpType.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VarpType)\n/* harmony export */ });\n/* harmony import */ var _ConfigType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigType */ \"./src/js/jagex2/config/ConfigType.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n\n\nclass VarpType extends _ConfigType__WEBPACK_IMPORTED_MODULE_0__.ConfigType {\n    static count = 0;\n    static instances = [];\n    static code3 = [];\n    static code3Count = 0;\n    static unpack = (config) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config.read('varp.dat'));\n        this.count = dat.g2;\n        for (let i = 0; i < this.count; i++) {\n            this.instances[i] = new VarpType(i).decodeType(dat);\n        }\n    };\n    // ----\n    scope = 0;\n    type = 0;\n    code3 = false;\n    protect = true;\n    clientcode = 0;\n    code7 = 0;\n    transmit = false;\n    code8 = false;\n    decode(code, dat) {\n        if (code === 1) {\n            this.scope = dat.g1;\n        }\n        else if (code === 2) {\n            this.type = dat.g1;\n        }\n        else if (code === 3) {\n            this.code3 = true;\n            VarpType.code3[VarpType.code3Count++] = this.id;\n        }\n        else if (code === 4) {\n            this.protect = false;\n        }\n        else if (code === 5) {\n            this.clientcode = dat.g2;\n        }\n        else if (code === 6) {\n            this.transmit = true;\n        }\n        else if (code === 7) {\n            this.code7 = dat.g4;\n        }\n        else if (code === 8) {\n            this.code8 = true;\n        }\n        else if (code === 10) {\n            this.debugname = dat.gjstr;\n        }\n        else {\n            throw new Error(`Error unrecognised config code: ${code}`);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/config/VarpType.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/CollisionFlag.ts":
/*!***********************************************!*\
  !*** ./src/js/jagex2/dash3d/CollisionFlag.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollisionFlag)\n/* harmony export */ });\nclass CollisionFlag {\n    static OPEN = 0x0;\n    static WALL_NORTH_WEST = 0x1;\n    static WALL_NORTH = 0x2;\n    static WALL_NORTH_EAST = 0x4;\n    static WALL_EAST = 0x8;\n    static WALL_SOUTH_EAST = CollisionFlag.WALL_NORTH_WEST << 4; // 16 0x10\n    static WALL_SOUTH = CollisionFlag.WALL_NORTH << 4; // 32 0x20\n    static WALL_SOUTH_WEST = CollisionFlag.WALL_NORTH_EAST << 4; // 64 0x40\n    static WALL_WEST = CollisionFlag.WALL_EAST << 4; // 128 0x80\n    static LOC = 0x100; // 256\n    static WALL_NORTH_WEST_PROJ_BLOCKER = 0x200; // 512\n    static WALL_NORTH_PROJ_BLOCKER = 0x400; // 1024\n    static WALL_NORTH_EAST_PROJ_BLOCKER = 0x800; // 2048\n    static WALL_EAST_PROJ_BLOCKER = 0x1000; // 4096\n    static WALL_SOUTH_EAST_PROJ_BLOCKER = CollisionFlag.WALL_NORTH_WEST_PROJ_BLOCKER << 4; // 8192 0x2000\n    static WALL_SOUTH_PROJ_BLOCKER = CollisionFlag.WALL_NORTH_PROJ_BLOCKER << 4; // 16384 0x4000\n    static WALL_SOUTH_WEST_PROJ_BLOCKER = CollisionFlag.WALL_NORTH_EAST_PROJ_BLOCKER << 4; // 32768 0x8000\n    static WALL_WEST_PROJ_BLOCKER = CollisionFlag.WALL_EAST_PROJ_BLOCKER << 4; // 65536 0x10000\n    static LOC_PROJ_BLOCKER = CollisionFlag.LOC << 9; // 131072 0x20000\n    static ANTIMACRO = 0x80000; // 524288\n    static FLOOR = 0x200000; // 2097152\n    static FLOOR_BLOCKED = CollisionFlag.FLOOR | CollisionFlag.ANTIMACRO; // 2621440 0x280000\n    static WALK_BLOCKED = CollisionFlag.LOC | CollisionFlag.FLOOR_BLOCKED; // 2621696 0x280100\n    static BLOCK_SOUTH = CollisionFlag.WALL_NORTH | CollisionFlag.WALK_BLOCKED; // 2621698 0x280102\n    static BLOCK_WEST = CollisionFlag.WALL_EAST | CollisionFlag.WALK_BLOCKED; // 2621704 0x280108\n    static BLOCK_SOUTH_WEST = CollisionFlag.WALL_NORTH | CollisionFlag.WALL_NORTH_EAST | CollisionFlag.BLOCK_WEST; // 2621710 0x28010E\n    static BLOCK_NORTH = CollisionFlag.WALL_SOUTH | CollisionFlag.WALK_BLOCKED; // 2621728 0x280120\n    static BLOCK_NORTH_WEST = CollisionFlag.WALL_EAST | CollisionFlag.WALL_SOUTH_EAST | CollisionFlag.BLOCK_NORTH; // 2621752 0x280138\n    static BLOCK_EAST = CollisionFlag.WALL_WEST | CollisionFlag.WALK_BLOCKED; // 2621824 0x280180\n    static BLOCK_SOUTH_EAST = CollisionFlag.WALL_NORTH_WEST | CollisionFlag.WALL_NORTH | CollisionFlag.BLOCK_EAST; // 2621827 0x280183\n    static BLOCK_NORTH_EAST = CollisionFlag.WALL_SOUTH | CollisionFlag.WALL_SOUTH_WEST | CollisionFlag.BLOCK_EAST; // 2621920 0x2801E0\n    static BOUNDS = 0xffffff; // 16777215\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/CollisionFlag.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/CollisionMap.ts":
/*!**********************************************!*\
  !*** ./src/js/jagex2/dash3d/CollisionMap.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollisionMap)\n/* harmony export */ });\n/* harmony import */ var _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CollisionFlag */ \"./src/js/jagex2/dash3d/CollisionFlag.ts\");\n/* harmony import */ var _LocAngle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LocAngle */ \"./src/js/jagex2/dash3d/LocAngle.ts\");\n/* harmony import */ var _LocShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocShape */ \"./src/js/jagex2/dash3d/LocShape.ts\");\n/* harmony import */ var _DirectionFlag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DirectionFlag */ \"./src/js/jagex2/dash3d/DirectionFlag.ts\");\n\n\n\n\nclass CollisionMap {\n    static LEVELS = 4;\n    static SIZE = 104;\n    static index = (x, z) => x * CollisionMap.SIZE + z;\n    // constructor\n    offsetX;\n    offsetZ;\n    sizeX;\n    sizeZ;\n    flags;\n    constructor() {\n        this.offsetX = 0;\n        this.offsetZ = 0;\n        this.sizeX = CollisionMap.SIZE;\n        this.sizeZ = CollisionMap.SIZE;\n        this.flags = new Int32Array(this.sizeX * this.sizeZ);\n        this.reset();\n    }\n    reset = () => {\n        for (let x = 0; x < this.sizeX; x++) {\n            for (let z = 0; z < this.sizeZ; z++) {\n                const index = CollisionMap.index(x, z);\n                if (x === 0 || z === 0 || x === this.sizeX - 1 || z === this.sizeZ - 1) {\n                    this.flags[index] = _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BOUNDS;\n                }\n                else {\n                    this.flags[index] = _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN;\n                }\n            }\n        }\n    };\n    addFloor = (tileX, tileZ) => {\n        this.flags[CollisionMap.index(tileX - this.offsetX, tileZ - this.offsetZ)] |= _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].FLOOR;\n    };\n    removeFloor = (tileX, tileZ) => {\n        this.flags[CollisionMap.index(tileX - this.offsetX, tileZ - this.offsetZ)] &= ~_CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].FLOOR;\n    };\n    addLoc = (tileX, tileZ, sizeX, sizeZ, angle, blockrange) => {\n        let flags = _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOC;\n        if (blockrange) {\n            flags |= _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOC_PROJ_BLOCKER;\n        }\n        const x = tileX - this.offsetX;\n        const z = tileZ - this.offsetZ;\n        if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n            // north or south\n            const tmp = sizeX;\n            sizeX = sizeZ;\n            sizeZ = tmp;\n        }\n        for (let tx = x; tx < x + sizeX; tx++) {\n            if (!(tx >= 0 && tx < this.sizeX)) {\n                continue;\n            }\n            for (let tz = z; tz < z + sizeZ; tz++) {\n                if (!(tz >= 0 && tz < this.sizeZ)) {\n                    continue;\n                }\n                this.add(tx, tz, flags);\n            }\n        }\n    };\n    removeLoc = (tileX, tileZ, sizeX, sizeZ, angle, blockrange) => {\n        let flags = _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOC;\n        if (blockrange) {\n            flags |= _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LOC_PROJ_BLOCKER;\n        }\n        const x = tileX - this.offsetX;\n        const z = tileZ - this.offsetZ;\n        if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n            const tmp = sizeX;\n            sizeX = sizeZ;\n            sizeZ = tmp;\n        }\n        for (let tx = x; tx < x + sizeX; tx++) {\n            if (!(tx >= 0 && tx < this.sizeX)) {\n                continue;\n            }\n            for (let tz = z; tz < z + sizeZ; tz++) {\n                if (!(tz >= 0 && tz < this.sizeZ)) {\n                    continue;\n                }\n                this.remove(tx, tz, flags);\n            }\n        }\n    };\n    addWall = (tileX, tileZ, shape, angle, blockrange) => {\n        const x = tileX - this.offsetX;\n        const z = tileZ - this.offsetZ;\n        const west = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST;\n        const east = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST;\n        const north = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH;\n        const south = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH;\n        const northWest = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_WEST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_WEST;\n        const southEast = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_EAST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_EAST;\n        const northEast = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_EAST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_EAST;\n        const southWest = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_WEST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_WEST;\n        if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_STRAIGHT.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                this.add(x, z, west);\n                this.add(x - 1, z, east);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                this.add(x, z, north);\n                this.add(x, z + 1, south);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                this.add(x, z, east);\n                this.add(x + 1, z, west);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                this.add(x, z, south);\n                this.add(x, z - 1, north);\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_DIAGONAL_CORNER.id || shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_SQUARE_CORNER.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                this.add(x, z, northWest);\n                this.add(x - 1, z + 1, southEast);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                this.add(x, z, northEast);\n                this.add(x + 1, z + 1, southWest);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                this.add(x, z, southEast);\n                this.add(x + 1, z - 1, northWest);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                this.add(x, z, southWest);\n                this.add(x - 1, z - 1, northEast);\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_L.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                this.add(x, z, north | west);\n                this.add(x - 1, z, east);\n                this.add(x, z + 1, south);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                this.add(x, z, north | east);\n                this.add(x, z + 1, south);\n                this.add(x + 1, z, west);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                this.add(x, z, south | east);\n                this.add(x + 1, z, west);\n                this.add(x, z - 1, north);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                this.add(x, z, south | west);\n                this.add(x, z - 1, north);\n                this.add(x - 1, z, east);\n            }\n        }\n        if (blockrange) {\n            this.addWall(tileX, tileZ, shape, angle, false);\n        }\n    };\n    removeWall = (tileX, tileZ, shape, angle, blockrange) => {\n        const x = tileX - this.offsetX;\n        const z = tileZ - this.offsetZ;\n        const west = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST;\n        const east = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST;\n        const north = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH;\n        const south = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH;\n        const northWest = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_WEST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_WEST;\n        const southEast = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_EAST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_EAST;\n        const northEast = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_EAST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH_EAST;\n        const southWest = blockrange ? _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_WEST_PROJ_BLOCKER : _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH_WEST;\n        if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_STRAIGHT.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                this.remove(x, z, west);\n                this.remove(x - 1, z, east);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                this.remove(x, z, north);\n                this.remove(x, z + 1, south);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                this.remove(x, z, east);\n                this.remove(x + 1, z, west);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                this.remove(x, z, south);\n                this.remove(x, z - 1, north);\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_DIAGONAL_CORNER.id || shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_SQUARE_CORNER.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                this.remove(x, z, northWest);\n                this.remove(x - 1, z + 1, southEast);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                this.remove(x, z, northEast);\n                this.remove(x + 1, z + 1, southWest);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                this.remove(x, z, southEast);\n                this.remove(x + 1, z - 1, northWest);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                this.remove(x, z, southWest);\n                this.remove(x - 1, z - 1, northEast);\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_L.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                this.remove(x, z, north | west);\n                this.remove(x - 1, z, east);\n                this.remove(x, z + 1, south);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                this.remove(x, z, north | east);\n                this.remove(x, z + 1, south);\n                this.remove(x + 1, z, west);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                this.remove(x, z, south | east);\n                this.remove(x + 1, z, west);\n                this.remove(x, z - 1, north);\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                this.remove(x, z, south | west);\n                this.remove(x, z - 1, north);\n                this.remove(x - 1, z, east);\n            }\n        }\n        if (blockrange) {\n            this.removeWall(tileX, tileZ, shape, angle, false);\n        }\n    };\n    reachedWall = (sourceX, sourceZ, destX, destZ, shape, angle) => {\n        if (sourceX === destX && sourceZ === destZ) {\n            return true;\n        }\n        const sx = sourceX - this.offsetX;\n        const sz = sourceZ - this.offsetZ;\n        const dx = destX - this.offsetX;\n        const dz = destZ - this.offsetZ;\n        const index = CollisionMap.index(sx, sz);\n        if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_STRAIGHT.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                if (sx === dx - 1 && sz === dz) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                if (sx === dx && sz === dz + 1) {\n                    return true;\n                }\n                else if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                if (sx === dx + 1 && sz === dz) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                if (sx === dx && sz === dz - 1) {\n                    return true;\n                }\n                else if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_L.id) {\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                if (sx === dx - 1 && sz === dz) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1) {\n                    return true;\n                }\n                else if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1) {\n                    return true;\n                }\n                else if (sx === dx + 1 && sz === dz) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx + 1 && sz === dz) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                if (sx === dx - 1 && sz === dz) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BLOCK_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1) {\n                    return true;\n                }\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALL_DIAGONAL.id) {\n            if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n            else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n            else if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n            else if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n        }\n        return false;\n    };\n    reachedWallDecoration = (sourceX, sourceZ, destX, destZ, shape, angle) => {\n        if (sourceX === destX && sourceZ === destZ) {\n            return true;\n        }\n        const sx = sourceX - this.offsetX;\n        const sz = sourceZ - this.offsetZ;\n        const dx = destX - this.offsetX;\n        const dz = destZ - this.offsetZ;\n        const index = CollisionMap.index(sx, sz);\n        if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALLDECOR_DIAGONAL_OFFSET.id || shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALLDECOR_DIAGONAL_NOOFFSET.id) {\n            if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALLDECOR_DIAGONAL_NOOFFSET.id) {\n                angle = (angle + 2) & 0x3;\n            }\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].WEST) {\n                if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].NORTH) {\n                if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].EAST) {\n                if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SOUTH) {\n                if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n                else if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                    return true;\n                }\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WALLDECOR_DIAGONAL_BOTH.id) {\n            if (sx === dx && sz === dz + 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n            else if (sx === dx && sz === dz - 1 && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n            else if (sx === dx - 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n            else if (sx === dx + 1 && sz === dz && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n                return true;\n            }\n        }\n        return false;\n    };\n    reachedLoc = (srcX, srcZ, dstX, dstZ, dstSizeX, dstSizeZ, forceapproach) => {\n        const maxX = dstX + dstSizeX - 1;\n        const maxZ = dstZ + dstSizeZ - 1;\n        const index = CollisionMap.index(srcX - this.offsetX, srcZ - this.offsetZ);\n        if (srcX >= dstX && srcX <= maxX && srcZ >= dstZ && srcZ <= maxZ) {\n            return true;\n        }\n        else if (srcX === dstX - 1 && srcZ >= dstZ && srcZ <= maxZ && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN && (forceapproach & _DirectionFlag__WEBPACK_IMPORTED_MODULE_3__[\"default\"].WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n            return true;\n        }\n        else if (srcX === maxX + 1 && srcZ >= dstZ && srcZ <= maxZ && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_WEST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN && (forceapproach & _DirectionFlag__WEBPACK_IMPORTED_MODULE_3__[\"default\"].EAST) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n            return true;\n        }\n        else if (srcZ === dstZ - 1 && srcX >= dstX && srcX <= maxX && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN && (forceapproach & _DirectionFlag__WEBPACK_IMPORTED_MODULE_3__[\"default\"].SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n            return true;\n        }\n        else if (srcZ === maxZ + 1 && srcX >= dstX && srcX <= maxX && (this.flags[index] & _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_SOUTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN && (forceapproach & _DirectionFlag__WEBPACK_IMPORTED_MODULE_3__[\"default\"].NORTH) === _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OPEN) {\n            return true;\n        }\n        return false;\n    };\n    add = (x, z, flags) => {\n        this.flags[CollisionMap.index(x, z)] |= flags;\n    };\n    remove = (x, z, flags) => {\n        this.flags[CollisionMap.index(x, z)] &= _CollisionFlag__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BOUNDS - flags;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/CollisionMap.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/DirectionFlag.ts":
/*!***********************************************!*\
  !*** ./src/js/jagex2/dash3d/DirectionFlag.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DirectionFlag)\n/* harmony export */ });\nclass DirectionFlag {\n    static NORTH = 0x1;\n    static EAST = 0x2;\n    static SOUTH = 0x4;\n    static WEST = 0x8;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/DirectionFlag.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/LocAngle.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/dash3d/LocAngle.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocAngle)\n/* harmony export */ });\nclass LocAngle {\n    static WEST = 0;\n    static NORTH = 1;\n    static EAST = 2;\n    static SOUTH = 3;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/LocAngle.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/LocLayer.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/dash3d/LocLayer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocLayer)\n/* harmony export */ });\nclass LocLayer {\n    static WALL = 0;\n    static WALL_DECOR = 1;\n    static GROUND = 2;\n    static GROUND_DECOR = 3;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/LocLayer.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/LocShape.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/dash3d/LocShape.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocShape)\n/* harmony export */ });\n/* harmony import */ var _LocLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LocLayer */ \"./src/js/jagex2/dash3d/LocLayer.ts\");\n\nclass LocShape {\n    static WALL_STRAIGHT = new LocShape(0, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL);\n    static WALL_DIAGONAL_CORNER = new LocShape(1, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL);\n    static WALL_L = new LocShape(2, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL);\n    static WALL_SQUARE_CORNER = new LocShape(3, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL);\n    static WALLDECOR_STRAIGHT_NOOFFSET = new LocShape(4, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_DECOR);\n    static WALLDECOR_STRAIGHT_OFFSET = new LocShape(5, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_DECOR);\n    static WALLDECOR_DIAGONAL_OFFSET = new LocShape(6, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_DECOR);\n    static WALLDECOR_DIAGONAL_NOOFFSET = new LocShape(7, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_DECOR);\n    static WALLDECOR_DIAGONAL_BOTH = new LocShape(8, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WALL_DECOR);\n    static WALL_DIAGONAL = new LocShape(9, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static CENTREPIECE_STRAIGHT = new LocShape(10, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static CENTREPIECE_DIAGONAL = new LocShape(11, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOF_STRAIGHT = new LocShape(12, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOF_DIAGONAL_WITH_ROOFEDGE = new LocShape(13, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOF_DIAGONAL = new LocShape(14, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOF_L_CONCAVE = new LocShape(15, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOF_L_CONVEX = new LocShape(16, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOF_FLAT = new LocShape(17, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOFEDGE_STRAIGHT = new LocShape(18, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOFEDGE_DIAGONAL_CORNER = new LocShape(19, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOFEDGE_L = new LocShape(20, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static ROOFEDGE_SQUARE_CORNER = new LocShape(21, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND);\n    static GROUND_DECOR = new LocShape(22, _LocLayer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GROUND_DECOR);\n    static values() {\n        return [\n            this.WALL_STRAIGHT,\n            this.WALL_DIAGONAL_CORNER,\n            this.ROOF_FLAT,\n            this.ROOF_L_CONCAVE,\n            this.WALL_L,\n            this.ROOF_DIAGONAL,\n            this.WALL_DIAGONAL,\n            this.WALL_SQUARE_CORNER,\n            this.GROUND_DECOR,\n            this.ROOF_STRAIGHT,\n            this.CENTREPIECE_DIAGONAL,\n            this.WALLDECOR_DIAGONAL_OFFSET,\n            this.ROOFEDGE_L,\n            this.CENTREPIECE_STRAIGHT,\n            this.WALLDECOR_STRAIGHT_OFFSET,\n            this.ROOF_DIAGONAL_WITH_ROOFEDGE,\n            this.WALLDECOR_DIAGONAL_NOOFFSET,\n            this.WALLDECOR_STRAIGHT_NOOFFSET,\n            this.ROOF_L_CONVEX,\n            this.WALLDECOR_DIAGONAL_BOTH,\n            this.ROOFEDGE_DIAGONAL_CORNER,\n            this.ROOFEDGE_SQUARE_CORNER,\n            this.ROOFEDGE_STRAIGHT\n        ];\n    }\n    static of(id) {\n        const values = this.values();\n        for (let index = 0; index < values.length; index++) {\n            const shape = values[index];\n            if (shape.id === id) {\n                return shape;\n            }\n        }\n        throw Error('shape not found');\n    }\n    id;\n    layer;\n    constructor(id, layer) {\n        this.id = id;\n        this.layer = layer;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/LocShape.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/World.ts":
/*!***************************************!*\
  !*** ./src/js/jagex2/dash3d/World.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ World)\n/* harmony export */ });\n/* harmony import */ var _CollisionMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CollisionMap */ \"./src/js/jagex2/dash3d/CollisionMap.ts\");\n/* harmony import */ var _config_FloType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/FloType */ \"./src/js/jagex2/config/FloType.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/Draw3D */ \"./src/js/jagex2/graphics/Draw3D.ts\");\n/* harmony import */ var _World3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./World3D */ \"./src/js/jagex2/dash3d/World3D.ts\");\n/* harmony import */ var _config_LocType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../config/LocType */ \"./src/js/jagex2/config/LocType.ts\");\n/* harmony import */ var _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./entity/LocEntity */ \"./src/js/jagex2/dash3d/entity/LocEntity.ts\");\n/* harmony import */ var _config_SeqType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../config/SeqType */ \"./src/js/jagex2/config/SeqType.ts\");\n/* harmony import */ var _LocShape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LocShape */ \"./src/js/jagex2/dash3d/LocShape.ts\");\n/* harmony import */ var _LocAngle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LocAngle */ \"./src/js/jagex2/dash3d/LocAngle.ts\");\n/* harmony import */ var _graphics_Colors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../graphics/Colors */ \"./src/js/jagex2/graphics/Colors.ts\");\n/* harmony import */ var _type_TileOverlayShape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./type/TileOverlayShape */ \"./src/js/jagex2/dash3d/type/TileOverlayShape.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n// noinspection JSSuspiciousNameCombination,DuplicatedCode\nclass World {\n    static ROTATION_WALL_TYPE = Int8Array.of(1, 2, 4, 8);\n    static ROTATION_WALL_CORNER_TYPE = Uint8Array.of(16, 32, 64, 128);\n    static WALL_DECORATION_ROTATION_FORWARD_X = Int8Array.of(1, 0, -1, 0);\n    static WALL_DECORATION_ROTATION_FORWARD_Z = Int8Array.of(0, -1, 0, 1);\n    static randomHueOffset = ((Math.random() * 17.0) | 0) - 8;\n    static randomLightnessOffset = ((Math.random() * 33.0) | 0) - 16;\n    static lowMemory = true;\n    static levelBuilt = 0;\n    static fullbright = false;\n    static perlin = (x, z) => {\n        let value = this.perlinScale(x + 45365, z + 91923, 4) + ((this.perlinScale(x + 10294, z + 37821, 2) - 128) >> 1) + ((this.perlinScale(x, z, 1) - 128) >> 2) - 128;\n        value = ((value * 0.3) | 0) + 35;\n        if (value < 10) {\n            value = 10;\n        }\n        else if (value > 60) {\n            value = 60;\n        }\n        return value;\n    };\n    static perlinScale = (x, z, scale) => {\n        const intX = (x / scale) | 0;\n        const fracX = x & (scale - 1);\n        const intZ = (z / scale) | 0;\n        const fracZ = z & (scale - 1);\n        const v1 = this.smoothNoise(intX, intZ);\n        const v2 = this.smoothNoise(intX + 1, intZ);\n        const v3 = this.smoothNoise(intX, intZ + 1);\n        const v4 = this.smoothNoise(intX + 1, intZ + 1);\n        const i1 = this.interpolate(v1, v2, fracX, scale);\n        const i2 = this.interpolate(v3, v4, fracX, scale);\n        return this.interpolate(i1, i2, fracZ, scale);\n    };\n    static interpolate = (a, b, x, scale) => {\n        const f = (65536 - _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_3__[\"default\"].cos[((x * 1024) / scale) | 0]) >> 1;\n        return ((a * (65536 - f)) >> 16) + ((b * f) >> 16);\n    };\n    static smoothNoise = (x, y) => {\n        const corners = this.noise(x - 1, y - 1) + this.noise(x + 1, y - 1) + this.noise(x - 1, y + 1) + this.noise(x + 1, y + 1);\n        const sides = this.noise(x - 1, y) + this.noise(x + 1, y) + this.noise(x, y - 1) + this.noise(x, y + 1);\n        const center = this.noise(x, y);\n        return ((corners / 16) | 0) + ((sides / 8) | 0) + ((center / 4) | 0);\n    };\n    static noise = (x, y) => {\n        const n = x + y * 57;\n        const n1 = BigInt((n << 13) ^ n);\n        return Number(((n1 * (n1 * n1 * 15731n + 789221n) + 1376312589n) & 0x7fffffffn) >> 19n) & 0xff;\n    };\n    static addLoc = (level, x, z, scene, levelHeightmap, locs, collision, locId, shape, angle, trueLevel) => {\n        const heightSW = levelHeightmap[trueLevel][x][z];\n        const heightSE = levelHeightmap[trueLevel][x + 1][z];\n        const heightNW = levelHeightmap[trueLevel][x + 1][z + 1];\n        const heightNE = levelHeightmap[trueLevel][x][z + 1];\n        const y = (heightSW + heightSE + heightNW + heightNE) >> 2;\n        const loc = _config_LocType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(locId);\n        let bitset = (x + (z << 7) + (locId << 14) + 0x40000000) | 0;\n        if (!loc.active) {\n            bitset += -0x80000000; // int.min\n        }\n        bitset |= 0;\n        const info = ((((angle << 6) + shape) | 0) << 24) >> 24;\n        if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].GROUND_DECOR.id) {\n            scene?.addGroundDecoration(loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].GROUND_DECOR.id, angle, heightSW, heightSE, heightNW, heightNE, -1), level, x, z, y, bitset, info);\n            if (loc.blockwalk && loc.active) {\n                collision?.addFloor(x, z);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 3, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_STRAIGHT.id || shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_DIAGONAL.id) {\n            const model = loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_STRAIGHT.id, angle, heightSW, heightSE, heightNW, heightNE, -1);\n            if (model) {\n                let yaw = 0;\n                if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_DIAGONAL.id) {\n                    yaw += 256;\n                }\n                let width;\n                let height;\n                if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].NORTH || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SOUTH) {\n                    width = loc.length;\n                    height = loc.width;\n                }\n                else {\n                    width = loc.width;\n                    height = loc.length;\n                }\n                scene?.addLoc(level, x, z, y, model, null, bitset, info, width, height, yaw);\n            }\n            if (loc.blockwalk) {\n                collision?.addLoc(x, z, loc.width, loc.length, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 2, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape >= _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].ROOF_STRAIGHT.id) {\n            scene?.addLoc(level, x, z, y, loc.getModel(shape, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info, 1, 1, 0);\n            if (loc.blockwalk) {\n                collision?.addLoc(x, z, loc.width, loc.length, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 2, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_STRAIGHT.id) {\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_TYPE[angle], 0, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_STRAIGHT.id, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info);\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_DIAGONAL_CORNER.id) {\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_CORNER_TYPE[angle], 0, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_DIAGONAL_CORNER.id, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info);\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_L.id) {\n            const offset = (angle + 1) & 0x3;\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_TYPE[angle], World.ROTATION_WALL_TYPE[offset], loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_L.id, angle + 4, heightSW, heightSE, heightNW, heightNE, -1), loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_L.id, offset, heightSW, heightSE, heightNW, heightNE, -1), bitset, info);\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_SQUARE_CORNER.id) {\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_CORNER_TYPE[angle], 0, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_SQUARE_CORNER.id, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info);\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_DIAGONAL.id) {\n            scene?.addLoc(level, x, z, y, loc.getModel(shape, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info, 1, 1, 0);\n            if (loc.blockwalk) {\n                collision?.addLoc(x, z, loc.width, loc.length, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 2, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle * 512, World.ROTATION_WALL_TYPE[angle]);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_OFFSET.id) {\n            let offset = 16;\n            if (scene) {\n                const width = scene.getWallBitset(level, x, z);\n                if (width > 0) {\n                    offset = _config_LocType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get((width >> 14) & 0x7fff).wallwidth;\n                }\n            }\n            scene?.setWallDecoration(level, x, z, y, World.WALL_DECORATION_ROTATION_FORWARD_X[angle] * offset, World.WALL_DECORATION_ROTATION_FORWARD_Z[angle] * offset, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle * 512, World.ROTATION_WALL_TYPE[angle]);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_DIAGONAL_OFFSET.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle, 256);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_DIAGONAL_NOOFFSET.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle, 512);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_DIAGONAL_BOTH.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle, 768);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n    };\n    maxTileX;\n    maxTileZ;\n    levelHeightmap;\n    levelTileFlags;\n    levelTileUnderlayIds;\n    levelTileOverlayIds;\n    levelTileOverlayShape;\n    levelTileOverlayRotation;\n    levelShademap;\n    levelLightmap;\n    blendChroma;\n    blendSaturation;\n    blendLightness;\n    blendLuminance;\n    blendMagnitude;\n    levelOccludemap;\n    constructor(maxTileX, maxTileZ, levelHeightmap, levelTileFlags) {\n        this.maxTileX = maxTileX;\n        this.maxTileZ = maxTileZ;\n        this.levelHeightmap = levelHeightmap;\n        this.levelTileFlags = levelTileFlags;\n        this.levelTileUnderlayIds = new _util_Arrays__WEBPACK_IMPORTED_MODULE_12__.Uint8Array3d(_CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS, maxTileX, maxTileZ);\n        this.levelTileOverlayIds = new _util_Arrays__WEBPACK_IMPORTED_MODULE_12__.Uint8Array3d(_CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS, maxTileX, maxTileZ);\n        this.levelTileOverlayShape = new _util_Arrays__WEBPACK_IMPORTED_MODULE_12__.Uint8Array3d(_CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS, maxTileX, maxTileZ);\n        this.levelTileOverlayRotation = new _util_Arrays__WEBPACK_IMPORTED_MODULE_12__.Uint8Array3d(_CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS, maxTileX, maxTileZ);\n        this.levelOccludemap = new _util_Arrays__WEBPACK_IMPORTED_MODULE_12__.Int32Array3d(_CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS, maxTileX + 1, maxTileZ + 1);\n        this.levelShademap = new _util_Arrays__WEBPACK_IMPORTED_MODULE_12__.Uint8Array3d(_CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS, maxTileX + 1, maxTileZ + 1);\n        this.levelLightmap = new _util_Arrays__WEBPACK_IMPORTED_MODULE_12__.Int32Array2d(maxTileX + 1, maxTileZ + 1);\n        this.blendChroma = new Int32Array(maxTileZ);\n        this.blendSaturation = new Int32Array(maxTileZ);\n        this.blendLightness = new Int32Array(maxTileZ);\n        this.blendLuminance = new Int32Array(maxTileZ);\n        this.blendMagnitude = new Int32Array(maxTileZ);\n    }\n    build = (scene, collision) => {\n        for (let level = 0; level < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS; level++) {\n            for (let x = 0; x < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SIZE; x++) {\n                for (let z = 0; z < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SIZE; z++) {\n                    // solid\n                    if ((this.levelTileFlags[level][x][z] & 0x1) === 1) {\n                        let trueLevel = level;\n                        // bridge\n                        if ((this.levelTileFlags[1][x][z] & 0x2) === 2) {\n                            trueLevel--;\n                        }\n                        if (trueLevel >= 0) {\n                            collision[trueLevel]?.addFloor(x, z);\n                        }\n                    }\n                }\n            }\n        }\n        World.randomHueOffset += ((Math.random() * 5.0) | 0) - 2;\n        if (World.randomHueOffset < -8) {\n            World.randomHueOffset = -8;\n        }\n        else if (World.randomHueOffset > 8) {\n            World.randomHueOffset = 8;\n        }\n        World.randomLightnessOffset += ((Math.random() * 5.0) | 0) - 2;\n        if (World.randomLightnessOffset < -16) {\n            World.randomLightnessOffset = -16;\n        }\n        else if (World.randomLightnessOffset > 16) {\n            World.randomLightnessOffset = 16;\n        }\n        for (let level = 0; level < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS; level++) {\n            const shademap = this.levelShademap[level];\n            const lightAmbient = 96;\n            const lightAttenuation = 768;\n            const lightX = -50;\n            const lightY = -10;\n            const lightZ = -50;\n            const lightMag = Math.sqrt(lightX * lightX + lightY * lightY + lightZ * lightZ) | 0;\n            const lightMagnitude = (lightAttenuation * lightMag) >> 8;\n            for (let z = 1; z < this.maxTileZ - 1; z++) {\n                for (let x = 1; x < this.maxTileX - 1; x++) {\n                    const dx = this.levelHeightmap[level][x + 1][z] - this.levelHeightmap[level][x - 1][z];\n                    const dz = this.levelHeightmap[level][x][z + 1] - this.levelHeightmap[level][x][z - 1];\n                    const len = Math.sqrt(dx * dx + dz * dz + 65536) | 0;\n                    const normalX = ((dx << 8) / len) | 0;\n                    const normalY = (65536 / len) | 0;\n                    const normalZ = ((dz << 8) / len) | 0;\n                    const light = lightAmbient + (((lightX * normalX + lightY * normalY + lightZ * normalZ) / lightMagnitude) | 0);\n                    const shade = (shademap[x - 1][z] >> 2) + (shademap[x + 1][z] >> 3) + (shademap[x][z - 1] >> 2) + (shademap[x][z + 1] >> 3) + (shademap[x][z] >> 1);\n                    this.levelLightmap[x][z] = light - shade;\n                }\n            }\n            for (let z = 0; z < this.maxTileZ; z++) {\n                this.blendChroma[z] = 0;\n                this.blendSaturation[z] = 0;\n                this.blendLightness[z] = 0;\n                this.blendLuminance[z] = 0;\n                this.blendMagnitude[z] = 0;\n            }\n            for (let x0 = -5; x0 < this.maxTileX + 5; x0++) {\n                for (let z0 = 0; z0 < this.maxTileZ; z0++) {\n                    const x1 = x0 + 5;\n                    let debugMag;\n                    if (x1 >= 0 && x1 < this.maxTileX) {\n                        const underlayId = this.levelTileUnderlayIds[level][x1][z0] & 0xff;\n                        if (underlayId > 0) {\n                            const flu = _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[underlayId - 1];\n                            this.blendChroma[z0] += flu.chroma;\n                            this.blendSaturation[z0] += flu.saturation;\n                            this.blendLightness[z0] += flu.lightness;\n                            this.blendLuminance[z0] += flu.luminance;\n                            debugMag = this.blendMagnitude[z0]++;\n                        }\n                    }\n                    const x2 = x0 - 5;\n                    if (x2 >= 0 && x2 < this.maxTileX) {\n                        const underlayId = this.levelTileUnderlayIds[level][x2][z0] & 0xff;\n                        if (underlayId > 0) {\n                            const flu = _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[underlayId - 1];\n                            this.blendChroma[z0] -= flu.chroma;\n                            this.blendSaturation[z0] -= flu.saturation;\n                            this.blendLightness[z0] -= flu.lightness;\n                            this.blendLuminance[z0] -= flu.luminance;\n                            debugMag = this.blendMagnitude[z0]--;\n                        }\n                    }\n                }\n                if (x0 >= 1 && x0 < this.maxTileX - 1) {\n                    let hueAccumulator = 0;\n                    let saturationAccumulator = 0;\n                    let lightnessAccumulator = 0;\n                    let luminanceAccumulator = 0;\n                    let magnitudeAccumulator = 0;\n                    for (let z0 = -5; z0 < this.maxTileZ + 5; z0++) {\n                        const dz1 = z0 + 5;\n                        if (dz1 >= 0 && dz1 < this.maxTileZ) {\n                            hueAccumulator += this.blendChroma[dz1];\n                            saturationAccumulator += this.blendSaturation[dz1];\n                            lightnessAccumulator += this.blendLightness[dz1];\n                            luminanceAccumulator += this.blendLuminance[dz1];\n                            magnitudeAccumulator += this.blendMagnitude[dz1];\n                        }\n                        const dz2 = z0 - 5;\n                        if (dz2 >= 0 && dz2 < this.maxTileZ) {\n                            hueAccumulator -= this.blendChroma[dz2];\n                            saturationAccumulator -= this.blendSaturation[dz2];\n                            lightnessAccumulator -= this.blendLightness[dz2];\n                            luminanceAccumulator -= this.blendLuminance[dz2];\n                            magnitudeAccumulator -= this.blendMagnitude[dz2];\n                        }\n                        if (z0 >= 1 && z0 < this.maxTileZ - 1 && (!World.lowMemory || ((this.levelTileFlags[level][x0][z0] & 0x10) === 0 && this.getDrawLevel(level, x0, z0) === World.levelBuilt))) {\n                            const underlayId = this.levelTileUnderlayIds[level][x0][z0] & 0xff;\n                            const overlayId = this.levelTileOverlayIds[level][x0][z0] & 0xff;\n                            if (underlayId > 0 || overlayId > 0) {\n                                const heightSW = this.levelHeightmap[level][x0][z0];\n                                const heightSE = this.levelHeightmap[level][x0 + 1][z0];\n                                const heightNE = this.levelHeightmap[level][x0 + 1][z0 + 1];\n                                const heightNW = this.levelHeightmap[level][x0][z0 + 1];\n                                const lightSW = this.levelLightmap[x0][z0];\n                                const lightSE = this.levelLightmap[x0 + 1][z0];\n                                const lightNE = this.levelLightmap[x0 + 1][z0 + 1];\n                                const lightNW = this.levelLightmap[x0][z0 + 1];\n                                let baseColor = -1;\n                                let tintColor = -1;\n                                if (underlayId > 0) {\n                                    const hue = ((hueAccumulator * 256) / luminanceAccumulator) | 0;\n                                    const saturation = (saturationAccumulator / magnitudeAccumulator) | 0;\n                                    let lightness = (lightnessAccumulator / magnitudeAccumulator) | 0;\n                                    baseColor = _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hsl24to16(hue, saturation, lightness);\n                                    const randomHue = (hue + World.randomHueOffset) & 0xff;\n                                    lightness += World.randomLightnessOffset;\n                                    if (lightness < 0) {\n                                        lightness = 0;\n                                    }\n                                    else if (lightness > 255) {\n                                        lightness = 255;\n                                    }\n                                    tintColor = _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hsl24to16(randomHue, saturation, lightness);\n                                }\n                                if (level > 0) {\n                                    let occludes = underlayId !== 0 || this.levelTileOverlayShape[level][x0][z0] === _type_TileOverlayShape__WEBPACK_IMPORTED_MODULE_11__[\"default\"].PLAIN;\n                                    if (overlayId > 0 && !_config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[overlayId - 1].occlude) {\n                                        occludes = false;\n                                    }\n                                    // occludes && flat\n                                    if (occludes && heightSW === heightSE && heightSW === heightNE && heightSW === heightNW) {\n                                        this.levelOccludemap[level][x0][z0] |= 0x924;\n                                    }\n                                }\n                                let shadeColor = 0;\n                                if (baseColor !== -1) {\n                                    shadeColor = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_3__[\"default\"].palette[_config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(tintColor, 96)];\n                                }\n                                if (overlayId === 0) {\n                                    scene?.setTile(level, x0, z0, _type_TileOverlayShape__WEBPACK_IMPORTED_MODULE_11__[\"default\"].PLAIN, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, -1, heightSW, heightSE, heightNE, heightNW, _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightSW), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightSE), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightNE), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightNW), _graphics_Colors__WEBPACK_IMPORTED_MODULE_10__[\"default\"].BLACK, _graphics_Colors__WEBPACK_IMPORTED_MODULE_10__[\"default\"].BLACK, _graphics_Colors__WEBPACK_IMPORTED_MODULE_10__[\"default\"].BLACK, _graphics_Colors__WEBPACK_IMPORTED_MODULE_10__[\"default\"].BLACK, shadeColor, _graphics_Colors__WEBPACK_IMPORTED_MODULE_10__[\"default\"].BLACK);\n                                }\n                                else {\n                                    const shape = this.levelTileOverlayShape[level][x0][z0] + 1;\n                                    const rotation = this.levelTileOverlayRotation[level][x0][z0];\n                                    const flo = _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[overlayId - 1];\n                                    let textureId = flo.texture;\n                                    let hsl;\n                                    let rgb;\n                                    if (textureId >= 0) {\n                                        rgb = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAverageTextureRGB(textureId);\n                                        hsl = -1;\n                                    }\n                                    else if (flo.rgb === _graphics_Colors__WEBPACK_IMPORTED_MODULE_10__[\"default\"].MAGENTA) {\n                                        rgb = 0;\n                                        hsl = -2;\n                                        textureId = -1;\n                                    }\n                                    else {\n                                        hsl = _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hsl24to16(flo.hue, flo.saturation, flo.lightness);\n                                        rgb = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_3__[\"default\"].palette[_config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].adjustLightness(flo.hsl, 96)];\n                                    }\n                                    scene?.setTile(level, x0, z0, shape, rotation, textureId, heightSW, heightSE, heightNE, heightNW, _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightSW), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightSE), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightNE), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mulHSL(baseColor, lightNW), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].adjustLightness(hsl, lightSW), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].adjustLightness(hsl, lightSE), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].adjustLightness(hsl, lightNE), _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].adjustLightness(hsl, lightNW), shadeColor, rgb);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            for (let stz = 1; stz < this.maxTileZ - 1; stz++) {\n                for (let stx = 1; stx < this.maxTileX - 1; stx++) {\n                    scene?.setDrawLevel(level, stx, stz, this.getDrawLevel(level, stx, stz));\n                }\n            }\n        }\n        if (!World.fullbright) {\n            scene?.buildModels(64, 768, -50, -10, -50);\n        }\n        for (let x = 0; x < this.maxTileX; x++) {\n            for (let z = 0; z < this.maxTileZ; z++) {\n                if ((this.levelTileFlags[1][x][z] & 0x2) === 2) {\n                    scene?.setBridge(x, z);\n                }\n            }\n        }\n        if (!World.fullbright) {\n            let wall0 = 0x1; // this flag is set by walls with rotation 0 or 2\n            let wall1 = 0x2; // this flag is set by walls with rotation 1 or 3\n            let floor = 0x4; // this flag is set by floors which are flat\n            for (let topLevel = 0; topLevel < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS; topLevel++) {\n                if (topLevel > 0) {\n                    wall0 <<= 0x3;\n                    wall1 <<= 0x3;\n                    floor <<= 0x3;\n                }\n                for (let level = 0; level <= topLevel; level++) {\n                    for (let tileZ = 0; tileZ <= this.maxTileZ; tileZ++) {\n                        for (let tileX = 0; tileX <= this.maxTileX; tileX++) {\n                            if ((this.levelOccludemap[level][tileX][tileZ] & wall0) !== 0) {\n                                let minTileZ = tileZ;\n                                let maxTileZ = tileZ;\n                                let minLevel = level;\n                                let maxLevel = level;\n                                while (minTileZ > 0 && (this.levelOccludemap[level][tileX][minTileZ - 1] & wall0) !== 0) {\n                                    minTileZ--;\n                                }\n                                while (maxTileZ < this.maxTileZ && (this.levelOccludemap[level][tileX][maxTileZ + 1] & wall0) !== 0) {\n                                    maxTileZ++;\n                                }\n                                find_min_level: while (minLevel > 0) {\n                                    for (let z = minTileZ; z <= maxTileZ; z++) {\n                                        if ((this.levelOccludemap[minLevel - 1][tileX][z] & wall0) === 0) {\n                                            break find_min_level;\n                                        }\n                                    }\n                                    minLevel--;\n                                }\n                                find_max_level: while (maxLevel < topLevel) {\n                                    for (let z = minTileZ; z <= maxTileZ; z++) {\n                                        if ((this.levelOccludemap[maxLevel + 1][tileX][z] & wall0) === 0) {\n                                            break find_max_level;\n                                        }\n                                    }\n                                    maxLevel++;\n                                }\n                                const area = (maxLevel + 1 - minLevel) * (maxTileZ + 1 - minTileZ);\n                                if (area >= 8) {\n                                    const minY = this.levelHeightmap[maxLevel][tileX][minTileZ] - 240;\n                                    const maxX = this.levelHeightmap[minLevel][tileX][minTileZ];\n                                    _World3D__WEBPACK_IMPORTED_MODULE_4__[\"default\"].addOccluder(topLevel, 1, tileX * 128, minY, minTileZ * 128, tileX * 128, maxX, maxTileZ * 128 + 128);\n                                    for (let l = minLevel; l <= maxLevel; l++) {\n                                        for (let z = minTileZ; z <= maxTileZ; z++) {\n                                            this.levelOccludemap[l][tileX][z] &= ~wall0;\n                                        }\n                                    }\n                                }\n                            }\n                            if ((this.levelOccludemap[level][tileX][tileZ] & wall1) !== 0) {\n                                let minTileX = tileX;\n                                let maxTileX = tileX;\n                                let minLevel = level;\n                                let maxLevel = level;\n                                while (minTileX > 0 && (this.levelOccludemap[level][minTileX - 1][tileZ] & wall1) !== 0) {\n                                    minTileX--;\n                                }\n                                while (maxTileX < this.maxTileX && (this.levelOccludemap[level][maxTileX + 1][tileZ] & wall1) !== 0) {\n                                    maxTileX++;\n                                }\n                                find_min_level2: while (minLevel > 0) {\n                                    for (let x = minTileX; x <= maxTileX; x++) {\n                                        if ((this.levelOccludemap[minLevel - 1][x][tileZ] & wall1) === 0) {\n                                            break find_min_level2;\n                                        }\n                                    }\n                                    minLevel--;\n                                }\n                                find_max_level2: while (maxLevel < topLevel) {\n                                    for (let x = minTileX; x <= maxTileX; x++) {\n                                        if ((this.levelOccludemap[maxLevel + 1][x][tileZ] & wall1) === 0) {\n                                            break find_max_level2;\n                                        }\n                                    }\n                                    maxLevel++;\n                                }\n                                const area = (maxLevel + 1 - minLevel) * (maxTileX + 1 - minTileX);\n                                if (area >= 8) {\n                                    const minY = this.levelHeightmap[maxLevel][minTileX][tileZ] - 240;\n                                    const maxY = this.levelHeightmap[minLevel][minTileX][tileZ];\n                                    _World3D__WEBPACK_IMPORTED_MODULE_4__[\"default\"].addOccluder(topLevel, 2, minTileX * 128, minY, tileZ * 128, maxTileX * 128 + 128, maxY, tileZ * 128);\n                                    for (let l = minLevel; l <= maxLevel; l++) {\n                                        for (let x = minTileX; x <= maxTileX; x++) {\n                                            this.levelOccludemap[l][x][tileZ] &= ~wall1;\n                                        }\n                                    }\n                                }\n                            }\n                            if ((this.levelOccludemap[level][tileX][tileZ] & floor) !== 0) {\n                                let minTileX = tileX;\n                                let maxTileX = tileX;\n                                let minTileZ = tileZ;\n                                let maxTileZ = tileZ;\n                                while (minTileZ > 0 && (this.levelOccludemap[level][tileX][minTileZ - 1] & floor) !== 0) {\n                                    minTileZ--;\n                                }\n                                while (maxTileZ < this.maxTileZ && (this.levelOccludemap[level][tileX][maxTileZ + 1] & floor) !== 0) {\n                                    maxTileZ++;\n                                }\n                                find_min_tile_xz: while (minTileX > 0) {\n                                    for (let z = minTileZ; z <= maxTileZ; z++) {\n                                        if ((this.levelOccludemap[level][minTileX - 1][z] & floor) === 0) {\n                                            break find_min_tile_xz;\n                                        }\n                                    }\n                                    minTileX--;\n                                }\n                                find_max_tile_xz: while (maxTileX < this.maxTileX) {\n                                    for (let z = minTileZ; z <= maxTileZ; z++) {\n                                        if ((this.levelOccludemap[level][maxTileX + 1][z] & floor) === 0) {\n                                            break find_max_tile_xz;\n                                        }\n                                    }\n                                    maxTileX++;\n                                }\n                                if ((maxTileX + 1 - minTileX) * (maxTileZ + 1 - minTileZ) >= 4) {\n                                    const y = this.levelHeightmap[level][minTileX][minTileZ];\n                                    _World3D__WEBPACK_IMPORTED_MODULE_4__[\"default\"].addOccluder(topLevel, 4, minTileX * 128, y, minTileZ * 128, maxTileX * 128 + 128, y, maxTileZ * 128 + 128);\n                                    for (let x = minTileX; x <= maxTileX; x++) {\n                                        for (let z = minTileZ; z <= maxTileZ; z++) {\n                                            this.levelOccludemap[level][x][z] &= ~floor;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    clearLandscape = (startX, startZ, endX, endZ) => {\n        let waterOverlay = 0;\n        for (let i = 0; i < _config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].count; i++) {\n            if (_config_FloType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[i].debugname?.toLowerCase() === 'water') {\n                waterOverlay = ((i + 1) << 24) >> 24;\n                break;\n            }\n        }\n        for (let z = startX; z < startX + endX; z++) {\n            for (let x = startZ; x < startZ + endZ; x++) {\n                if (x >= 0 && x < this.maxTileX && z >= 0 && z < this.maxTileZ) {\n                    this.levelTileOverlayIds[0][x][z] = waterOverlay;\n                    for (let level = 0; level < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS; level++) {\n                        this.levelHeightmap[level][x][z] = 0;\n                        this.levelTileFlags[level][x][z] = 0;\n                    }\n                }\n            }\n        }\n    };\n    readLandscape = (originX, originZ, xOffset, zOffset, src) => {\n        const buf = new _io_Packet__WEBPACK_IMPORTED_MODULE_2__[\"default\"](new Uint8Array(src));\n        for (let level = 0; level < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].LEVELS; level++) {\n            for (let x = 0; x < 64; x++) {\n                for (let z = 0; z < 64; z++) {\n                    const stx = x + xOffset;\n                    const stz = z + zOffset;\n                    let opcode;\n                    if (stx >= 0 && stx < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SIZE && stz >= 0 && stz < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SIZE) {\n                        this.levelTileFlags[level][stx][stz] = 0;\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            opcode = buf.g1;\n                            if (opcode === 0) {\n                                if (level === 0) {\n                                    this.levelHeightmap[0][stx][stz] = -World.perlin(stx + originX + 932731, stz + 556238 + originZ) * 8;\n                                }\n                                else {\n                                    this.levelHeightmap[level][stx][stz] = this.levelHeightmap[level - 1][stx][stz] - 240;\n                                }\n                                break;\n                            }\n                            if (opcode === 1) {\n                                let height = buf.g1;\n                                if (height === 1) {\n                                    height = 0;\n                                }\n                                if (level === 0) {\n                                    this.levelHeightmap[0][stx][stz] = -height * 8;\n                                }\n                                else {\n                                    this.levelHeightmap[level][stx][stz] = this.levelHeightmap[level - 1][stx][stz] - height * 8;\n                                }\n                                break;\n                            }\n                            if (opcode <= 49) {\n                                this.levelTileOverlayIds[level][stx][stz] = buf.g1b;\n                                this.levelTileOverlayShape[level][stx][stz] = ((((opcode - 2) / 4) | 0) << 24) >> 24;\n                                this.levelTileOverlayRotation[level][stx][stz] = (((opcode - 2) & 0x3) << 24) >> 24;\n                            }\n                            else if (opcode <= 81) {\n                                this.levelTileFlags[level][stx][stz] = ((opcode - 49) << 24) >> 24;\n                            }\n                            else {\n                                this.levelTileUnderlayIds[level][stx][stz] = ((opcode - 81) << 24) >> 24;\n                            }\n                        }\n                    }\n                    else {\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            opcode = buf.g1;\n                            if (opcode === 0) {\n                                break;\n                            }\n                            if (opcode === 1) {\n                                buf.g1;\n                                break;\n                            }\n                            if (opcode <= 49) {\n                                buf.g1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    readLocs = (scene, locs, collision, src, xOffset, zOffset) => {\n        const buf = new _io_Packet__WEBPACK_IMPORTED_MODULE_2__[\"default\"](new Uint8Array(src));\n        let locId = -1;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const deltaId = buf.gsmarts;\n            if (deltaId === 0) {\n                return;\n            }\n            locId += deltaId;\n            let locPos = 0;\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const deltaPos = buf.gsmarts;\n                if (deltaPos === 0) {\n                    break;\n                }\n                locPos += deltaPos - 1;\n                const z = locPos & 0x3f;\n                const x = (locPos >> 6) & 0x3f;\n                const level = locPos >> 12;\n                const info = buf.g1;\n                const shape = info >> 2;\n                const rotation = info & 0x3;\n                const stx = x + xOffset;\n                const stz = z + zOffset;\n                if (stx > 0 && stz > 0 && stx < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SIZE - 1 && stz < _CollisionMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SIZE - 1) {\n                    let currentLevel = level;\n                    if ((this.levelTileFlags[1][stx][stz] & 0x2) === 2) {\n                        currentLevel = level - 1;\n                    }\n                    let collisionMap = null;\n                    if (currentLevel >= 0) {\n                        collisionMap = collision[currentLevel];\n                    }\n                    this.addLoc(level, stx, stz, scene, locs, collisionMap, locId, shape, rotation);\n                }\n            }\n        }\n    };\n    addLoc = (level, x, z, scene, locs, collision, locId, shape, angle) => {\n        if (World.lowMemory) {\n            if ((this.levelTileFlags[level][x][z] & 0x10) !== 0) {\n                return;\n            }\n            if (this.getDrawLevel(level, x, z) !== World.levelBuilt) {\n                return;\n            }\n        }\n        const heightSW = this.levelHeightmap[level][x][z];\n        const heightSE = this.levelHeightmap[level][x + 1][z];\n        const heightNW = this.levelHeightmap[level][x + 1][z + 1];\n        const heightNE = this.levelHeightmap[level][x][z + 1];\n        const y = (heightSW + heightSE + heightNW + heightNE) >> 2;\n        const loc = _config_LocType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(locId);\n        let bitset = (x + (z << 7) + (locId << 14) + 0x40000000) | 0;\n        if (!loc.active) {\n            bitset += -0x80000000; // int.min\n        }\n        bitset |= 0;\n        const info = ((((angle << 6) + shape) | 0) << 24) >> 24;\n        if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].GROUND_DECOR.id) {\n            if (!World.lowMemory || loc.active || loc.forcedecor) {\n                scene?.addGroundDecoration(loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].GROUND_DECOR.id, angle, heightSW, heightSE, heightNW, heightNE, -1), level, x, z, y, bitset, info);\n                if (loc.blockwalk && loc.active) {\n                    collision?.addFloor(x, z);\n                }\n                if (loc.anim !== -1) {\n                    locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 3, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n                }\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_STRAIGHT.id || shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_DIAGONAL.id) {\n            const model = loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_STRAIGHT.id, angle, heightSW, heightSE, heightNW, heightNE, -1);\n            if (model) {\n                let yaw = 0;\n                if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].CENTREPIECE_DIAGONAL.id) {\n                    yaw += 256;\n                }\n                let width;\n                let height;\n                if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].NORTH || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SOUTH) {\n                    width = loc.length;\n                    height = loc.width;\n                }\n                else {\n                    width = loc.width;\n                    height = loc.length;\n                }\n                if (scene?.addLoc(level, x, z, y, model, null, bitset, info, width, height, yaw) && loc.shadow) {\n                    for (let dx = 0; dx <= width; dx++) {\n                        for (let dz = 0; dz <= height; dz++) {\n                            let shade = (model.radius / 4) | 0;\n                            if (shade > 30) {\n                                shade = 30;\n                            }\n                            if (shade > this.levelShademap[level][x + dx][z + dz]) {\n                                this.levelShademap[level][x + dx][z + dz] = (shade << 24) >> 24;\n                            }\n                        }\n                    }\n                }\n            }\n            if (loc.blockwalk) {\n                collision?.addLoc(x, z, loc.width, loc.length, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 2, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape >= _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].ROOF_STRAIGHT.id) {\n            scene?.addLoc(level, x, z, y, loc.getModel(shape, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info, 1, 1, 0);\n            if (shape >= _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].ROOF_STRAIGHT.id && shape <= _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].ROOF_FLAT.id && shape !== _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].ROOF_DIAGONAL_WITH_ROOFEDGE.id && level > 0) {\n                this.levelOccludemap[level][x][z] |= 0x924;\n            }\n            if (loc.blockwalk) {\n                collision?.addLoc(x, z, loc.width, loc.length, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 2, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_STRAIGHT.id) {\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_TYPE[angle], 0, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_STRAIGHT.id, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info);\n            if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST) {\n                if (loc.shadow) {\n                    this.levelShademap[level][x][z] = 50;\n                    this.levelShademap[level][x][z + 1] = 50;\n                }\n                if (loc.occlude) {\n                    this.levelOccludemap[level][x][z] |= 0x249;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].NORTH) {\n                if (loc.shadow) {\n                    this.levelShademap[level][x][z + 1] = 50;\n                    this.levelShademap[level][x + 1][z + 1] = 50;\n                }\n                if (loc.occlude) {\n                    this.levelOccludemap[level][x][z + 1] |= 0x492;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].EAST) {\n                if (loc.shadow) {\n                    this.levelShademap[level][x + 1][z] = 50;\n                    this.levelShademap[level][x + 1][z + 1] = 50;\n                }\n                if (loc.occlude) {\n                    this.levelOccludemap[level][x + 1][z] |= 0x249;\n                }\n            }\n            else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SOUTH) {\n                if (loc.shadow) {\n                    this.levelShademap[level][x][z] = 50;\n                    this.levelShademap[level][x + 1][z] = 50;\n                }\n                if (loc.occlude) {\n                    this.levelOccludemap[level][x][z] |= 0x492;\n                }\n            }\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n            if (loc.wallwidth !== 16) {\n                scene?.setWallDecorationOffset(level, x, z, loc.wallwidth);\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_DIAGONAL_CORNER.id) {\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_CORNER_TYPE[angle], 0, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_DIAGONAL_CORNER.id, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info);\n            if (loc.shadow) {\n                if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST) {\n                    this.levelShademap[level][x][z + 1] = 50;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].NORTH) {\n                    this.levelShademap[level][x + 1][z + 1] = 50;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].EAST) {\n                    this.levelShademap[level][x + 1][z] = 50;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SOUTH) {\n                    this.levelShademap[level][x][z] = 50;\n                }\n            }\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_L.id) {\n            const offset = (angle + 1) & 0x3;\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_TYPE[angle], World.ROTATION_WALL_TYPE[offset], loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_L.id, angle + 4, heightSW, heightSE, heightNW, heightNE, -1), loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_L.id, offset, heightSW, heightSE, heightNW, heightNE, -1), bitset, info);\n            if (loc.occlude) {\n                if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST) {\n                    this.levelOccludemap[level][x][z] |= 0x109;\n                    this.levelOccludemap[level][x][z + 1] |= 0x492;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].NORTH) {\n                    this.levelOccludemap[level][x][z + 1] |= 0x492;\n                    this.levelOccludemap[level][x + 1][z] |= 0x249;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].EAST) {\n                    this.levelOccludemap[level][x + 1][z] |= 0x249;\n                    this.levelOccludemap[level][x][z] |= 0x492;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SOUTH) {\n                    this.levelOccludemap[level][x][z] |= 0x492;\n                    this.levelOccludemap[level][x][z] |= 0x249;\n                }\n            }\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n            if (loc.wallwidth !== 16) {\n                scene?.setWallDecorationOffset(level, x, z, loc.wallwidth);\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_SQUARE_CORNER.id) {\n            scene?.addWall(level, x, z, y, World.ROTATION_WALL_CORNER_TYPE[angle], 0, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_SQUARE_CORNER.id, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info);\n            if (loc.shadow) {\n                if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST) {\n                    this.levelShademap[level][x][z + 1] = 50;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].NORTH) {\n                    this.levelShademap[level][x + 1][z + 1] = 50;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].EAST) {\n                    this.levelShademap[level][x + 1][z] = 50;\n                }\n                else if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SOUTH) {\n                    this.levelShademap[level][x][z] = 50;\n                }\n            }\n            if (loc.blockwalk) {\n                collision?.addWall(x, z, shape, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 0, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALL_DIAGONAL.id) {\n            scene?.addLoc(level, x, z, y, loc.getModel(shape, angle, heightSW, heightSE, heightNW, heightNE, -1), null, bitset, info, 1, 1, 0);\n            if (loc.blockwalk) {\n                collision?.addLoc(x, z, loc.width, loc.length, angle, loc.blockrange);\n            }\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 2, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle * 512, World.ROTATION_WALL_TYPE[angle]);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_OFFSET.id) {\n            let offset = 16;\n            if (scene) {\n                const width = scene.getWallBitset(level, x, z);\n                if (width > 0) {\n                    offset = _config_LocType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get((width >> 14) & 0x7fff).wallwidth;\n                }\n            }\n            scene?.setWallDecoration(level, x, z, y, World.WALL_DECORATION_ROTATION_FORWARD_X[angle] * offset, World.WALL_DECORATION_ROTATION_FORWARD_Z[angle] * offset, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle * 512, World.ROTATION_WALL_TYPE[angle]);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_DIAGONAL_OFFSET.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle, 256);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_DIAGONAL_NOOFFSET.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle, 512);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n        else if (shape === _LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_DIAGONAL_BOTH.id) {\n            scene?.setWallDecoration(level, x, z, y, 0, 0, bitset, loc.getModel(_LocShape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].WALLDECOR_STRAIGHT_NOOFFSET.id, _LocAngle__WEBPACK_IMPORTED_MODULE_9__[\"default\"].WEST, heightSW, heightSE, heightNW, heightNE, -1), info, angle, 768);\n            if (loc.anim !== -1) {\n                locs.addTail(new _entity_LocEntity__WEBPACK_IMPORTED_MODULE_6__[\"default\"](locId, level, 1, x, z, _config_SeqType__WEBPACK_IMPORTED_MODULE_7__[\"default\"].instances[loc.anim], true));\n            }\n        }\n    };\n    getDrawLevel = (level, stx, stz) => {\n        if ((this.levelTileFlags[level][stx][stz] & 0x8) === 0) {\n            return level <= 0 || (this.levelTileFlags[1][stx][stz] & 0x2) === 0 ? level : level - 1;\n        }\n        return 0;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/World.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/World3D.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/dash3d/World3D.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ World3D)\n/* harmony export */ });\n/* harmony import */ var _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/Draw3D */ \"./src/js/jagex2/graphics/Draw3D.ts\");\n/* harmony import */ var _type_Loc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type/Loc */ \"./src/js/jagex2/dash3d/type/Loc.ts\");\n/* harmony import */ var _type_Tile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type/Tile */ \"./src/js/jagex2/dash3d/type/Tile.ts\");\n/* harmony import */ var _type_Occluder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type/Occluder */ \"./src/js/jagex2/dash3d/type/Occluder.ts\");\n/* harmony import */ var _CollisionMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CollisionMap */ \"./src/js/jagex2/dash3d/CollisionMap.ts\");\n/* harmony import */ var _type_GroundDecoration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./type/GroundDecoration */ \"./src/js/jagex2/dash3d/type/GroundDecoration.ts\");\n/* harmony import */ var _type_Wall__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./type/Wall */ \"./src/js/jagex2/dash3d/type/Wall.ts\");\n/* harmony import */ var _type_WallDecoration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./type/WallDecoration */ \"./src/js/jagex2/dash3d/type/WallDecoration.ts\");\n/* harmony import */ var _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../datastruct/LinkList */ \"./src/js/jagex2/datastruct/LinkList.ts\");\n/* harmony import */ var _type_ObjStack__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./type/ObjStack */ \"./src/js/jagex2/dash3d/type/ObjStack.ts\");\n/* harmony import */ var _type_TileUnderlay__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./type/TileUnderlay */ \"./src/js/jagex2/dash3d/type/TileUnderlay.ts\");\n/* harmony import */ var _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../graphics/Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./type/TileOverlay */ \"./src/js/jagex2/dash3d/type/TileOverlay.ts\");\n/* harmony import */ var _type_TileOverlayShape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./type/TileOverlayShape */ \"./src/js/jagex2/dash3d/type/TileOverlayShape.ts\");\n/* harmony import */ var _LocAngle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./LocAngle */ \"./src/js/jagex2/dash3d/LocAngle.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass World3D {\n    static visibilityMatrix = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.TypedArray4d(8, 32, 51, 51, false);\n    static locBuffer = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.TypedArray1d(100, null);\n    static levelOccluderCount = new Int32Array(_CollisionMap__WEBPACK_IMPORTED_MODULE_4__[\"default\"].LEVELS);\n    static levelOccluders = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.TypedArray2d(_CollisionMap__WEBPACK_IMPORTED_MODULE_4__[\"default\"].LEVELS, 500, null);\n    static activeOccluders = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.TypedArray1d(500, null);\n    static drawTileQueue = new _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_8__[\"default\"]();\n    static cycle = 0;\n    static viewportLeft = 0;\n    static viewportTop = 0;\n    static viewportRight = 0;\n    static viewportBottom = 0;\n    static viewportCenterX = 0;\n    static viewportCenterY = 0;\n    static sinEyePitch = 0;\n    static cosEyePitch = 0;\n    static sinEyeYaw = 0;\n    static cosEyeYaw = 0;\n    static eyeX = 0;\n    static eyeY = 0;\n    static eyeZ = 0;\n    static eyeTileX = 0;\n    static eyeTileZ = 0;\n    static minDrawTileX = 0;\n    static maxDrawTileX = 0;\n    static minDrawTileZ = 0;\n    static maxDrawTileZ = 0;\n    static topLevel = 0;\n    static tilesRemaining = 0;\n    static takingInput = false;\n    static visibilityMap = null;\n    static FRONT_WALL_TYPES = Uint8Array.of(19, 55, 38, 155, 255, 110, 137, 205, 76);\n    static DIRECTION_ALLOW_WALL_CORNER_TYPE = Uint8Array.of(160, 192, 80, 96, 0, 144, 80, 48, 160);\n    static BACK_WALL_TYPES = Uint8Array.of(76, 8, 137, 4, 0, 1, 38, 2, 19);\n    static WALL_CORNER_TYPE_16_BLOCK_LOC_SPANS = Int8Array.of(0, 0, 2, 0, 0, 2, 1, 1, 0);\n    static WALL_CORNER_TYPE_32_BLOCK_LOC_SPANS = Int8Array.of(2, 0, 0, 2, 0, 0, 0, 4, 4);\n    static WALL_CORNER_TYPE_64_BLOCK_LOC_SPANS = Int8Array.of(0, 4, 4, 8, 0, 0, 8, 0, 0);\n    static WALL_CORNER_TYPE_128_BLOCK_LOC_SPANS = Int8Array.of(1, 1, 0, 0, 0, 8, 0, 0, 8);\n    static WALL_DECORATION_INSET_X = Int8Array.of(53, -53, -53, 53);\n    static WALL_DECORATION_INSET_Z = Int8Array.of(-53, -53, 53, 53);\n    static WALL_DECORATION_OUTSET_X = Int8Array.of(-45, 45, 45, -45);\n    static WALL_DECORATION_OUTSET_Z = Int8Array.of(45, 45, -45, -45);\n    // prettier-ignore\n    static MINIMAP_TILE_MASK = [\n        new Int8Array(16),\n        Int8Array.of(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), // PLAIN_SHAPE\n        Int8Array.of(1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1), // DIAGONAL_SHAPE\n        Int8Array.of(1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0), // LEFT_SEMI_DIAGONAL_SMALL_SHAPE\n        Int8Array.of(0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1), // RIGHT_SEMI_DIAGONAL_SMALL_SHAPE\n        Int8Array.of(0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), // LEFT_SEMI_DIAGONAL_BIG_SHAPE\n        Int8Array.of(1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1), // RIGHT_SEMI_DIAGONAL_BIG_SHAPE\n        Int8Array.of(1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0), // HALF_SQUARE_SHAPE\n        Int8Array.of(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0), // CORNER_SMALL_SHAPE\n        Int8Array.of(1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1), // CORNER_BIG_SHAPE\n        Int8Array.of(1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0), // FAN_SMALL_SHAPE\n        Int8Array.of(0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1), // FAN_BIG_SHAPE\n        Int8Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1) // TRAPEZIUM_SHAPE\n    ];\n    // prettier-ignore\n    static MINIMAP_TILE_ROTATION_MAP = [\n        Int8Array.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15),\n        Int8Array.of(12, 8, 4, 0, 13, 9, 5, 1, 14, 10, 6, 2, 15, 11, 7, 3),\n        Int8Array.of(15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0),\n        Int8Array.of(3, 7, 11, 15, 2, 6, 10, 14, 1, 5, 9, 13, 0, 4, 8, 12),\n    ];\n    // prettier-ignore\n    static TEXTURE_HSL = Int32Array.of(41, 39248, 41, 4643, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 43086, 41, 41, 41, 41, 41, 41, 41, 8602, 41, 28992, 41, 41, 41, 41, 41, 5056, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 3131, 41, 41, 41);\n    static activeOccluderCount = 0;\n    static mouseX = 0;\n    static mouseY = 0;\n    static clickTileX = -1;\n    static clickTileZ = -1;\n    static lowMemory = true;\n    static init = (viewportWidth, viewportHeight, frustumStart, frustumEnd, pitchDistance) => {\n        this.viewportLeft = 0;\n        this.viewportTop = 0;\n        this.viewportRight = viewportWidth;\n        this.viewportBottom = viewportHeight;\n        this.viewportCenterX = (viewportWidth / 2) | 0;\n        this.viewportCenterY = (viewportHeight / 2) | 0;\n        const matrix = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.TypedArray4d(9, 32, 53, 53, false);\n        for (let pitch = 128; pitch <= 384; pitch += 32) {\n            for (let yaw = 0; yaw < 2048; yaw += 64) {\n                this.sinEyePitch = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sin[pitch];\n                this.cosEyePitch = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cos[pitch];\n                this.sinEyeYaw = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sin[yaw];\n                this.cosEyeYaw = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cos[yaw];\n                const pitchLevel = ((pitch - 128) / 32) | 0;\n                const yawLevel = (yaw / 64) | 0;\n                for (let dx = -26; dx <= 26; dx++) {\n                    for (let dz = -26; dz <= 26; dz++) {\n                        const x = dx * 128;\n                        const z = dz * 128;\n                        let visible = false;\n                        for (let y = -frustumStart; y <= frustumEnd; y += 128) {\n                            if (this.testPoint(x, z, pitchDistance[pitchLevel] + y)) {\n                                visible = true;\n                                break;\n                            }\n                        }\n                        matrix[pitchLevel][yawLevel][dx + 25 + 1][dz + 25 + 1] = visible;\n                    }\n                }\n            }\n        }\n        for (let pitchLevel = 0; pitchLevel < 8; pitchLevel++) {\n            for (let yawLevel = 0; yawLevel < 32; yawLevel++) {\n                for (let x = -25; x < 25; x++) {\n                    for (let z = -25; z < 25; z++) {\n                        let visible = false;\n                        check_areas: for (let dx = -1; dx <= 1; dx++) {\n                            for (let dz = -1; dz <= 1; dz++) {\n                                if (matrix[pitchLevel][yawLevel][x + dx + 25 + 1][z + dz + 25 + 1]) {\n                                    visible = true;\n                                    break check_areas;\n                                }\n                                if (matrix[pitchLevel][(yawLevel + 1) % 31][x + dx + 25 + 1][z + dz + 25 + 1]) {\n                                    visible = true;\n                                    break check_areas;\n                                }\n                                if (matrix[pitchLevel + 1][yawLevel][x + dx + 25 + 1][z + dz + 25 + 1]) {\n                                    visible = true;\n                                    break check_areas;\n                                }\n                                if (matrix[pitchLevel + 1][(yawLevel + 1) % 31][x + dx + 25 + 1][z + dz + 25 + 1]) {\n                                    visible = true;\n                                    break check_areas;\n                                }\n                            }\n                        }\n                        this.visibilityMatrix[pitchLevel][yawLevel][x + 25][z + 25] = visible;\n                    }\n                }\n            }\n        }\n    };\n    static unload = () => {\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.locBuffer = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.levelOccluderCount = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.levelOccluders = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.drawTileQueue = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.visibilityMatrix = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.activeOccluders = null;\n        this.visibilityMap = null;\n        console.log('World3D unloaded!');\n    };\n    static addOccluder = (level, type, minX, minY, minZ, maxX, maxY, maxZ) => {\n        World3D.levelOccluders[level][World3D.levelOccluderCount[level]++] = new _type_Occluder__WEBPACK_IMPORTED_MODULE_3__[\"default\"]((minX / 128) | 0, (maxX / 128) | 0, (minZ / 128) | 0, (maxZ / 128) | 0, type, minX, maxX, minZ, maxZ, minY, maxY);\n    };\n    static testPoint = (x, z, y) => {\n        const px = (z * this.sinEyeYaw + x * this.cosEyeYaw) >> 16;\n        const tmp = (z * this.cosEyeYaw - x * this.sinEyeYaw) >> 16;\n        const pz = (y * this.sinEyePitch + tmp * this.cosEyePitch) >> 16;\n        const py = (y * this.cosEyePitch - tmp * this.sinEyePitch) >> 16;\n        if (pz < 50 || pz > 3500) {\n            return false;\n        }\n        const viewportX = this.viewportCenterX + (((px << 9) / pz) | 0);\n        const viewportY = this.viewportCenterY + (((py << 9) / pz) | 0);\n        return viewportX >= this.viewportLeft && viewportX <= this.viewportRight && viewportY >= this.viewportTop && viewportY <= this.viewportBottom;\n    };\n    // ----\n    // constructor\n    maxLevel;\n    maxTileX;\n    maxTileZ;\n    levelHeightmaps;\n    levelTiles;\n    temporaryLocs;\n    levelTileOcclusionCycles;\n    mergeIndexA;\n    mergeIndexB;\n    // runtime\n    temporaryLocCount = 0;\n    minLevel = 0;\n    tmpMergeIndex = 0;\n    constructor(levelHeightmaps, maxTileZ, maxLevel, maxTileX) {\n        this.maxLevel = maxLevel;\n        this.maxTileX = maxTileX;\n        this.maxTileZ = maxTileZ;\n        this.levelTiles = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.TypedArray3d(maxLevel, maxTileX, maxTileZ, null);\n        this.levelTileOcclusionCycles = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.Int32Array3d(maxLevel, maxTileX + 1, maxTileZ + 1);\n        this.levelHeightmaps = levelHeightmaps;\n        this.temporaryLocs = new _util_Arrays__WEBPACK_IMPORTED_MODULE_15__.TypedArray1d(5000, null);\n        this.mergeIndexA = new Int32Array(10000);\n        this.mergeIndexB = new Int32Array(10000);\n        this.reset();\n    }\n    reset = () => {\n        for (let level = 0; level < this.maxLevel; level++) {\n            for (let x = 0; x < this.maxTileX; x++) {\n                for (let z = 0; z < this.maxTileZ; z++) {\n                    this.levelTiles[level][x][z] = null;\n                }\n            }\n        }\n        for (let l = 0; l < _CollisionMap__WEBPACK_IMPORTED_MODULE_4__[\"default\"].LEVELS; l++) {\n            for (let o = 0; o < World3D.levelOccluderCount[l]; o++) {\n                World3D.levelOccluders[l][o] = null;\n            }\n            World3D.levelOccluderCount[l] = 0;\n        }\n        for (let i = 0; i < this.temporaryLocCount; i++) {\n            this.temporaryLocs[i] = null;\n        }\n        this.temporaryLocCount = 0;\n        World3D.locBuffer.fill(null);\n    };\n    setMinLevel = (level) => {\n        this.minLevel = level;\n        for (let stx = 0; stx < this.maxTileX; stx++) {\n            for (let stz = 0; stz < this.maxTileZ; stz++) {\n                this.levelTiles[level][stx][stz] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](level, stx, stz);\n            }\n        }\n    };\n    setBridge = (stx, stz) => {\n        const ground = this.levelTiles[0][stx][stz];\n        for (let level = 0; level < 3; level++) {\n            this.levelTiles[level][stx][stz] = this.levelTiles[level + 1][stx][stz];\n            const tile = this.levelTiles[level][stx][stz];\n            if (tile) {\n                tile.level--;\n            }\n        }\n        if (!this.levelTiles[0][stx][stz]) {\n            this.levelTiles[0][stx][stz] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, stx, stz);\n        }\n        const tile = this.levelTiles[0][stx][stz];\n        if (tile) {\n            tile.bridge = ground;\n        }\n        this.levelTiles[3][stx][stz] = null;\n    };\n    setDrawLevel = (level, stx, stz, drawLevel) => {\n        const tile = this.levelTiles[level][stx][stz];\n        if (!tile) {\n            return;\n        }\n        tile.drawLevel = drawLevel;\n    };\n    setTile = (level, x, z, shape, angle, textureId, southwestY, southeastY, northeastY, northwestY, southwestColor, southeastColor, northeastColor, northwestColor, southwestColor2, southeastColor2, northeastColor2, northwestColor2, backgroundRgb, foregroundRgb) => {\n        if (shape === _type_TileOverlayShape__WEBPACK_IMPORTED_MODULE_13__[\"default\"].PLAIN) {\n            for (let l = level; l >= 0; l--) {\n                if (!this.levelTiles[l][x][z]) {\n                    this.levelTiles[l][x][z] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](l, x, z);\n                }\n            }\n            const tile = this.levelTiles[level][x][z];\n            if (tile) {\n                tile.underlay = new _type_TileUnderlay__WEBPACK_IMPORTED_MODULE_10__[\"default\"](southwestColor, southeastColor, northeastColor, northwestColor, -1, backgroundRgb, false);\n            }\n        }\n        else if (shape === _type_TileOverlayShape__WEBPACK_IMPORTED_MODULE_13__[\"default\"].DIAGONAL) {\n            for (let l = level; l >= 0; l--) {\n                if (!this.levelTiles[l][x][z]) {\n                    this.levelTiles[l][x][z] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](l, x, z);\n                }\n            }\n            const tile = this.levelTiles[level][x][z];\n            if (tile) {\n                tile.underlay = new _type_TileUnderlay__WEBPACK_IMPORTED_MODULE_10__[\"default\"](southwestColor2, southeastColor2, northeastColor2, northwestColor2, textureId, foregroundRgb, southwestY === southeastY && southwestY === northeastY && southwestY === northwestY);\n            }\n        }\n        else {\n            for (let l = level; l >= 0; l--) {\n                if (!this.levelTiles[l][x][z]) {\n                    this.levelTiles[l][x][z] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](l, x, z);\n                }\n            }\n            const tile = this.levelTiles[level][x][z];\n            if (tile) {\n                tile.overlay = new _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"](x, shape, southeastColor2, southeastY, northeastColor, angle, southwestColor, northwestY, foregroundRgb, southwestColor2, textureId, northwestColor2, backgroundRgb, northeastY, northeastColor2, northwestColor, southwestY, z, southeastColor);\n            }\n        }\n    };\n    addGroundDecoration = (model, tileLevel, tileX, tileZ, y, bitset, info) => {\n        if (!this.levelTiles[tileLevel][tileX][tileZ]) {\n            this.levelTiles[tileLevel][tileX][tileZ] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](tileLevel, tileX, tileZ);\n        }\n        const tile = this.levelTiles[tileLevel][tileX][tileZ];\n        if (tile) {\n            tile.groundDecoration = new _type_GroundDecoration__WEBPACK_IMPORTED_MODULE_5__[\"default\"](y, tileX * 128 + 64, tileZ * 128 + 64, model, bitset, info);\n        }\n    };\n    removeGroundDecoration = (level, x, z) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        tile.groundDecoration = null;\n    };\n    addObjStack = (stx, stz, y, level, bitset, topObj, middleObj, bottomObj) => {\n        let stackOffset = 0;\n        const tile = this.levelTiles[level][stx][stz];\n        if (tile) {\n            for (let l = 0; l < tile.locCount; l++) {\n                const loc = tile.locs[l];\n                if (!loc || !loc.model) {\n                    continue;\n                }\n                const height = loc.model.objRaise;\n                if (height > stackOffset) {\n                    stackOffset = height;\n                }\n            }\n        }\n        else {\n            this.levelTiles[level][stx][stz] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](level, stx, stz);\n        }\n        const tile2 = this.levelTiles[level][stx][stz];\n        if (tile2) {\n            tile2.objStack = new _type_ObjStack__WEBPACK_IMPORTED_MODULE_9__[\"default\"](y, stx * 128 + 64, stz * 128 + 64, topObj, middleObj, bottomObj, bitset, stackOffset);\n        }\n    };\n    removeObjStack = (level, x, z) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        tile.objStack = null;\n    };\n    addWall = (level, tileX, tileZ, y, typeA, typeB, modelA, modelB, bitset, info) => {\n        if (!modelA && !modelB) {\n            return;\n        }\n        for (let l = level; l >= 0; l--) {\n            if (!this.levelTiles[l][tileX][tileZ]) {\n                this.levelTiles[l][tileX][tileZ] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](l, tileX, tileZ);\n            }\n        }\n        const tile = this.levelTiles[level][tileX][tileZ];\n        if (tile) {\n            tile.wall = new _type_Wall__WEBPACK_IMPORTED_MODULE_6__[\"default\"](y, tileX * 128 + 64, tileZ * 128 + 64, typeA, typeB, modelA, modelB, bitset, info);\n        }\n    };\n    removeWall = (level, x, z, force) => {\n        const tile = this.levelTiles[level][x][z];\n        if (force === 1 && tile) {\n            tile.wall = null;\n        }\n    };\n    setWallDecoration = (level, tileX, tileZ, y, offsetX, offsetZ, bitset, model, info, angle, type) => {\n        if (!model) {\n            return;\n        }\n        for (let l = level; l >= 0; l--) {\n            if (!this.levelTiles[l][tileX][tileZ]) {\n                this.levelTiles[l][tileX][tileZ] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](l, tileX, tileZ);\n            }\n        }\n        const tile = this.levelTiles[level][tileX][tileZ];\n        if (tile) {\n            tile.wallDecoration = new _type_WallDecoration__WEBPACK_IMPORTED_MODULE_7__[\"default\"](y, tileX * 128 + offsetX + 64, tileZ * 128 + offsetZ + 64, type, angle, model, bitset, info);\n        }\n    };\n    removeWallDecoration = (level, x, z) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        tile.wallDecoration = null;\n    };\n    setWallDecorationOffset = (level, x, z, offset) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        const decor = tile.wallDecoration;\n        if (!decor) {\n            return;\n        }\n        const sx = x * 128 + 64;\n        const sz = z * 128 + 64;\n        decor.x = sx + ((((decor.x - sx) * offset) / 16) | 0);\n        decor.z = sz + ((((decor.z - sz) * offset) / 16) | 0);\n    };\n    setWallDecorationModel = (level, x, z, model) => {\n        if (!model) {\n            return;\n        }\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        const decor = tile.wallDecoration;\n        if (!decor) {\n            return;\n        }\n        decor.model = model;\n    };\n    setGroundDecorationModel = (level, x, z, model) => {\n        if (!model) {\n            return;\n        }\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        const decor = tile.groundDecoration;\n        if (!decor) {\n            return;\n        }\n        decor.model = model;\n    };\n    setWallModel = (level, x, z, model) => {\n        if (!model) {\n            return;\n        }\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        const wall = tile.wall;\n        if (!wall) {\n            return;\n        }\n        wall.modelA = model;\n    };\n    setWallModels = (x, z, level, modelA, modelB) => {\n        if (!modelA) {\n            return;\n        }\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        const wall = tile.wall;\n        if (!wall) {\n            return;\n        }\n        wall.modelA = modelA;\n        wall.modelB = modelB;\n    };\n    addLoc = (level, tileX, tileZ, y, model, entity, bitset, info, width, length, yaw) => {\n        if (!model && !entity) {\n            return true;\n        }\n        const sceneX = tileX * 128 + width * 64;\n        const sceneZ = tileZ * 128 + length * 64;\n        return this.addLoc2(sceneX, sceneZ, y, level, tileX, tileZ, width, length, model, entity, bitset, info, yaw, false);\n    };\n    addTemporary = (level, x, y, z, model, entity, bitset, yaw, padding, forwardPadding) => {\n        if (!model && !entity) {\n            return true;\n        }\n        let x0 = x - padding;\n        let z0 = z - padding;\n        let x1 = x + padding;\n        let z1 = z + padding;\n        if (forwardPadding) {\n            if (yaw > 640 && yaw < 1408) {\n                z1 += 128;\n            }\n            if (yaw > 1152 && yaw < 1920) {\n                x1 += 128;\n            }\n            if (yaw > 1664 || yaw < 384) {\n                z0 -= 128;\n            }\n            if (yaw > 128 && yaw < 896) {\n                x0 -= 128;\n            }\n        }\n        x0 = (x0 / 128) | 0;\n        z0 = (z0 / 128) | 0;\n        x1 = (x1 / 128) | 0;\n        z1 = (z1 / 128) | 0;\n        return this.addLoc2(x, z, y, level, x0, z0, x1 + 1 - x0, z1 - z0 + 1, model, entity, bitset, 0, yaw, true);\n    };\n    addTemporary2 = (level, x, y, z, minTileX, minTileZ, maxTileX, maxTileZ, model, entity, bitset, yaw) => {\n        return (!model && !entity) || this.addLoc2(x, z, y, level, minTileX, minTileZ, maxTileX + 1 - minTileX, maxTileZ - minTileZ + 1, model, entity, bitset, 0, yaw, true);\n    };\n    removeLoc = (level, x, z) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        for (let l = 0; l < tile.locCount; l++) {\n            const loc = tile.locs[l];\n            if (loc && ((loc.bitset >> 29) & 0x3) === 2 && loc.minSceneTileX === x && loc.minSceneTileZ === z) {\n                this.removeLoc2(loc);\n                return;\n            }\n        }\n    };\n    setLocModel = (level, x, z, model) => {\n        if (!model) {\n            return;\n        }\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        for (let i = 0; i < tile.locCount; i++) {\n            const loc = tile.locs[i];\n            if (loc && ((loc.bitset >> 29) & 0x3) === 2) {\n                loc.model = model;\n                return;\n            }\n        }\n    };\n    clearTemporaryLocs = () => {\n        for (let i = 0; i < this.temporaryLocCount; i++) {\n            const loc = this.temporaryLocs[i];\n            if (loc) {\n                this.removeLoc2(loc);\n            }\n            this.temporaryLocs[i] = null;\n        }\n        this.temporaryLocCount = 0;\n    };\n    getWallBitset = (level, x, z) => {\n        const tile = this.levelTiles[level][x][z];\n        return !tile || !tile.wall ? 0 : tile.wall.bitset;\n    };\n    getWallDecorationBitset = (level, z, x) => {\n        const tile = this.levelTiles[level][x][z];\n        return !tile || !tile.wallDecoration ? 0 : tile.wallDecoration.bitset;\n    };\n    getLocBitset = (level, x, z) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return 0;\n        }\n        for (let l = 0; l < tile.locCount; l++) {\n            const loc = tile.locs[l];\n            if (loc && ((loc.bitset >> 29) & 0x3) === 2 && loc.minSceneTileX === x && loc.minSceneTileZ === z) {\n                return loc.bitset;\n            }\n        }\n        return 0;\n    };\n    getGroundDecorationBitset = (level, x, z) => {\n        const tile = this.levelTiles[level][x][z];\n        return !tile || !tile.groundDecoration ? 0 : tile.groundDecoration.bitset;\n    };\n    getInfo = (level, x, z, bitset) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return -1;\n        }\n        else if (tile.wall && tile.wall.bitset === bitset) {\n            return tile.wall.info & 0xff;\n        }\n        else if (tile.wallDecoration && tile.wallDecoration.bitset === bitset) {\n            return tile.wallDecoration.info & 0xff;\n        }\n        else if (tile.groundDecoration && tile.groundDecoration.bitset === bitset) {\n            return tile.groundDecoration.info & 0xff;\n        }\n        else {\n            for (let i = 0; i < tile.locCount; i++) {\n                const loc = tile.locs[i];\n                if (loc && loc.bitset === bitset) {\n                    return loc.info & 0xff;\n                }\n            }\n            return -1;\n        }\n    };\n    buildModels = (lightAmbient, lightAttenuation, lightSrcX, lightSrcY, lightSrcZ) => {\n        const lightMagnitude = Math.sqrt(lightSrcX * lightSrcX + lightSrcY * lightSrcY + lightSrcZ * lightSrcZ) | 0;\n        const attenuation = (lightAttenuation * lightMagnitude) >> 8;\n        for (let level = 0; level < this.maxLevel; level++) {\n            for (let tileX = 0; tileX < this.maxTileX; tileX++) {\n                for (let tileZ = 0; tileZ < this.maxTileZ; tileZ++) {\n                    const tile = this.levelTiles[level][tileX][tileZ];\n                    if (!tile) {\n                        continue;\n                    }\n                    const wall = tile.wall;\n                    if (wall && wall.modelA && wall.modelA.vertexNormal) {\n                        this.mergeLocNormals(level, tileX, tileZ, 1, 1, wall.modelA);\n                        if (wall.modelB && wall.modelB.vertexNormal) {\n                            this.mergeLocNormals(level, tileX, tileZ, 1, 1, wall.modelB);\n                            this.mergeNormals(wall.modelA, wall.modelB, 0, 0, 0, false);\n                            wall.modelB.applyLighting(lightAmbient, attenuation, lightSrcX, lightSrcY, lightSrcZ);\n                        }\n                        wall.modelA.applyLighting(lightAmbient, attenuation, lightSrcX, lightSrcY, lightSrcZ);\n                    }\n                    for (let i = 0; i < tile.locCount; i++) {\n                        const loc = tile.locs[i];\n                        if (loc && loc.model && loc.model.vertexNormal) {\n                            this.mergeLocNormals(level, tileX, tileZ, loc.maxSceneTileX + 1 - loc.minSceneTileX, loc.maxSceneTileZ - loc.minSceneTileZ + 1, loc.model);\n                            loc.model.applyLighting(lightAmbient, attenuation, lightSrcX, lightSrcY, lightSrcZ);\n                        }\n                    }\n                    const decor = tile.groundDecoration;\n                    if (decor && decor.model && decor.model.vertexNormal) {\n                        this.mergeGroundDecorationNormals(level, tileX, tileZ, decor.model);\n                        decor.model.applyLighting(lightAmbient, attenuation, lightSrcX, lightSrcY, lightSrcZ);\n                    }\n                }\n            }\n        }\n    };\n    mergeGroundDecorationNormals = (level, tileX, tileZ, model) => {\n        if (tileX < this.maxTileX) {\n            const tile = this.levelTiles[level][tileX + 1][tileZ];\n            if (tile && tile.groundDecoration && tile.groundDecoration.model && tile.groundDecoration.model.vertexNormal) {\n                this.mergeNormals(model, tile.groundDecoration.model, 128, 0, 0, true);\n            }\n        }\n        if (tileZ < this.maxTileX) {\n            const tile = this.levelTiles[level][tileX][tileZ + 1];\n            if (tile && tile.groundDecoration && tile.groundDecoration.model && tile.groundDecoration.model.vertexNormal) {\n                this.mergeNormals(model, tile.groundDecoration.model, 0, 0, 128, true);\n            }\n        }\n        if (tileX < this.maxTileX && tileZ < this.maxTileZ) {\n            const tile = this.levelTiles[level][tileX + 1][tileZ + 1];\n            if (tile && tile.groundDecoration && tile.groundDecoration.model && tile.groundDecoration.model.vertexNormal) {\n                this.mergeNormals(model, tile.groundDecoration.model, 128, 0, 128, true);\n            }\n        }\n        if (tileX < this.maxTileX && tileZ > 0) {\n            const tile = this.levelTiles[level][tileX + 1][tileZ - 1];\n            if (tile && tile.groundDecoration && tile.groundDecoration.model && tile.groundDecoration.model.vertexNormal) {\n                this.mergeNormals(model, tile.groundDecoration.model, 128, 0, -128, true);\n            }\n        }\n    };\n    mergeLocNormals = (level, tileX, tileZ, tileSizeX, tileSizeZ, model) => {\n        let allowFaceRemoval = true;\n        let minTileX = tileX;\n        const maxTileX = tileX + tileSizeX;\n        const minTileZ = tileZ - 1;\n        const maxTileZ = tileZ + tileSizeZ;\n        for (let l = level; l <= level + 1; l++) {\n            if (l === this.maxLevel) {\n                continue;\n            }\n            for (let x = minTileX; x <= maxTileX; x++) {\n                if (x < 0 || x >= this.maxTileX) {\n                    continue;\n                }\n                for (let z = minTileZ; z <= maxTileZ; z++) {\n                    if (z < 0 || z >= this.maxTileZ || (allowFaceRemoval && x < maxTileX && z < maxTileZ && (z >= tileZ || x === tileX))) {\n                        continue;\n                    }\n                    const tile = this.levelTiles[l][x][z];\n                    if (!tile) {\n                        continue;\n                    }\n                    const offsetX = (x - tileX) * 128 + (1 - tileSizeX) * 64;\n                    const offsetZ = (z - tileZ) * 128 + (1 - tileSizeZ) * 64;\n                    const offsetY = (((this.levelHeightmaps[l][x][z] + this.levelHeightmaps[l][x + 1][z] + this.levelHeightmaps[l][x][z + 1] + this.levelHeightmaps[l][x + 1][z + 1]) / 4) | 0) -\n                        (((this.levelHeightmaps[level][tileX][tileZ] + this.levelHeightmaps[level][tileX + 1][tileZ] + this.levelHeightmaps[level][tileX][tileZ + 1] + this.levelHeightmaps[level][tileX + 1][tileZ + 1]) / 4) | 0);\n                    const wall = tile.wall;\n                    if (wall && wall.modelA && wall.modelA.vertexNormal) {\n                        this.mergeNormals(model, wall.modelA, offsetX, offsetY, offsetZ, allowFaceRemoval);\n                    }\n                    if (wall && wall.modelB && wall.modelB.vertexNormal) {\n                        this.mergeNormals(model, wall.modelB, offsetX, offsetY, offsetZ, allowFaceRemoval);\n                    }\n                    for (let i = 0; i < tile.locCount; i++) {\n                        const loc = tile.locs[i];\n                        if (!loc || !loc.model || !loc.model.vertexNormal) {\n                            continue;\n                        }\n                        const locTileSizeX = loc.maxSceneTileX + 1 - loc.minSceneTileX;\n                        const locTileSizeZ = loc.maxSceneTileZ + 1 - loc.minSceneTileZ;\n                        this.mergeNormals(model, loc.model, (loc.minSceneTileX - tileX) * 128 + (locTileSizeX - tileSizeX) * 64, offsetY, (loc.minSceneTileZ - tileZ) * 128 + (locTileSizeZ - tileSizeZ) * 64, allowFaceRemoval);\n                    }\n                }\n            }\n            minTileX--;\n            allowFaceRemoval = false;\n        }\n    };\n    mergeNormals = (modelA, modelB, offsetX, offsetY, offsetZ, allowFaceRemoval) => {\n        this.tmpMergeIndex++;\n        let merged = 0;\n        const vertexX = modelB.vertexX;\n        const vertexCountB = modelB.vertexCount;\n        if (modelA.vertexNormal && modelA.vertexNormalOriginal) {\n            for (let vertexA = 0; vertexA < modelA.vertexCount; vertexA++) {\n                const normalA = modelA.vertexNormal[vertexA];\n                const originalNormalA = modelA.vertexNormalOriginal[vertexA];\n                if (originalNormalA && originalNormalA.w !== 0) {\n                    const y = modelA.vertexY[vertexA] - offsetY;\n                    if (y > modelB.minY) {\n                        continue;\n                    }\n                    const x = modelA.vertexX[vertexA] - offsetX;\n                    if (x < modelB.minX || x > modelB.maxX) {\n                        continue;\n                    }\n                    const z = modelA.vertexZ[vertexA] - offsetZ;\n                    if (z < modelB.minZ || z > modelB.maxZ) {\n                        continue;\n                    }\n                    if (modelB.vertexNormal && modelB.vertexNormalOriginal) {\n                        for (let vertexB = 0; vertexB < vertexCountB; vertexB++) {\n                            const normalB = modelB.vertexNormal[vertexB];\n                            const originalNormalB = modelB.vertexNormalOriginal[vertexB];\n                            if (x !== vertexX[vertexB] || z !== modelB.vertexZ[vertexB] || y !== modelB.vertexY[vertexB] || (originalNormalB && originalNormalB.w === 0)) {\n                                continue;\n                            }\n                            if (normalA && normalB && originalNormalB) {\n                                normalA.x += originalNormalB.x;\n                                normalA.y += originalNormalB.y;\n                                normalA.z += originalNormalB.z;\n                                normalA.w += originalNormalB.w;\n                                normalB.x += originalNormalA.x;\n                                normalB.y += originalNormalA.y;\n                                normalB.z += originalNormalA.z;\n                                normalB.w += originalNormalA.w;\n                                merged++;\n                            }\n                            this.mergeIndexA[vertexA] = this.tmpMergeIndex;\n                            this.mergeIndexB[vertexB] = this.tmpMergeIndex;\n                        }\n                    }\n                }\n            }\n        }\n        if (merged < 3 || !allowFaceRemoval) {\n            return;\n        }\n        if (modelA.faceInfo) {\n            for (let i = 0; i < modelA.faceCount; i++) {\n                if (this.mergeIndexA[modelA.faceVertexA[i]] === this.tmpMergeIndex && this.mergeIndexA[modelA.faceVertexB[i]] === this.tmpMergeIndex && this.mergeIndexA[modelA.faceVertexC[i]] === this.tmpMergeIndex) {\n                    modelA.faceInfo[i] = -1;\n                }\n            }\n        }\n        if (modelB.faceInfo) {\n            for (let i = 0; i < modelB.faceCount; i++) {\n                if (this.mergeIndexB[modelB.faceVertexA[i]] === this.tmpMergeIndex && this.mergeIndexB[modelB.faceVertexB[i]] === this.tmpMergeIndex && this.mergeIndexB[modelB.faceVertexC[i]] === this.tmpMergeIndex) {\n                    modelB.faceInfo[i] = -1;\n                }\n            }\n        }\n    };\n    drawMinimapTile = (level, x, z, dst, offset, step) => {\n        const tile = this.levelTiles[level][x][z];\n        if (!tile) {\n            return;\n        }\n        const underlay = tile.underlay;\n        if (underlay) {\n            const rgb = underlay.color;\n            if (rgb !== 0) {\n                for (let i = 0; i < 4; i++) {\n                    dst[offset] = rgb;\n                    dst[offset + 1] = rgb;\n                    dst[offset + 2] = rgb;\n                    dst[offset + 3] = rgb;\n                    offset += step;\n                }\n            }\n            return;\n        }\n        const overlay = tile.overlay;\n        if (!overlay) {\n            return;\n        }\n        const shape = overlay.shape;\n        const angle = overlay.angle;\n        const background = overlay.backgroundRgb;\n        const foreground = overlay.foregroundRgb;\n        const mask = World3D.MINIMAP_TILE_MASK[shape];\n        const rotation = World3D.MINIMAP_TILE_ROTATION_MAP[angle];\n        let off = 0;\n        if (background !== 0) {\n            for (let i = 0; i < 4; i++) {\n                dst[offset] = mask[rotation[off++]] === 0 ? background : foreground;\n                dst[offset + 1] = mask[rotation[off++]] === 0 ? background : foreground;\n                dst[offset + 2] = mask[rotation[off++]] === 0 ? background : foreground;\n                dst[offset + 3] = mask[rotation[off++]] === 0 ? background : foreground;\n                offset += step;\n            }\n            return;\n        }\n        for (let i = 0; i < 4; i++) {\n            if (mask[rotation[off++]] !== 0) {\n                dst[offset] = foreground;\n            }\n            if (mask[rotation[off++]] !== 0) {\n                dst[offset + 1] = foreground;\n            }\n            if (mask[rotation[off++]] !== 0) {\n                dst[offset + 2] = foreground;\n            }\n            if (mask[rotation[off++]] !== 0) {\n                dst[offset + 3] = foreground;\n            }\n            offset += step;\n        }\n    };\n    click = (mouseX, mouseY) => {\n        World3D.takingInput = true;\n        World3D.mouseX = mouseX;\n        World3D.mouseY = mouseY;\n        World3D.clickTileX = -1;\n        World3D.clickTileZ = -1;\n    };\n    draw = (eyeX, eyeY, eyeZ, topLevel, eyeYaw, eyePitch, loopCycle) => {\n        if (eyeX < 0) {\n            eyeX = 0;\n        }\n        else if (eyeX >= this.maxTileX * 128) {\n            eyeX = this.maxTileX * 128 - 1;\n        }\n        if (eyeZ < 0) {\n            eyeZ = 0;\n        }\n        else if (eyeZ >= this.maxTileZ * 128) {\n            eyeZ = this.maxTileZ * 128 - 1;\n        }\n        World3D.cycle++;\n        World3D.sinEyePitch = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sin[eyePitch];\n        World3D.cosEyePitch = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cos[eyePitch];\n        World3D.sinEyeYaw = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sin[eyeYaw];\n        World3D.cosEyeYaw = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cos[eyeYaw];\n        World3D.visibilityMap = World3D.visibilityMatrix[((eyePitch - 128) / 32) | 0][(eyeYaw / 64) | 0];\n        World3D.eyeX = eyeX;\n        World3D.eyeY = eyeY;\n        World3D.eyeZ = eyeZ;\n        World3D.eyeTileX = (eyeX / 128) | 0;\n        World3D.eyeTileZ = (eyeZ / 128) | 0;\n        World3D.topLevel = topLevel;\n        World3D.minDrawTileX = World3D.eyeTileX - 25;\n        if (World3D.minDrawTileX < 0) {\n            World3D.minDrawTileX = 0;\n        }\n        World3D.minDrawTileZ = World3D.eyeTileZ - 25;\n        if (World3D.minDrawTileZ < 0) {\n            World3D.minDrawTileZ = 0;\n        }\n        World3D.maxDrawTileX = World3D.eyeTileX + 25;\n        if (World3D.maxDrawTileX > this.maxTileX) {\n            World3D.maxDrawTileX = this.maxTileX;\n        }\n        World3D.maxDrawTileZ = World3D.eyeTileZ + 25;\n        if (World3D.maxDrawTileZ > this.maxTileZ) {\n            World3D.maxDrawTileZ = this.maxTileZ;\n        }\n        this.updateActiveOccluders();\n        World3D.tilesRemaining = 0;\n        for (let level = this.minLevel; level < this.maxLevel; level++) {\n            const tiles = this.levelTiles[level];\n            for (let x = World3D.minDrawTileX; x < World3D.maxDrawTileX; x++) {\n                for (let z = World3D.minDrawTileZ; z < World3D.maxDrawTileZ; z++) {\n                    const tile = tiles[x][z];\n                    if (!tile) {\n                        continue;\n                    }\n                    if (tile.drawLevel <= topLevel && (World3D.visibilityMap[x + 25 - World3D.eyeTileX][z + 25 - World3D.eyeTileZ] || this.levelHeightmaps[level][x][z] - eyeY >= 2000)) {\n                        tile.visible = true;\n                        tile.update = true;\n                        tile.containsLocs = tile.locCount > 0;\n                        World3D.tilesRemaining++;\n                    }\n                    else {\n                        tile.visible = false;\n                        tile.update = false;\n                        tile.checkLocSpans = 0;\n                    }\n                }\n            }\n        }\n        for (let level = this.minLevel; level < this.maxLevel; level++) {\n            const tiles = this.levelTiles[level];\n            for (let dx = -25; dx <= 0; dx++) {\n                const rightTileX = World3D.eyeTileX + dx;\n                const leftTileX = World3D.eyeTileX - dx;\n                if (rightTileX < World3D.minDrawTileX && leftTileX >= World3D.maxDrawTileX) {\n                    continue;\n                }\n                for (let dz = -25; dz <= 0; dz++) {\n                    const forwardTileZ = World3D.eyeTileZ + dz;\n                    const backwardTileZ = World3D.eyeTileZ - dz;\n                    let tile;\n                    if (rightTileX >= World3D.minDrawTileX) {\n                        if (forwardTileZ >= World3D.minDrawTileZ) {\n                            tile = tiles[rightTileX][forwardTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, true, loopCycle);\n                            }\n                        }\n                        if (backwardTileZ < World3D.maxDrawTileZ) {\n                            tile = tiles[rightTileX][backwardTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, true, loopCycle);\n                            }\n                        }\n                    }\n                    if (leftTileX < World3D.maxDrawTileX) {\n                        if (forwardTileZ >= World3D.minDrawTileZ) {\n                            tile = tiles[leftTileX][forwardTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, true, loopCycle);\n                            }\n                        }\n                        if (backwardTileZ < World3D.maxDrawTileZ) {\n                            tile = tiles[leftTileX][backwardTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, true, loopCycle);\n                            }\n                        }\n                    }\n                    if (World3D.tilesRemaining === 0) {\n                        World3D.takingInput = false;\n                        return;\n                    }\n                }\n            }\n        }\n        for (let level = this.minLevel; level < this.maxLevel; level++) {\n            const tiles = this.levelTiles[level];\n            for (let dx = -25; dx <= 0; dx++) {\n                const rightTileX = World3D.eyeTileX + dx;\n                const leftTileX = World3D.eyeTileX - dx;\n                if (rightTileX < World3D.minDrawTileX && leftTileX >= World3D.maxDrawTileX) {\n                    continue;\n                }\n                for (let dz = -25; dz <= 0; dz++) {\n                    const forwardTileZ = World3D.eyeTileZ + dz;\n                    const backgroundTileZ = World3D.eyeTileZ - dz;\n                    let tile;\n                    if (rightTileX >= World3D.minDrawTileX) {\n                        if (forwardTileZ >= World3D.minDrawTileZ) {\n                            tile = tiles[rightTileX][forwardTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, false, loopCycle);\n                            }\n                        }\n                        if (backgroundTileZ < World3D.maxDrawTileZ) {\n                            tile = tiles[rightTileX][backgroundTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, false, loopCycle);\n                            }\n                        }\n                    }\n                    if (leftTileX < World3D.maxDrawTileX) {\n                        if (forwardTileZ >= World3D.minDrawTileZ) {\n                            tile = tiles[leftTileX][forwardTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, false, loopCycle);\n                            }\n                        }\n                        if (backgroundTileZ < World3D.maxDrawTileZ) {\n                            tile = tiles[leftTileX][backgroundTileZ];\n                            if (tile && tile.visible) {\n                                this.drawTile(tile, false, loopCycle);\n                            }\n                        }\n                    }\n                    if (World3D.tilesRemaining === 0) {\n                        World3D.takingInput = false;\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    addLoc2 = (x, z, y, level, tileX, tileZ, tileSizeX, tileSizeZ, model, entity, bitset, info, yaw, temporary) => {\n        if (!model && !entity) {\n            return false;\n        }\n        for (let tx = tileX; tx < tileX + tileSizeX; tx++) {\n            for (let tz = tileZ; tz < tileZ + tileSizeZ; tz++) {\n                if (tx < 0 || tz < 0 || tx >= this.maxTileX || tz >= this.maxTileZ) {\n                    return false;\n                }\n                const tile = this.levelTiles[level][tx][tz];\n                if (tile && tile.locCount >= 5) {\n                    return false;\n                }\n            }\n        }\n        const loc = new _type_Loc__WEBPACK_IMPORTED_MODULE_1__[\"default\"](level, y, x, z, model, entity, yaw, tileX, tileX + tileSizeX - 1, tileZ, tileZ + tileSizeZ - 1, bitset, info);\n        for (let tx = tileX; tx < tileX + tileSizeX; tx++) {\n            for (let tz = tileZ; tz < tileZ + tileSizeZ; tz++) {\n                let spans = 0;\n                if (tx > tileX) {\n                    spans |= 0x1;\n                }\n                if (tx < tileX + tileSizeX - 1) {\n                    spans += 0x4;\n                }\n                if (tz > tileZ) {\n                    spans += 0x8;\n                }\n                if (tz < tileZ + tileSizeZ - 1) {\n                    spans += 0x2;\n                }\n                for (let l = level; l >= 0; l--) {\n                    if (!this.levelTiles[l][tx][tz]) {\n                        this.levelTiles[l][tx][tz] = new _type_Tile__WEBPACK_IMPORTED_MODULE_2__[\"default\"](l, tx, tz);\n                    }\n                }\n                const tile = this.levelTiles[level][tx][tz];\n                if (tile) {\n                    tile.locs[tile.locCount] = loc;\n                    tile.locSpan[tile.locCount] = spans;\n                    tile.locSpans |= spans;\n                    tile.locCount++;\n                }\n            }\n        }\n        if (temporary) {\n            this.temporaryLocs[this.temporaryLocCount++] = loc;\n        }\n        return true;\n    };\n    removeLoc2 = (loc) => {\n        for (let tx = loc.minSceneTileX; tx <= loc.maxSceneTileX; tx++) {\n            for (let tz = loc.minSceneTileZ; tz <= loc.maxSceneTileZ; tz++) {\n                const tile = this.levelTiles[loc.level][tx][tz];\n                if (!tile) {\n                    continue;\n                }\n                for (let i = 0; i < tile.locCount; i++) {\n                    if (tile.locs[i] === loc) {\n                        tile.locCount--;\n                        for (let j = i; j < tile.locCount; j++) {\n                            tile.locs[j] = tile.locs[j + 1];\n                            tile.locSpan[j] = tile.locSpan[j + 1];\n                        }\n                        tile.locs[tile.locCount] = null;\n                        break;\n                    }\n                }\n                tile.locSpans = 0;\n                for (let i = 0; i < tile.locCount; i++) {\n                    tile.locSpans |= tile.locSpan[i];\n                }\n            }\n        }\n    };\n    updateActiveOccluders = () => {\n        const count = World3D.levelOccluderCount[World3D.topLevel];\n        const occluders = World3D.levelOccluders[World3D.topLevel];\n        World3D.activeOccluderCount = 0;\n        for (let i = 0; i < count; i++) {\n            const occluder = occluders[i];\n            if (!occluder) {\n                continue;\n            }\n            let deltaMaxY;\n            let deltaMinTileZ;\n            let deltaMaxTileZ;\n            let deltaMaxTileX;\n            if (occluder.type === 1) {\n                deltaMaxY = occluder.minTileX + 25 - World3D.eyeTileX;\n                if (deltaMaxY >= 0 && deltaMaxY <= 50) {\n                    deltaMinTileZ = occluder.minTileZ + 25 - World3D.eyeTileZ;\n                    if (deltaMinTileZ < 0) {\n                        deltaMinTileZ = 0;\n                    }\n                    deltaMaxTileZ = occluder.maxTileZ + 25 - World3D.eyeTileZ;\n                    if (deltaMaxTileZ > 50) {\n                        deltaMaxTileZ = 50;\n                    }\n                    let ok = false;\n                    while (deltaMinTileZ <= deltaMaxTileZ) {\n                        if (World3D.visibilityMap && World3D.visibilityMap[deltaMaxY][deltaMinTileZ++]) {\n                            ok = true;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        deltaMaxTileX = World3D.eyeX - occluder.minX;\n                        if (deltaMaxTileX > 32) {\n                            occluder.mode = 1;\n                        }\n                        else {\n                            if (deltaMaxTileX >= -32) {\n                                continue;\n                            }\n                            occluder.mode = 2;\n                            deltaMaxTileX = -deltaMaxTileX;\n                        }\n                        occluder.minDeltaZ = (((occluder.minZ - World3D.eyeZ) << 8) / deltaMaxTileX) | 0;\n                        occluder.maxDeltaZ = (((occluder.maxZ - World3D.eyeZ) << 8) / deltaMaxTileX) | 0;\n                        occluder.minDeltaY = (((occluder.minY - World3D.eyeY) << 8) / deltaMaxTileX) | 0;\n                        occluder.maxDeltaY = (((occluder.maxY - World3D.eyeY) << 8) / deltaMaxTileX) | 0;\n                        World3D.activeOccluders[World3D.activeOccluderCount++] = occluder;\n                    }\n                }\n            }\n            else if (occluder.type === 2) {\n                deltaMaxY = occluder.minTileZ + 25 - World3D.eyeTileZ;\n                if (deltaMaxY >= 0 && deltaMaxY <= 50) {\n                    deltaMinTileZ = occluder.minTileX + 25 - World3D.eyeTileX;\n                    if (deltaMinTileZ < 0) {\n                        deltaMinTileZ = 0;\n                    }\n                    deltaMaxTileZ = occluder.maxTileX + 25 - World3D.eyeTileX;\n                    if (deltaMaxTileZ > 50) {\n                        deltaMaxTileZ = 50;\n                    }\n                    let ok = false;\n                    while (deltaMinTileZ <= deltaMaxTileZ) {\n                        if (World3D.visibilityMap && World3D.visibilityMap[deltaMinTileZ++][deltaMaxY]) {\n                            ok = true;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        deltaMaxTileX = World3D.eyeZ - occluder.minZ;\n                        if (deltaMaxTileX > 32) {\n                            occluder.mode = 3;\n                        }\n                        else {\n                            if (deltaMaxTileX >= -32) {\n                                continue;\n                            }\n                            occluder.mode = 4;\n                            deltaMaxTileX = -deltaMaxTileX;\n                        }\n                        occluder.minDeltaX = (((occluder.minX - World3D.eyeX) << 8) / deltaMaxTileX) | 0;\n                        occluder.maxDeltaX = (((occluder.maxX - World3D.eyeX) << 8) / deltaMaxTileX) | 0;\n                        occluder.minDeltaY = (((occluder.minY - World3D.eyeY) << 8) / deltaMaxTileX) | 0;\n                        occluder.maxDeltaY = (((occluder.maxY - World3D.eyeY) << 8) / deltaMaxTileX) | 0;\n                        World3D.activeOccluders[World3D.activeOccluderCount++] = occluder;\n                    }\n                }\n            }\n            else if (occluder.type === 4) {\n                deltaMaxY = occluder.minY - World3D.eyeY;\n                if (deltaMaxY > 128) {\n                    deltaMinTileZ = occluder.minTileZ + 25 - World3D.eyeTileZ;\n                    if (deltaMinTileZ < 0) {\n                        deltaMinTileZ = 0;\n                    }\n                    deltaMaxTileZ = occluder.maxTileZ + 25 - World3D.eyeTileZ;\n                    if (deltaMaxTileZ > 50) {\n                        deltaMaxTileZ = 50;\n                    }\n                    if (deltaMinTileZ <= deltaMaxTileZ) {\n                        let deltaMinTileX = occluder.minTileX + 25 - World3D.eyeTileX;\n                        if (deltaMinTileX < 0) {\n                            deltaMinTileX = 0;\n                        }\n                        deltaMaxTileX = occluder.maxTileX + 25 - World3D.eyeTileX;\n                        if (deltaMaxTileX > 50) {\n                            deltaMaxTileX = 50;\n                        }\n                        let ok = false;\n                        find_visible_tile: for (let x = deltaMinTileX; x <= deltaMaxTileX; x++) {\n                            for (let z = deltaMinTileZ; z <= deltaMaxTileZ; z++) {\n                                if (World3D.visibilityMap && World3D.visibilityMap[x][z]) {\n                                    ok = true;\n                                    break find_visible_tile;\n                                }\n                            }\n                        }\n                        if (ok) {\n                            occluder.mode = 5;\n                            occluder.minDeltaX = (((occluder.minX - World3D.eyeX) << 8) / deltaMaxY) | 0;\n                            occluder.maxDeltaX = (((occluder.maxX - World3D.eyeX) << 8) / deltaMaxY) | 0;\n                            occluder.minDeltaZ = (((occluder.minZ - World3D.eyeZ) << 8) / deltaMaxY) | 0;\n                            occluder.maxDeltaZ = (((occluder.maxZ - World3D.eyeZ) << 8) / deltaMaxY) | 0;\n                            World3D.activeOccluders[World3D.activeOccluderCount++] = occluder;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    drawTile = (next, checkAdjacent, loopCycle) => {\n        World3D.drawTileQueue.addTail(next);\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let tile;\n            do {\n                tile = World3D.drawTileQueue.removeHead();\n                if (!tile) {\n                    return;\n                }\n            } while (!tile.update);\n            const tileX = tile.x;\n            const tileZ = tile.z;\n            const level = tile.level;\n            const occludeLevel = tile.occludeLevel;\n            const tiles = this.levelTiles[level];\n            if (tile.visible) {\n                if (checkAdjacent) {\n                    if (level > 0) {\n                        const above = this.levelTiles[level - 1][tileX][tileZ];\n                        if (above && above.update) {\n                            continue;\n                        }\n                    }\n                    if (tileX <= World3D.eyeTileX && tileX > World3D.minDrawTileX) {\n                        const adjacent = tiles[tileX - 1][tileZ];\n                        if (adjacent && adjacent.update && (adjacent.visible || (tile.locSpans & 0x1) === 0)) {\n                            continue;\n                        }\n                    }\n                    if (tileX >= World3D.eyeTileX && tileX < World3D.maxDrawTileX - 1) {\n                        const adjacent = tiles[tileX + 1][tileZ];\n                        if (adjacent && adjacent.update && (adjacent.visible || (tile.locSpans & 0x4) === 0)) {\n                            continue;\n                        }\n                    }\n                    if (tileZ <= World3D.eyeTileZ && tileZ > World3D.minDrawTileZ) {\n                        const adjacent = tiles[tileX][tileZ - 1];\n                        if (adjacent && adjacent.update && (adjacent.visible || (tile.locSpans & 0x8) === 0)) {\n                            continue;\n                        }\n                    }\n                    if (tileZ >= World3D.eyeTileZ && tileZ < World3D.maxDrawTileZ - 1) {\n                        const adjacent = tiles[tileX][tileZ + 1];\n                        if (adjacent && adjacent.update && (adjacent.visible || (tile.locSpans & 0x2) === 0)) {\n                            continue;\n                        }\n                    }\n                }\n                else {\n                    checkAdjacent = true;\n                }\n                tile.visible = false;\n                if (tile.bridge) {\n                    const bridge = tile.bridge;\n                    if (!bridge.underlay) {\n                        if (bridge.overlay && !this.tileVisible(0, tileX, tileZ)) {\n                            this.drawTileOverlay(tileX, tileZ, bridge.overlay, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw);\n                        }\n                    }\n                    else if (!this.tileVisible(0, tileX, tileZ)) {\n                        this.drawTileUnderlay(bridge.underlay, 0, tileX, tileZ, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw);\n                    }\n                    const wall = bridge.wall;\n                    if (wall) {\n                        wall.modelA?.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, wall.x - World3D.eyeX, wall.y - World3D.eyeY, wall.z - World3D.eyeZ, wall.bitset);\n                    }\n                    for (let i = 0; i < bridge.locCount; i++) {\n                        const loc = bridge.locs[i];\n                        if (loc) {\n                            let model = loc.model;\n                            if (!model) {\n                                model = loc.entity?.draw(loopCycle) ?? null;\n                            }\n                            model?.draw(loc.yaw, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, loc.x - World3D.eyeX, loc.y - World3D.eyeY, loc.z - World3D.eyeZ, loc.bitset);\n                        }\n                    }\n                }\n                let tileDrawn = false;\n                if (!tile.underlay) {\n                    if (tile.overlay && !this.tileVisible(occludeLevel, tileX, tileZ)) {\n                        tileDrawn = true;\n                        this.drawTileOverlay(tileX, tileZ, tile.overlay, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw);\n                    }\n                }\n                else if (!this.tileVisible(occludeLevel, tileX, tileZ)) {\n                    tileDrawn = true;\n                    this.drawTileUnderlay(tile.underlay, occludeLevel, tileX, tileZ, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw);\n                }\n                let direction = 0;\n                let frontWallTypes = 0;\n                const wall = tile.wall;\n                const decor = tile.wallDecoration;\n                if (wall || decor) {\n                    if (World3D.eyeTileX === tileX) {\n                        direction += 1;\n                    }\n                    else if (World3D.eyeTileX < tileX) {\n                        direction += 2;\n                    }\n                    if (World3D.eyeTileZ === tileZ) {\n                        direction += 3;\n                    }\n                    else if (World3D.eyeTileZ > tileZ) {\n                        direction += 6;\n                    }\n                    frontWallTypes = World3D.FRONT_WALL_TYPES[direction];\n                    tile.backWallTypes = World3D.BACK_WALL_TYPES[direction];\n                }\n                if (wall) {\n                    if ((wall.typeA & World3D.DIRECTION_ALLOW_WALL_CORNER_TYPE[direction]) === 0) {\n                        tile.checkLocSpans = 0;\n                    }\n                    else if (wall.typeA === 16) {\n                        tile.checkLocSpans = 3;\n                        tile.blockLocSpans = World3D.WALL_CORNER_TYPE_16_BLOCK_LOC_SPANS[direction];\n                        tile.inverseBlockLocSpans = 3 - tile.blockLocSpans;\n                    }\n                    else if (wall.typeA === 32) {\n                        tile.checkLocSpans = 6;\n                        tile.blockLocSpans = World3D.WALL_CORNER_TYPE_32_BLOCK_LOC_SPANS[direction];\n                        tile.inverseBlockLocSpans = 6 - tile.blockLocSpans;\n                    }\n                    else if (wall.typeA === 64) {\n                        tile.checkLocSpans = 12;\n                        tile.blockLocSpans = World3D.WALL_CORNER_TYPE_64_BLOCK_LOC_SPANS[direction];\n                        tile.inverseBlockLocSpans = 12 - tile.blockLocSpans;\n                    }\n                    else {\n                        tile.checkLocSpans = 9;\n                        tile.blockLocSpans = World3D.WALL_CORNER_TYPE_128_BLOCK_LOC_SPANS[direction];\n                        tile.inverseBlockLocSpans = 9 - tile.blockLocSpans;\n                    }\n                    if ((wall.typeA & frontWallTypes) !== 0 && !this.wallVisible(occludeLevel, tileX, tileZ, wall.typeA)) {\n                        wall.modelA?.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, wall.x - World3D.eyeX, wall.y - World3D.eyeY, wall.z - World3D.eyeZ, wall.bitset);\n                    }\n                    if ((wall.typeB & frontWallTypes) !== 0 && !this.wallVisible(occludeLevel, tileX, tileZ, wall.typeB)) {\n                        wall.modelB?.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, wall.x - World3D.eyeX, wall.y - World3D.eyeY, wall.z - World3D.eyeZ, wall.bitset);\n                    }\n                }\n                if (decor && !this.visible(occludeLevel, tileX, tileZ, decor.model.maxY)) {\n                    if ((decor.type & frontWallTypes) !== 0) {\n                        decor.model.draw(decor.angle, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, decor.x - World3D.eyeX, decor.y - World3D.eyeY, decor.z - World3D.eyeZ, decor.bitset);\n                    }\n                    else if ((decor.type & 0x300) !== 0) {\n                        const x = decor.x - World3D.eyeX;\n                        const y = decor.y - World3D.eyeY;\n                        const z = decor.z - World3D.eyeZ;\n                        const angle = decor.angle;\n                        let nearestX;\n                        if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].NORTH || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].EAST) {\n                            nearestX = -x;\n                        }\n                        else {\n                            nearestX = x;\n                        }\n                        let nearestZ;\n                        if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].EAST || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].SOUTH) {\n                            nearestZ = -z;\n                        }\n                        else {\n                            nearestZ = z;\n                        }\n                        if ((decor.type & 0x100) !== 0 && nearestZ < nearestX) {\n                            const drawX = x + World3D.WALL_DECORATION_INSET_X[angle];\n                            const drawZ = z + World3D.WALL_DECORATION_INSET_Z[angle];\n                            decor.model.draw(angle * 512 + 256, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, drawX, y, drawZ, decor.bitset);\n                        }\n                        if ((decor.type & 0x200) !== 0 && nearestZ > nearestX) {\n                            const drawX = x + World3D.WALL_DECORATION_OUTSET_X[angle];\n                            const drawZ = z + World3D.WALL_DECORATION_OUTSET_Z[angle];\n                            decor.model.draw((angle * 512 + 1280) & 0x7ff, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, drawX, y, drawZ, decor.bitset);\n                        }\n                    }\n                }\n                if (tileDrawn) {\n                    const groundDecor = tile.groundDecoration;\n                    if (groundDecor) {\n                        groundDecor.model?.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, groundDecor.x - World3D.eyeX, groundDecor.y - World3D.eyeY, groundDecor.z - World3D.eyeZ, groundDecor.bitset);\n                    }\n                    const objs = tile.objStack;\n                    if (objs && objs.offset === 0) {\n                        if (objs.bottomObj) {\n                            objs.bottomObj.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, objs.x - World3D.eyeX, objs.y - World3D.eyeY, objs.z - World3D.eyeZ, objs.bitset);\n                        }\n                        if (objs.middleObj) {\n                            objs.middleObj.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, objs.x - World3D.eyeX, objs.y - World3D.eyeY, objs.z - World3D.eyeZ, objs.bitset);\n                        }\n                        if (objs.topObj) {\n                            objs.topObj.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, objs.x - World3D.eyeX, objs.y - World3D.eyeY, objs.z - World3D.eyeZ, objs.bitset);\n                        }\n                    }\n                }\n                const spans = tile.locSpans;\n                if (spans !== 0) {\n                    if (tileX < World3D.eyeTileX && (spans & 0x4) !== 0) {\n                        const adjacent = tiles[tileX + 1][tileZ];\n                        if (adjacent && adjacent.update) {\n                            World3D.drawTileQueue.addTail(adjacent);\n                        }\n                    }\n                    if (tileZ < World3D.eyeTileZ && (spans & 0x2) !== 0) {\n                        const adjacent = tiles[tileX][tileZ + 1];\n                        if (adjacent && adjacent.update) {\n                            World3D.drawTileQueue.addTail(adjacent);\n                        }\n                    }\n                    if (tileX > World3D.eyeTileX && (spans & 0x1) !== 0) {\n                        const adjacent = tiles[tileX - 1][tileZ];\n                        if (adjacent && adjacent.update) {\n                            World3D.drawTileQueue.addTail(adjacent);\n                        }\n                    }\n                    if (tileZ > World3D.eyeTileZ && (spans & 0x8) !== 0) {\n                        const adjacent = tiles[tileX][tileZ - 1];\n                        if (adjacent && adjacent.update) {\n                            World3D.drawTileQueue.addTail(adjacent);\n                        }\n                    }\n                }\n            }\n            if (tile.checkLocSpans !== 0) {\n                let draw = true;\n                for (let i = 0; i < tile.locCount; i++) {\n                    const loc = tile.locs[i];\n                    if (!loc) {\n                        continue;\n                    }\n                    if (loc.cycle !== World3D.cycle && (tile.locSpan[i] & tile.checkLocSpans) === tile.blockLocSpans) {\n                        draw = false;\n                        break;\n                    }\n                }\n                if (draw) {\n                    const wall = tile.wall;\n                    if (wall && !this.wallVisible(occludeLevel, tileX, tileZ, wall.typeA)) {\n                        wall.modelA?.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, wall.x - World3D.eyeX, wall.y - World3D.eyeY, wall.z - World3D.eyeZ, wall.bitset);\n                    }\n                    tile.checkLocSpans = 0;\n                }\n            }\n            if (tile.containsLocs) {\n                const locCount = tile.locCount;\n                tile.containsLocs = false;\n                let locBufferSize = 0;\n                iterate_locs: for (let i = 0; i < locCount; i++) {\n                    const loc = tile.locs[i];\n                    if (!loc || loc.cycle === World3D.cycle) {\n                        continue;\n                    }\n                    for (let x = loc.minSceneTileX; x <= loc.maxSceneTileX; x++) {\n                        for (let z = loc.minSceneTileZ; z <= loc.maxSceneTileZ; z++) {\n                            const other = tiles[x][z];\n                            if (!other) {\n                                continue;\n                            }\n                            if (!other.visible) {\n                                if (other.checkLocSpans === 0) {\n                                    continue;\n                                }\n                                let spans = 0;\n                                if (x > loc.minSceneTileX) {\n                                    spans += 1;\n                                }\n                                if (x < loc.maxSceneTileX) {\n                                    spans += 4;\n                                }\n                                if (z > loc.minSceneTileZ) {\n                                    spans += 8;\n                                }\n                                if (z < loc.maxSceneTileZ) {\n                                    spans += 2;\n                                }\n                                if ((spans & other.checkLocSpans) !== tile.inverseBlockLocSpans) {\n                                    continue;\n                                }\n                            }\n                            tile.containsLocs = true;\n                            continue iterate_locs;\n                        }\n                    }\n                    World3D.locBuffer[locBufferSize++] = loc;\n                    let minTileDistanceX = World3D.eyeTileX - loc.minSceneTileX;\n                    const maxTileDistanceX = loc.maxSceneTileX - World3D.eyeTileX;\n                    if (maxTileDistanceX > minTileDistanceX) {\n                        minTileDistanceX = maxTileDistanceX;\n                    }\n                    const minTileDistanceZ = World3D.eyeTileZ - loc.minSceneTileZ;\n                    const maxTileDistanceZ = loc.maxSceneTileZ - World3D.eyeTileZ;\n                    if (maxTileDistanceZ > minTileDistanceZ) {\n                        loc.distance = minTileDistanceX + maxTileDistanceZ;\n                    }\n                    else {\n                        loc.distance = minTileDistanceX + minTileDistanceZ;\n                    }\n                }\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    let farthestDistance = -50;\n                    let farthestIndex = -1;\n                    for (let index = 0; index < locBufferSize; index++) {\n                        const loc = World3D.locBuffer[index];\n                        if (!loc) {\n                            continue;\n                        }\n                        if (loc.cycle !== World3D.cycle) {\n                            if (loc.distance > farthestDistance) {\n                                farthestDistance = loc.distance;\n                                farthestIndex = index;\n                            }\n                        }\n                    }\n                    if (farthestIndex === -1) {\n                        break;\n                    }\n                    const farthest = World3D.locBuffer[farthestIndex];\n                    if (farthest) {\n                        farthest.cycle = World3D.cycle;\n                        let model = farthest.model;\n                        if (!model) {\n                            model = farthest.entity?.draw(loopCycle) ?? null;\n                        }\n                        if (model && !this.locVisible(occludeLevel, farthest.minSceneTileX, farthest.maxSceneTileX, farthest.minSceneTileZ, farthest.maxSceneTileZ, model.maxY)) {\n                            model.draw(farthest.yaw, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, farthest.x - World3D.eyeX, farthest.y - World3D.eyeY, farthest.z - World3D.eyeZ, farthest.bitset);\n                        }\n                        for (let x = farthest.minSceneTileX; x <= farthest.maxSceneTileX; x++) {\n                            for (let z = farthest.minSceneTileZ; z <= farthest.maxSceneTileZ; z++) {\n                                const occupied = tiles[x][z];\n                                if (!occupied) {\n                                    continue;\n                                }\n                                if (occupied.checkLocSpans !== 0) {\n                                    World3D.drawTileQueue.addTail(occupied);\n                                }\n                                else if ((x !== tileX || z !== tileZ) && occupied.update) {\n                                    World3D.drawTileQueue.addTail(occupied);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (tile.containsLocs) {\n                    continue;\n                }\n            }\n            if (!tile.update || tile.checkLocSpans !== 0) {\n                continue;\n            }\n            if (tileX <= World3D.eyeTileX && tileX > World3D.minDrawTileX) {\n                const adjacent = tiles[tileX - 1][tileZ];\n                if (adjacent && adjacent.update) {\n                    continue;\n                }\n            }\n            if (tileX >= World3D.eyeTileX && tileX < World3D.maxDrawTileX - 1) {\n                const adjacent = tiles[tileX + 1][tileZ];\n                if (adjacent && adjacent.update) {\n                    continue;\n                }\n            }\n            if (tileZ <= World3D.eyeTileZ && tileZ > World3D.minDrawTileZ) {\n                const adjacent = tiles[tileX][tileZ - 1];\n                if (adjacent && adjacent.update) {\n                    continue;\n                }\n            }\n            if (tileZ >= World3D.eyeTileZ && tileZ < World3D.maxDrawTileZ - 1) {\n                const adjacent = tiles[tileX][tileZ + 1];\n                if (adjacent && adjacent.update) {\n                    continue;\n                }\n            }\n            tile.update = false;\n            World3D.tilesRemaining--;\n            const objs = tile.objStack;\n            if (objs && objs.offset !== 0) {\n                if (objs.bottomObj) {\n                    objs.bottomObj.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, objs.x - World3D.eyeX, objs.y - World3D.eyeY - objs.offset, objs.z - World3D.eyeZ, objs.bitset);\n                }\n                if (objs.middleObj) {\n                    objs.middleObj.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, objs.x - World3D.eyeX, objs.y - World3D.eyeY - objs.offset, objs.z - World3D.eyeZ, objs.bitset);\n                }\n                if (objs.topObj) {\n                    objs.topObj.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, objs.x - World3D.eyeX, objs.y - World3D.eyeY - objs.offset, objs.z - World3D.eyeZ, objs.bitset);\n                }\n            }\n            if (tile.backWallTypes !== 0) {\n                const decor = tile.wallDecoration;\n                if (decor && !this.visible(occludeLevel, tileX, tileZ, decor.model.maxY)) {\n                    if ((decor.type & tile.backWallTypes) !== 0) {\n                        decor.model.draw(decor.angle, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, decor.x - World3D.eyeX, decor.y - World3D.eyeY, decor.z - World3D.eyeZ, decor.bitset);\n                    }\n                    else if ((decor.type & 0x300) !== 0) {\n                        const x = decor.x - World3D.eyeX;\n                        const y = decor.y - World3D.eyeY;\n                        const z = decor.z - World3D.eyeZ;\n                        const angle = decor.angle;\n                        let nearestX;\n                        if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].NORTH || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].EAST) {\n                            nearestX = -x;\n                        }\n                        else {\n                            nearestX = x;\n                        }\n                        let nearestZ;\n                        if (angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].EAST || angle === _LocAngle__WEBPACK_IMPORTED_MODULE_14__[\"default\"].SOUTH) {\n                            nearestZ = -z;\n                        }\n                        else {\n                            nearestZ = z;\n                        }\n                        if ((decor.type & 0x100) !== 0 && nearestZ >= nearestX) {\n                            const drawX = x + World3D.WALL_DECORATION_INSET_X[angle];\n                            const drawZ = z + World3D.WALL_DECORATION_INSET_Z[angle];\n                            decor.model.draw(angle * 512 + 256, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, drawX, y, drawZ, decor.bitset);\n                        }\n                        if ((decor.type & 0x200) !== 0 && nearestZ <= nearestX) {\n                            const drawX = x + World3D.WALL_DECORATION_OUTSET_X[angle];\n                            const drawZ = z + World3D.WALL_DECORATION_OUTSET_Z[angle];\n                            decor.model.draw((angle * 512 + 1280) & 0x7ff, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, drawX, y, drawZ, decor.bitset);\n                        }\n                    }\n                }\n                const wall = tile.wall;\n                if (wall) {\n                    if ((wall.typeB & tile.backWallTypes) !== 0 && !this.wallVisible(occludeLevel, tileX, tileZ, wall.typeB)) {\n                        wall.modelB?.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, wall.x - World3D.eyeX, wall.y - World3D.eyeY, wall.z - World3D.eyeZ, wall.bitset);\n                    }\n                    if ((wall.typeA & tile.backWallTypes) !== 0 && !this.wallVisible(occludeLevel, tileX, tileZ, wall.typeA)) {\n                        wall.modelA?.draw(0, World3D.sinEyePitch, World3D.cosEyePitch, World3D.sinEyeYaw, World3D.cosEyeYaw, wall.x - World3D.eyeX, wall.y - World3D.eyeY, wall.z - World3D.eyeZ, wall.bitset);\n                    }\n                }\n            }\n            if (level < this.maxLevel - 1) {\n                const above = this.levelTiles[level + 1][tileX][tileZ];\n                if (above && above.update) {\n                    World3D.drawTileQueue.addTail(above);\n                }\n            }\n            if (tileX < World3D.eyeTileX) {\n                const adjacent = tiles[tileX + 1][tileZ];\n                if (adjacent && adjacent.update) {\n                    World3D.drawTileQueue.addTail(adjacent);\n                }\n            }\n            if (tileZ < World3D.eyeTileZ) {\n                const adjacent = tiles[tileX][tileZ + 1];\n                if (adjacent && adjacent.update) {\n                    World3D.drawTileQueue.addTail(adjacent);\n                }\n            }\n            if (tileX > World3D.eyeTileX) {\n                const adjacent = tiles[tileX - 1][tileZ];\n                if (adjacent && adjacent.update) {\n                    World3D.drawTileQueue.addTail(adjacent);\n                }\n            }\n            if (tileZ > World3D.eyeTileZ) {\n                const adjacent = tiles[tileX][tileZ - 1];\n                if (adjacent && adjacent.update) {\n                    World3D.drawTileQueue.addTail(adjacent);\n                }\n            }\n        }\n    };\n    drawTileUnderlay = (underlay, level, tileX, tileZ, sinEyePitch, cosEyePitch, sinEyeYaw, cosEyeYaw) => {\n        let x3;\n        let x0 = (x3 = (tileX << 7) - World3D.eyeX);\n        let z1;\n        let z0 = (z1 = (tileZ << 7) - World3D.eyeZ);\n        let x2;\n        let x1 = (x2 = x0 + 128);\n        let z3;\n        let z2 = (z3 = z0 + 128);\n        let y0 = this.levelHeightmaps[level][tileX][tileZ] - World3D.eyeY;\n        let y1 = this.levelHeightmaps[level][tileX + 1][tileZ] - World3D.eyeY;\n        let y2 = this.levelHeightmaps[level][tileX + 1][tileZ + 1] - World3D.eyeY;\n        let y3 = this.levelHeightmaps[level][tileX][tileZ + 1] - World3D.eyeY;\n        let tmp = (z0 * sinEyeYaw + x0 * cosEyeYaw) >> 16;\n        z0 = (z0 * cosEyeYaw - x0 * sinEyeYaw) >> 16;\n        x0 = tmp;\n        tmp = (y0 * cosEyePitch - z0 * sinEyePitch) >> 16;\n        z0 = (y0 * sinEyePitch + z0 * cosEyePitch) >> 16;\n        y0 = tmp;\n        if (z0 < 50) {\n            return;\n        }\n        tmp = (z1 * sinEyeYaw + x1 * cosEyeYaw) >> 16;\n        z1 = (z1 * cosEyeYaw - x1 * sinEyeYaw) >> 16;\n        x1 = tmp;\n        tmp = (y1 * cosEyePitch - z1 * sinEyePitch) >> 16;\n        z1 = (y1 * sinEyePitch + z1 * cosEyePitch) >> 16;\n        y1 = tmp;\n        if (z1 < 50) {\n            return;\n        }\n        tmp = (z2 * sinEyeYaw + x2 * cosEyeYaw) >> 16;\n        z2 = (z2 * cosEyeYaw - x2 * sinEyeYaw) >> 16;\n        x2 = tmp;\n        tmp = (y2 * cosEyePitch - z2 * sinEyePitch) >> 16;\n        z2 = (y2 * sinEyePitch + z2 * cosEyePitch) >> 16;\n        y2 = tmp;\n        if (z2 < 50) {\n            return;\n        }\n        tmp = (z3 * sinEyeYaw + x3 * cosEyeYaw) >> 16;\n        z3 = (z3 * cosEyeYaw - x3 * sinEyeYaw) >> 16;\n        x3 = tmp;\n        tmp = (y3 * cosEyePitch - z3 * sinEyePitch) >> 16;\n        z3 = (y3 * sinEyePitch + z3 * cosEyePitch) >> 16;\n        y3 = tmp;\n        if (z3 < 50) {\n            return;\n        }\n        const px0 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerX + (((x0 << 9) / z0) | 0);\n        const py0 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerY + (((y0 << 9) / z0) | 0);\n        const pz0 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerX + (((x1 << 9) / z1) | 0);\n        const px1 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerY + (((y1 << 9) / z1) | 0);\n        const py1 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerX + (((x2 << 9) / z2) | 0);\n        const pz1 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerY + (((y2 << 9) / z2) | 0);\n        const px3 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerX + (((x3 << 9) / z3) | 0);\n        const py3 = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerY + (((y3 << 9) / z3) | 0);\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].alpha = 0;\n        if ((py1 - px3) * (px1 - py3) - (pz1 - py3) * (pz0 - px3) > 0) {\n            _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clipX = py1 < 0 || px3 < 0 || pz0 < 0 || py1 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX || px3 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX || pz0 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX;\n            if (World3D.takingInput && this.pointInsideTriangle(World3D.mouseX, World3D.mouseY, pz1, py3, px1, py1, px3, pz0)) {\n                World3D.clickTileX = tileX;\n                World3D.clickTileZ = tileZ;\n            }\n            if (underlay.textureId === -1) {\n                if (underlay.northeastColor !== 12345678) {\n                    _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillGouraudTriangle(py1, px3, pz0, pz1, py3, px1, underlay.northeastColor, underlay.northwestColor, underlay.southeastColor);\n                }\n            }\n            else if (World3D.lowMemory) {\n                const averageColor = World3D.TEXTURE_HSL[underlay.textureId];\n                _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillGouraudTriangle(py1, px3, pz0, pz1, py3, px1, this.mulLightness(averageColor, underlay.northeastColor), this.mulLightness(averageColor, underlay.northwestColor), this.mulLightness(averageColor, underlay.southeastColor));\n            }\n            else if (underlay.flat) {\n                _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillTexturedTriangle(py1, px3, pz0, pz1, py3, px1, underlay.northeastColor, underlay.northwestColor, underlay.southeastColor, x0, y0, z0, x1, x3, y1, y3, z1, z3, underlay.textureId);\n            }\n            else {\n                _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillTexturedTriangle(py1, px3, pz0, pz1, py3, px1, underlay.northeastColor, underlay.northwestColor, underlay.southeastColor, x2, y2, z2, x3, x1, y3, y1, z3, z1, underlay.textureId);\n            }\n        }\n        if ((px0 - pz0) * (py3 - px1) - (py0 - px1) * (px3 - pz0) <= 0) {\n            return;\n        }\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clipX = px0 < 0 || pz0 < 0 || px3 < 0 || px0 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX || pz0 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX || px3 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX;\n        if (World3D.takingInput && this.pointInsideTriangle(World3D.mouseX, World3D.mouseY, py0, px1, py3, px0, pz0, px3)) {\n            World3D.clickTileX = tileX;\n            World3D.clickTileZ = tileZ;\n        }\n        if (underlay.textureId !== -1) {\n            if (!World3D.lowMemory) {\n                _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillTexturedTriangle(px0, pz0, px3, py0, px1, py3, underlay.southwestColor, underlay.southeastColor, underlay.northwestColor, x0, y0, z0, x1, x3, y1, y3, z1, z3, underlay.textureId);\n                return;\n            }\n            const averageColor = World3D.TEXTURE_HSL[underlay.textureId];\n            _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillGouraudTriangle(px0, pz0, px3, py0, px1, py3, this.mulLightness(averageColor, underlay.southwestColor), this.mulLightness(averageColor, underlay.southeastColor), this.mulLightness(averageColor, underlay.northwestColor));\n        }\n        else if (underlay.southwestColor !== 12345678) {\n            _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillGouraudTriangle(px0, pz0, px3, py0, px1, py3, underlay.southwestColor, underlay.southeastColor, underlay.northwestColor);\n        }\n    };\n    drawTileOverlay = (tileX, tileZ, overlay, sinEyePitch, cosEyePitch, sinEyeYaw, cosEyeYaw) => {\n        let vertexCount = overlay.vertexX.length;\n        for (let i = 0; i < vertexCount; i++) {\n            let x = overlay.vertexX[i] - World3D.eyeX;\n            let y = overlay.vertexY[i] - World3D.eyeY;\n            let z = overlay.vertexZ[i] - World3D.eyeZ;\n            let tmp = (z * sinEyeYaw + x * cosEyeYaw) >> 16;\n            z = (z * cosEyeYaw - x * sinEyeYaw) >> 16;\n            x = tmp;\n            tmp = (y * cosEyePitch - z * sinEyePitch) >> 16;\n            z = (y * sinEyePitch + z * cosEyePitch) >> 16;\n            y = tmp;\n            if (z < 50) {\n                return;\n            }\n            if (overlay.triangleTextureIds) {\n                _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceX[i] = x;\n                _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceY[i] = y;\n                _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceZ[i] = z;\n            }\n            _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenX[i] = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerX + (((x << 9) / z) | 0);\n            _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenY[i] = _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].centerY + (((y << 9) / z) | 0);\n        }\n        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].alpha = 0;\n        vertexCount = overlay.triangleVertexA.length;\n        for (let v = 0; v < vertexCount; v++) {\n            const a = overlay.triangleVertexA[v];\n            const b = overlay.triangleVertexB[v];\n            const c = overlay.triangleVertexC[v];\n            const x0 = _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenX[a];\n            const x1 = _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenX[b];\n            const x2 = _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenX[c];\n            const y0 = _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenY[a];\n            const y1 = _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenY[b];\n            const y2 = _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpScreenY[c];\n            if ((x0 - x1) * (y2 - y1) - (y0 - y1) * (x2 - x1) > 0) {\n                _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].clipX = x0 < 0 || x1 < 0 || x2 < 0 || x0 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX || x1 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX || x2 > _graphics_Draw2D__WEBPACK_IMPORTED_MODULE_11__[\"default\"].boundX;\n                if (World3D.takingInput && this.pointInsideTriangle(World3D.mouseX, World3D.mouseY, y0, y1, y2, x0, x1, x2)) {\n                    World3D.clickTileX = tileX;\n                    World3D.clickTileZ = tileZ;\n                }\n                if (!overlay.triangleTextureIds || overlay.triangleTextureIds[v] === -1) {\n                    if (overlay.triangleColorA[v] !== 12345678) {\n                        _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillGouraudTriangle(x0, x1, x2, y0, y1, y2, overlay.triangleColorA[v], overlay.triangleColorB[v], overlay.triangleColorC[v]);\n                    }\n                }\n                else if (World3D.lowMemory) {\n                    const textureColor = World3D.TEXTURE_HSL[overlay.triangleTextureIds[v]];\n                    _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillGouraudTriangle(x0, x1, x2, y0, y1, y2, this.mulLightness(textureColor, overlay.triangleColorA[v]), this.mulLightness(textureColor, overlay.triangleColorB[v]), this.mulLightness(textureColor, overlay.triangleColorC[v]));\n                }\n                else if (overlay.flat) {\n                    _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillTexturedTriangle(x0, x1, x2, y0, y1, y2, overlay.triangleColorA[v], overlay.triangleColorB[v], overlay.triangleColorC[v], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceX[0], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceY[0], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceZ[0], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceX[1], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceX[3], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceY[1], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceY[3], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceZ[1], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceZ[3], overlay.triangleTextureIds[v]);\n                }\n                else {\n                    _graphics_Draw3D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fillTexturedTriangle(x0, x1, x2, y0, y1, y2, overlay.triangleColorA[v], overlay.triangleColorB[v], overlay.triangleColorC[v], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceX[a], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceY[a], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceZ[a], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceX[b], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceX[c], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceY[b], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceY[c], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceZ[b], _type_TileOverlay__WEBPACK_IMPORTED_MODULE_12__[\"default\"].tmpViewspaceZ[c], overlay.triangleTextureIds[v]);\n                }\n            }\n        }\n    };\n    tileVisible = (level, x, z) => {\n        const cycle = this.levelTileOcclusionCycles[level][x][z];\n        if (cycle === -World3D.cycle) {\n            return false;\n        }\n        else if (cycle === World3D.cycle) {\n            return true;\n        }\n        else {\n            const sx = x << 7;\n            const sz = z << 7;\n            if (this.occluded(sx + 1, this.levelHeightmaps[level][x][z], sz + 1) &&\n                this.occluded(sx + 128 - 1, this.levelHeightmaps[level][x + 1][z], sz + 1) &&\n                this.occluded(sx + 128 - 1, this.levelHeightmaps[level][x + 1][z + 1], sz + 128 - 1) &&\n                this.occluded(sx + 1, this.levelHeightmaps[level][x][z + 1], sz + 128 - 1)) {\n                this.levelTileOcclusionCycles[level][x][z] = World3D.cycle;\n                return true;\n            }\n            else {\n                this.levelTileOcclusionCycles[level][x][z] = -World3D.cycle;\n                return false;\n            }\n        }\n    };\n    wallVisible = (level, x, z, type) => {\n        if (!this.tileVisible(level, x, z)) {\n            return false;\n        }\n        const sceneX = x << 7;\n        const sceneZ = z << 7;\n        const sceneY = this.levelHeightmaps[level][x][z] - 1;\n        const y0 = sceneY - 120;\n        const y1 = sceneY - 230;\n        const y2 = sceneY - 238;\n        if (type < 16) {\n            if (type === 1) {\n                if (sceneX > World3D.eyeX) {\n                    if (!this.occluded(sceneX, sceneY, sceneZ)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX, sceneY, sceneZ + 128)) {\n                        return false;\n                    }\n                }\n                if (level > 0) {\n                    if (!this.occluded(sceneX, y0, sceneZ)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX, y0, sceneZ + 128)) {\n                        return false;\n                    }\n                }\n                if (!this.occluded(sceneX, y1, sceneZ)) {\n                    return false;\n                }\n                return this.occluded(sceneX, y1, sceneZ + 128);\n            }\n            if (type === 2) {\n                if (sceneZ < World3D.eyeZ) {\n                    if (!this.occluded(sceneX, sceneY, sceneZ + 128)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX + 128, sceneY, sceneZ + 128)) {\n                        return false;\n                    }\n                }\n                if (level > 0) {\n                    if (!this.occluded(sceneX, y0, sceneZ + 128)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX + 128, y0, sceneZ + 128)) {\n                        return false;\n                    }\n                }\n                if (!this.occluded(sceneX, y1, sceneZ + 128)) {\n                    return false;\n                }\n                return this.occluded(sceneX + 128, y1, sceneZ + 128);\n            }\n            if (type === 4) {\n                if (sceneX < World3D.eyeX) {\n                    if (!this.occluded(sceneX + 128, sceneY, sceneZ)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX + 128, sceneY, sceneZ + 128)) {\n                        return false;\n                    }\n                }\n                if (level > 0) {\n                    if (!this.occluded(sceneX + 128, y0, sceneZ)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX + 128, y0, sceneZ + 128)) {\n                        return false;\n                    }\n                }\n                if (!this.occluded(sceneX + 128, y1, sceneZ)) {\n                    return false;\n                }\n                return this.occluded(sceneX + 128, y1, sceneZ + 128);\n            }\n            if (type === 8) {\n                if (sceneZ > World3D.eyeZ) {\n                    if (!this.occluded(sceneX, sceneY, sceneZ)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX + 128, sceneY, sceneZ)) {\n                        return false;\n                    }\n                }\n                if (level > 0) {\n                    if (!this.occluded(sceneX, y0, sceneZ)) {\n                        return false;\n                    }\n                    if (!this.occluded(sceneX + 128, y0, sceneZ)) {\n                        return false;\n                    }\n                }\n                if (!this.occluded(sceneX, y1, sceneZ)) {\n                    return false;\n                }\n                return this.occluded(sceneX + 128, y1, sceneZ);\n            }\n        }\n        if (!this.occluded(sceneX + 64, y2, sceneZ + 64)) {\n            return false;\n        }\n        else if (type === 16) {\n            return this.occluded(sceneX, y1, sceneZ + 128);\n        }\n        else if (type === 32) {\n            return this.occluded(sceneX + 128, y1, sceneZ + 128);\n        }\n        else if (type === 64) {\n            return this.occluded(sceneX + 128, y1, sceneZ);\n        }\n        else if (type === 128) {\n            return this.occluded(sceneX, y1, sceneZ);\n        }\n        console.warn('Warning unsupported wall type!');\n        return true;\n    };\n    visible = (level, tileX, tileZ, y) => {\n        if (this.tileVisible(level, tileX, tileZ)) {\n            const x = tileX << 7;\n            const z = tileZ << 7;\n            return (this.occluded(x + 1, this.levelHeightmaps[level][tileX][tileZ] - y, z + 1) &&\n                this.occluded(x + 128 - 1, this.levelHeightmaps[level][tileX + 1][tileZ] - y, z + 1) &&\n                this.occluded(x + 128 - 1, this.levelHeightmaps[level][tileX + 1][tileZ + 1] - y, z + 128 - 1) &&\n                this.occluded(x + 1, this.levelHeightmaps[level][tileX][tileZ + 1] - y, z + 128 - 1));\n        }\n        return false;\n    };\n    locVisible = (level, minX, maxX, minZ, maxZ, y) => {\n        let x;\n        let z;\n        if (minX !== maxX || minZ !== maxZ) {\n            for (x = minX; x <= maxX; x++) {\n                for (z = minZ; z <= maxZ; z++) {\n                    if (this.levelTileOcclusionCycles[level][x][z] === -World3D.cycle) {\n                        return false;\n                    }\n                }\n            }\n            z = (minX << 7) + 1;\n            const z0 = (minZ << 7) + 2;\n            const y0 = this.levelHeightmaps[level][minX][minZ] - y;\n            if (!this.occluded(z, y0, z0)) {\n                return false;\n            }\n            const x1 = (maxX << 7) - 1;\n            if (!this.occluded(x1, y0, z0)) {\n                return false;\n            }\n            const z1 = (maxZ << 7) - 1;\n            if (!this.occluded(z, y0, z1)) {\n                return false;\n            }\n            else\n                return this.occluded(x1, y0, z1);\n        }\n        else if (this.tileVisible(level, minX, minZ)) {\n            x = minX << 7;\n            z = minZ << 7;\n            return (this.occluded(x + 1, this.levelHeightmaps[level][minX][minZ] - y, z + 1) &&\n                this.occluded(x + 128 - 1, this.levelHeightmaps[level][minX + 1][minZ] - y, z + 1) &&\n                this.occluded(x + 128 - 1, this.levelHeightmaps[level][minX + 1][minZ + 1] - y, z + 128 - 1) &&\n                this.occluded(x + 1, this.levelHeightmaps[level][minX][minZ + 1] - y, z + 128 - 1));\n        }\n        return false;\n    };\n    occluded = (x, y, z) => {\n        for (let i = 0; i < World3D.activeOccluderCount; i++) {\n            const occluder = World3D.activeOccluders[i];\n            if (!occluder) {\n                continue;\n            }\n            if (occluder.mode === 1) {\n                const dx = occluder.minX - x;\n                if (dx > 0) {\n                    const minZ = occluder.minZ + ((occluder.minDeltaZ * dx) >> 8);\n                    const maxZ = occluder.maxZ + ((occluder.maxDeltaZ * dx) >> 8);\n                    const minY = occluder.minY + ((occluder.minDeltaY * dx) >> 8);\n                    const maxY = occluder.maxY + ((occluder.maxDeltaY * dx) >> 8);\n                    if (z >= minZ && z <= maxZ && y >= minY && y <= maxY) {\n                        return true;\n                    }\n                }\n            }\n            else if (occluder.mode === 2) {\n                const dx = x - occluder.minX;\n                if (dx > 0) {\n                    const minZ = occluder.minZ + ((occluder.minDeltaZ * dx) >> 8);\n                    const maxZ = occluder.maxZ + ((occluder.maxDeltaZ * dx) >> 8);\n                    const minY = occluder.minY + ((occluder.minDeltaY * dx) >> 8);\n                    const maxY = occluder.maxY + ((occluder.maxDeltaY * dx) >> 8);\n                    if (z >= minZ && z <= maxZ && y >= minY && y <= maxY) {\n                        return true;\n                    }\n                }\n            }\n            else if (occluder.mode === 3) {\n                const dz = occluder.minZ - z;\n                if (dz > 0) {\n                    const minX = occluder.minX + ((occluder.minDeltaX * dz) >> 8);\n                    const maxX = occluder.maxX + ((occluder.maxDeltaX * dz) >> 8);\n                    const minY = occluder.minY + ((occluder.minDeltaY * dz) >> 8);\n                    const maxY = occluder.maxY + ((occluder.maxDeltaY * dz) >> 8);\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n                        return true;\n                    }\n                }\n            }\n            else if (occluder.mode === 4) {\n                const dz = z - occluder.minZ;\n                if (dz > 0) {\n                    const minX = occluder.minX + ((occluder.minDeltaX * dz) >> 8);\n                    const maxX = occluder.maxX + ((occluder.maxDeltaX * dz) >> 8);\n                    const minY = occluder.minY + ((occluder.minDeltaY * dz) >> 8);\n                    const maxY = occluder.maxY + ((occluder.maxDeltaY * dz) >> 8);\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n                        return true;\n                    }\n                }\n            }\n            else if (occluder.mode === 5) {\n                const dy = y - occluder.minY;\n                if (dy > 0) {\n                    const minX = occluder.minX + ((occluder.minDeltaX * dy) >> 8);\n                    const maxX = occluder.maxX + ((occluder.maxDeltaX * dy) >> 8);\n                    const minZ = occluder.minZ + ((occluder.minDeltaZ * dy) >> 8);\n                    const maxZ = occluder.maxZ + ((occluder.maxDeltaZ * dy) >> 8);\n                    if (x >= minX && x <= maxX && z >= minZ && z <= maxZ) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    pointInsideTriangle = (x, y, y0, y1, y2, x0, x1, x2) => {\n        if (y < y0 && y < y1 && y < y2) {\n            return false;\n        }\n        else if (y > y0 && y > y1 && y > y2) {\n            return false;\n        }\n        else if (x < x0 && x < x1 && x < x2) {\n            return false;\n        }\n        else if (x > x0 && x > x1 && x > x2) {\n            return false;\n        }\n        const crossProduct_01 = (y - y0) * (x1 - x0) - (x - x0) * (y1 - y0);\n        const crossProduct_20 = (y - y2) * (x0 - x2) - (x - x2) * (y0 - y2);\n        const crossProduct_12 = (y - y1) * (x2 - x1) - (x - x1) * (y2 - y1);\n        return crossProduct_01 * crossProduct_12 > 0 && crossProduct_12 * crossProduct_20 > 0;\n    };\n    mulLightness = (hsl, lightness) => {\n        const invLightness = 127 - lightness;\n        lightness = ((invLightness * (hsl & 0x7f)) / 160) | 0;\n        if (lightness < 2) {\n            lightness = 2;\n        }\n        else if (lightness > 126) {\n            lightness = 126;\n        }\n        return (hsl & 0xff80) + lightness;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/World3D.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/Entity.ts":
/*!***********************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/Entity.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass Entity extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/Entity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/LocEntity.ts":
/*!**************************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/LocEntity.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocEntity)\n/* harmony export */ });\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass LocEntity extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // constructor\n    heightmapSW;\n    heightmapSE;\n    heightmapNE;\n    heightmapNW;\n    index;\n    seq;\n    seqFrame;\n    seqCycle;\n    constructor(index, heightmapSW, heightmapSE, heightmapNE, heightmapNW, seq, randomFrame) {\n        super();\n        this.heightmapSW = heightmapSW;\n        this.heightmapSE = heightmapSE;\n        this.heightmapNE = heightmapNE;\n        this.heightmapNW = heightmapNW;\n        this.index = index;\n        this.seq = seq;\n        if (randomFrame && seq.replayoff !== -1 && this.seq.delay) {\n            this.seqFrame = (Math.random() * this.seq.frameCount) | 0;\n            this.seqCycle = (Math.random() * this.seq.delay[this.seqFrame]) | 0;\n        }\n        else {\n            this.seqFrame = -1;\n            this.seqCycle = 0;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/LocEntity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/NpcEntity.ts":
/*!**************************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/NpcEntity.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NpcEntity)\n/* harmony export */ });\n/* harmony import */ var _PathingEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PathingEntity */ \"./src/js/jagex2/dash3d/entity/PathingEntity.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config/SpotAnimType */ \"./src/js/jagex2/config/SpotAnimType.ts\");\n/* harmony import */ var _config_SeqType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config/SeqType */ \"./src/js/jagex2/config/SeqType.ts\");\n\n\n\n\nclass NpcEntity extends _PathingEntity__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static ANIM = 0x2;\n    static FACE_ENTITY = 0x4;\n    static SAY = 0x8;\n    static DAMAGE = 0x10;\n    static CHANGE_TYPE = 0x20;\n    static SPOTANIM = 0x40;\n    static FACE_COORD = 0x80;\n    type = null;\n    draw(_loopCycle) {\n        if (!this.type) {\n            return null;\n        }\n        if (this.spotanimId === -1 || this.spotanimFrame === -1) {\n            return this.getSequencedModel();\n        }\n        const model = this.getSequencedModel();\n        if (!model) {\n            return null;\n        }\n        const spotanim = _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_2__[\"default\"].instances[this.spotanimId];\n        const model1 = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelShareColored(spotanim.getModel(), true, !spotanim.disposeAlpha, false);\n        model1.translate(-this.spotanimOffset, 0, 0);\n        model1.createLabelReferences();\n        if (spotanim.seq && spotanim.seq.frames) {\n            model1.applyTransform(spotanim.seq.frames[this.spotanimFrame]);\n        }\n        model1.labelFaces = null;\n        model1.labelVertices = null;\n        if (spotanim.resizeh !== 128 || spotanim.resizev !== 128) {\n            model1.scale(spotanim.resizeh, spotanim.resizev, spotanim.resizeh);\n        }\n        model1.calculateNormals(64 + spotanim.ambient, 850 + spotanim.contrast, -30, -50, -30, true);\n        const models = [model, model1];\n        const tmp = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelFromModelsBounds(models, 2);\n        if (this.type.size === 1) {\n            tmp.pickable = true;\n        }\n        return tmp;\n    }\n    isVisible() {\n        return this.type !== null;\n    }\n    getSequencedModel() {\n        if (!this.type) {\n            return null;\n        }\n        if (this.primarySeqId >= 0 && this.primarySeqDelay === 0) {\n            const frames = _config_SeqType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[this.primarySeqId].frames;\n            if (frames) {\n                const primaryTransformId = frames[this.primarySeqFrame];\n                let secondaryTransformId = -1;\n                if (this.secondarySeqId >= 0 && this.secondarySeqId !== this.seqStandId) {\n                    const secondFrames = _config_SeqType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[this.secondarySeqId].frames;\n                    if (secondFrames) {\n                        secondaryTransformId = secondFrames[this.secondarySeqFrame];\n                    }\n                }\n                return this.type.getSequencedModel(primaryTransformId, secondaryTransformId, _config_SeqType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[this.primarySeqId].walkmerge);\n            }\n        }\n        let transformId = -1;\n        if (this.secondarySeqId >= 0) {\n            const secondFrames = _config_SeqType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[this.secondarySeqId].frames;\n            if (secondFrames) {\n                transformId = secondFrames[this.secondarySeqFrame];\n            }\n        }\n        const model = this.type.getSequencedModel(transformId, -1, null);\n        if (!model) {\n            return null;\n        }\n        this.height = model.maxY;\n        return model;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/NpcEntity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/ObjStackEntity.ts":
/*!*******************************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/ObjStackEntity.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ObjStackEntity)\n/* harmony export */ });\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass ObjStackEntity extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // constructor\n    index;\n    count;\n    constructor(index, count) {\n        super();\n        this.index = index;\n        this.count = count;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/ObjStackEntity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/PathingEntity.ts":
/*!******************************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/PathingEntity.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PathingEntity)\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"./src/js/jagex2/dash3d/entity/Entity.ts\");\n/* harmony import */ var _config_SeqType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config/SeqType */ \"./src/js/jagex2/config/SeqType.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\nclass PathingEntity extends _Entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    x = 0;\n    z = 0;\n    yaw = 0;\n    seqStretches = false;\n    size = 1;\n    seqStandId = -1;\n    seqTurnId = -1;\n    seqWalkId = -1;\n    seqTurnAroundId = -1;\n    seqTurnLeftId = -1;\n    seqTurnRightId = -1;\n    seqRunId = -1;\n    chat = null;\n    chatTimer = 100;\n    chatColor = 0;\n    chatStyle = 0;\n    damage = 0;\n    damageType = 0;\n    combatCycle = -1000;\n    health = 0;\n    totalHealth = 0;\n    targetId = -1;\n    targetTileX = 0;\n    targetTileZ = 0;\n    secondarySeqId = -1;\n    secondarySeqFrame = 0;\n    secondarySeqCycle = 0;\n    primarySeqId = -1;\n    primarySeqFrame = 0;\n    primarySeqCycle = 0;\n    primarySeqDelay = 0;\n    primarySeqLoop = 0;\n    spotanimId = -1;\n    spotanimFrame = 0;\n    spotanimCycle = 0;\n    spotanimLastCycle = 0;\n    spotanimOffset = 0;\n    forceMoveStartSceneTileX = 0;\n    forceMoveEndSceneTileX = 0;\n    forceMoveStartSceneTileZ = 0;\n    forceMoveEndSceneTileZ = 0;\n    forceMoveEndCycle = 0;\n    forceMoveStartCycle = 0;\n    forceMoveFaceDirection = 0;\n    cycle = 0;\n    height = 0;\n    dstYaw = 0;\n    pathLength = 0;\n    pathTileX = new Int32Array(10);\n    pathTileZ = new Int32Array(10);\n    pathRunning = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.TypedArray1d(10, false);\n    seqTrigger = 0;\n    lastMask = -1;\n    lastMaskCycle = -1;\n    lastFaceX = -1;\n    lastFaceZ = -1;\n    move(teleport, x, z) {\n        if (this.primarySeqId !== -1 && _config_SeqType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[this.primarySeqId].priority <= 1) {\n            this.primarySeqId = -1;\n        }\n        if (!teleport) {\n            const dx = x - this.pathTileX[0];\n            const dz = z - this.pathTileZ[0];\n            if (dx >= -8 && dx <= 8 && dz >= -8 && dz <= 8) {\n                if (this.pathLength < 9) {\n                    this.pathLength++;\n                }\n                for (let i = this.pathLength; i > 0; i--) {\n                    this.pathTileX[i] = this.pathTileX[i - 1];\n                    this.pathTileZ[i] = this.pathTileZ[i - 1];\n                    this.pathRunning[i] = this.pathRunning[i - 1];\n                }\n                this.pathTileX[0] = x;\n                this.pathTileZ[0] = z;\n                this.pathRunning[0] = false;\n                return;\n            }\n        }\n        this.pathLength = 0;\n        this.seqTrigger = 0;\n        this.pathTileX[0] = x;\n        this.pathTileZ[0] = z;\n        this.x = this.pathTileX[0] * 128 + this.size * 64;\n        this.z = this.pathTileZ[0] * 128 + this.size * 64;\n    }\n    step(running, direction) {\n        let nextX = this.pathTileX[0];\n        let nextZ = this.pathTileZ[0];\n        if (direction === 0) {\n            nextX--;\n            nextZ++;\n        }\n        else if (direction === 1) {\n            nextZ++;\n        }\n        else if (direction === 2) {\n            nextX++;\n            nextZ++;\n        }\n        else if (direction === 3) {\n            nextX--;\n        }\n        else if (direction === 4) {\n            nextX++;\n        }\n        else if (direction === 5) {\n            nextX--;\n            nextZ--;\n        }\n        else if (direction === 6) {\n            nextZ--;\n        }\n        else if (direction === 7) {\n            nextX++;\n            nextZ--;\n        }\n        if (this.primarySeqId !== -1 && _config_SeqType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[this.primarySeqId].priority <= 1) {\n            this.primarySeqId = -1;\n        }\n        if (this.pathLength < 9) {\n            this.pathLength++;\n        }\n        for (let i = this.pathLength; i > 0; i--) {\n            this.pathTileX[i] = this.pathTileX[i - 1];\n            this.pathTileZ[i] = this.pathTileZ[i - 1];\n            this.pathRunning[i] = this.pathRunning[i - 1];\n        }\n        this.pathTileX[0] = nextX;\n        this.pathTileZ[0] = nextZ;\n        this.pathRunning[0] = running;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/PathingEntity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/PlayerEntity.ts":
/*!*****************************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/PlayerEntity.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PlayerEntity)\n/* harmony export */ });\n/* harmony import */ var _PathingEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PathingEntity */ \"./src/js/jagex2/dash3d/entity/PathingEntity.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n/* harmony import */ var _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../datastruct/LruCache */ \"./src/js/jagex2/datastruct/LruCache.ts\");\n/* harmony import */ var _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config/SpotAnimType */ \"./src/js/jagex2/config/SpotAnimType.ts\");\n/* harmony import */ var _config_SeqType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config/SeqType */ \"./src/js/jagex2/config/SeqType.ts\");\n/* harmony import */ var _config_IdkType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../config/IdkType */ \"./src/js/jagex2/config/IdkType.ts\");\n/* harmony import */ var _config_ObjType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../config/ObjType */ \"./src/js/jagex2/config/ObjType.ts\");\n/* harmony import */ var _datastruct_JString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../datastruct/JString */ \"./src/js/jagex2/datastruct/JString.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n/* harmony import */ var _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../graphics/Colors */ \"./src/js/jagex2/graphics/Colors.ts\");\n\n\n\n\n\n\n\n\n\n\nclass PlayerEntity extends _PathingEntity__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static APPEARANCE = 0x1;\n    static ANIM = 0x2;\n    static FACE_ENTITY = 0x4;\n    static SAY = 0x8;\n    static DAMAGE = 0x10;\n    static FACE_COORD = 0x20;\n    static CHAT = 0x40;\n    static BIG_UPDATE = 0x80;\n    static SPOTANIM = 0x100;\n    static EXACT_MOVE = 0x200;\n    // prettier-ignore\n    static TORSO_RECOLORS = [\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_KHAKI,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_CHARCOAL,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_CRIMSON,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_NAVY,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_STRAW,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_WHITE,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_RED,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_BLUE,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_GREEN,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_YELLOW,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_PURPLE,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_ORANGE,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_ROSE,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_LIME,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_CYAN,\n        _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RECOLOR_EMERALD\n    ];\n    // prettier-ignore\n    static DESIGN_IDK_COLORS = [\n        [\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_DARK_BROWN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_WHITE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_LIGHT_GREY,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_DARK_GREY,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_APRICOT,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_STRAW,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_LIGHT_BROWN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_BROWN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_TURQUOISE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_GREEN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_GINGER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].HAIR_MAGENTA\n        ],\n        [\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_KHAKI,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_CHARCOAL,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_CRIMSON,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_NAVY,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_STRAW,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_WHITE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RED,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_BLUE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_GREEN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_YELLOW,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_PURPLE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_ORANGE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_ROSE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_LIME,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_CYAN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_EMERALD\n        ],\n        [\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_EMERALD - 1,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_KHAKI + 1,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_CHARCOAL,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_CRIMSON,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_NAVY,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_STRAW,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_WHITE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_RED,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_BLUE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_GREEN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_YELLOW,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_PURPLE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_ORANGE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_ROSE,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_LIME,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].BODY_CYAN\n        ],\n        [\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].FEET_BROWN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].FEET_KHAKI,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].FEET_ASHEN,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].FEET_DARK,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].FEET_TERRACOTTA,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].FEET_GREY\n        ],\n        [\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN_DARKER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN_DARKER_DARKER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN_DARKER_DARKER_DARKER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN_DARKER_DARKER_DARKER_DARKER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN_DARKER_DARKER_DARKER_DARKER_DARKER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN_DARKER_DARKER_DARKER_DARKER_DARKER_DARKER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN_DARKER_DARKER_DARKER_DARKER_DARKER_DARKER_DARKER,\n            _graphics_Colors__WEBPACK_IMPORTED_MODULE_9__[\"default\"].SKIN\n        ]\n    ];\n    static modelCache = new _datastruct_LruCache__WEBPACK_IMPORTED_MODULE_2__[\"default\"](200);\n    name = null;\n    visible = false;\n    gender = 0;\n    headicons = 0;\n    appearances = new Uint16Array(12);\n    colors = new Uint16Array(5);\n    combatLevel = 0;\n    appearanceHashcode = 0n;\n    y = 0;\n    locStartCycle = 0;\n    locStopCycle = 0;\n    locOffsetX = 0;\n    locOffsetY = 0;\n    locOffsetZ = 0;\n    locModel = null;\n    minTileX = 0;\n    minTileZ = 0;\n    maxTileX = 0;\n    maxTileZ = 0;\n    lowMemory = false;\n    draw(loopCycle) {\n        if (!this.visible) {\n            return null;\n        }\n        let model = this.getSequencedModel();\n        this.height = model.maxY;\n        model.pickable = true;\n        if (this.lowMemory) {\n            return model;\n        }\n        if (this.spotanimId !== -1 && this.spotanimFrame !== -1) {\n            const spotanim = _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[this.spotanimId];\n            const model2 = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelShareColored(spotanim.getModel(), true, !spotanim.disposeAlpha, false);\n            model2.translate(-this.spotanimOffset, 0, 0);\n            model2.createLabelReferences();\n            if (spotanim.seq && spotanim.seq.frames) {\n                model2.applyTransform(spotanim.seq.frames[this.spotanimFrame]);\n            }\n            model2.labelFaces = null;\n            model2.labelVertices = null;\n            if (spotanim.resizeh !== 128 || spotanim.resizev !== 128) {\n                model2.scale(spotanim.resizeh, spotanim.resizev, spotanim.resizeh);\n            }\n            model2.calculateNormals(spotanim.ambient + 64, spotanim.contrast + 850, -30, -50, -30, true);\n            const models = [model, model2];\n            model = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelFromModelsBounds(models, 2);\n        }\n        if (this.locModel) {\n            if (loopCycle >= this.locStopCycle) {\n                this.locModel = null;\n            }\n            if (loopCycle >= this.locStartCycle && loopCycle < this.locStopCycle) {\n                const loc = this.locModel;\n                if (loc) {\n                    loc.translate(this.locOffsetY - this.y, this.locOffsetX - this.x, this.locOffsetZ - this.z);\n                    if (this.dstYaw === 512) {\n                        loc.rotateY90();\n                        loc.rotateY90();\n                        loc.rotateY90();\n                    }\n                    else if (this.dstYaw === 1024) {\n                        loc.rotateY90();\n                        loc.rotateY90();\n                    }\n                    else if (this.dstYaw === 1536) {\n                        loc.rotateY90();\n                    }\n                    const models = [model, loc];\n                    model = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelFromModelsBounds(models, 2);\n                    if (this.dstYaw === 512) {\n                        loc.rotateY90();\n                    }\n                    else if (this.dstYaw === 1024) {\n                        loc.rotateY90();\n                        loc.rotateY90();\n                    }\n                    else if (this.dstYaw === 1536) {\n                        loc.rotateY90();\n                        loc.rotateY90();\n                        loc.rotateY90();\n                    }\n                    loc.translate(this.y - this.locOffsetY, this.x - this.locOffsetX, this.z - this.locOffsetZ);\n                }\n            }\n        }\n        model.pickable = true;\n        return model;\n    }\n    isVisible() {\n        return this.visible;\n    }\n    read(buf) {\n        buf.pos = 0;\n        this.gender = buf.g1;\n        this.headicons = buf.g1;\n        for (let part = 0; part < 12; part++) {\n            const msb = buf.g1;\n            if (msb === 0) {\n                this.appearances[part] = 0;\n            }\n            else {\n                this.appearances[part] = (msb << 8) + buf.g1;\n            }\n        }\n        for (let part = 0; part < 5; part++) {\n            let color = buf.g1;\n            if (color < 0 || color >= PlayerEntity.DESIGN_IDK_COLORS[part].length) {\n                color = 0;\n            }\n            this.colors[part] = color;\n        }\n        this.seqStandId = buf.g2;\n        if (this.seqStandId === 65535) {\n            this.seqStandId = -1;\n        }\n        this.seqTurnId = buf.g2;\n        if (this.seqTurnId === 65535) {\n            this.seqTurnId = -1;\n        }\n        this.seqWalkId = buf.g2;\n        if (this.seqWalkId === 65535) {\n            this.seqWalkId = -1;\n        }\n        this.seqTurnAroundId = buf.g2;\n        if (this.seqTurnAroundId === 65535) {\n            this.seqTurnAroundId = -1;\n        }\n        this.seqTurnLeftId = buf.g2;\n        if (this.seqTurnLeftId === 65535) {\n            this.seqTurnLeftId = -1;\n        }\n        this.seqTurnRightId = buf.g2;\n        if (this.seqTurnRightId === 65535) {\n            this.seqTurnRightId = -1;\n        }\n        this.seqRunId = buf.g2;\n        if (this.seqRunId === 65535) {\n            this.seqRunId = -1;\n        }\n        this.name = _datastruct_JString__WEBPACK_IMPORTED_MODULE_7__[\"default\"].formatName(_datastruct_JString__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromBase37(buf.g8));\n        this.combatLevel = buf.g1;\n        this.visible = true;\n        this.appearanceHashcode = 0n;\n        for (let part = 0; part < 12; part++) {\n            this.appearanceHashcode <<= 0x4n;\n            if (this.appearances[part] >= 256) {\n                this.appearanceHashcode += BigInt(this.appearances[part]) - 256n;\n            }\n        }\n        if (this.appearances[0] >= 256) {\n            this.appearanceHashcode += (BigInt(this.appearances[0]) - 256n) >> 4n;\n        }\n        if (this.appearances[1] >= 256) {\n            this.appearanceHashcode += (BigInt(this.appearances[1]) - 256n) >> 8n;\n        }\n        for (let part = 0; part < 5; part++) {\n            this.appearanceHashcode <<= 0x3n;\n            this.appearanceHashcode += BigInt(this.colors[part]);\n        }\n        this.appearanceHashcode <<= 0x1n;\n        this.appearanceHashcode += BigInt(this.gender);\n    }\n    getHeadModel() {\n        if (!this.visible) {\n            return null;\n        }\n        const models = new _util_Arrays__WEBPACK_IMPORTED_MODULE_8__.TypedArray1d(12, null);\n        let modelCount = 0;\n        for (let part = 0; part < 12; part++) {\n            const value = this.appearances[part];\n            if (value >= 256 && value < 512) {\n                models[modelCount++] = _config_IdkType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instances[value - 256].getHeadModel();\n            }\n            if (value >= 512) {\n                const headModel = _config_ObjType__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(value - 512).getHeadModel(this.gender);\n                if (headModel) {\n                    models[modelCount++] = headModel;\n                }\n            }\n        }\n        const tmp = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelFromModels(models, modelCount);\n        for (let part = 0; part < 5; part++) {\n            if (this.colors[part] === 0) {\n                continue;\n            }\n            tmp.recolor(PlayerEntity.DESIGN_IDK_COLORS[part][0], PlayerEntity.DESIGN_IDK_COLORS[part][this.colors[part]]);\n            if (part === 1) {\n                tmp.recolor(PlayerEntity.TORSO_RECOLORS[0], PlayerEntity.TORSO_RECOLORS[this.colors[part]]);\n            }\n        }\n        return tmp;\n    }\n    getSequencedModel() {\n        let hashCode = this.appearanceHashcode;\n        let primaryTransformId = -1;\n        let secondaryTransformId = -1;\n        let rightHandValue = -1;\n        let leftHandValue = -1;\n        if (this.primarySeqId >= 0 && this.primarySeqDelay === 0) {\n            const seq = _config_SeqType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[this.primarySeqId];\n            if (seq.frames) {\n                primaryTransformId = seq.frames[this.primarySeqFrame];\n            }\n            if (this.secondarySeqId >= 0 && this.secondarySeqId !== this.seqStandId) {\n                const secondFrames = _config_SeqType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[this.secondarySeqId].frames;\n                if (secondFrames) {\n                    secondaryTransformId = secondFrames[this.secondarySeqFrame];\n                }\n            }\n            if (seq.righthand >= 0) {\n                rightHandValue = seq.righthand;\n                hashCode += BigInt(rightHandValue - this.appearances[5]) << 8n;\n            }\n            if (seq.lefthand >= 0) {\n                leftHandValue = seq.lefthand;\n                hashCode += BigInt(leftHandValue - this.appearances[3]) << 16n;\n            }\n        }\n        else if (this.secondarySeqId >= 0) {\n            const secondFrames = _config_SeqType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[this.secondarySeqId].frames;\n            if (secondFrames) {\n                primaryTransformId = secondFrames[this.secondarySeqFrame];\n            }\n        }\n        let model = PlayerEntity.modelCache?.get(hashCode);\n        if (!model) {\n            const models = new _util_Arrays__WEBPACK_IMPORTED_MODULE_8__.TypedArray1d(12, null);\n            let modelCount = 0;\n            for (let part = 0; part < 12; part++) {\n                let value = this.appearances[part];\n                if (leftHandValue >= 0 && part === 3) {\n                    value = leftHandValue;\n                }\n                if (rightHandValue >= 0 && part === 5) {\n                    value = rightHandValue;\n                }\n                if (value >= 256 && value < 512) {\n                    const idkModel = _config_IdkType__WEBPACK_IMPORTED_MODULE_5__[\"default\"].instances[value - 256].getModel();\n                    if (idkModel) {\n                        models[modelCount++] = idkModel;\n                    }\n                }\n                if (value >= 512) {\n                    const obj = _config_ObjType__WEBPACK_IMPORTED_MODULE_6__[\"default\"].get(value - 512);\n                    const wornModel = obj.getWornModel(this.gender);\n                    if (wornModel) {\n                        models[modelCount++] = wornModel;\n                    }\n                }\n            }\n            model = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelFromModels(models, modelCount);\n            for (let part = 0; part < 5; part++) {\n                if (this.colors[part] === 0) {\n                    continue;\n                }\n                model.recolor(PlayerEntity.DESIGN_IDK_COLORS[part][0], PlayerEntity.DESIGN_IDK_COLORS[part][this.colors[part]]);\n                if (part === 1) {\n                    model.recolor(PlayerEntity.TORSO_RECOLORS[0], PlayerEntity.TORSO_RECOLORS[this.colors[part]]);\n                }\n            }\n            model.createLabelReferences();\n            model.calculateNormals(64, 850, -30, -50, -30, true);\n            PlayerEntity.modelCache?.put(hashCode, model);\n        }\n        if (this.lowMemory) {\n            return model;\n        }\n        const tmp = _graphics_Model__WEBPACK_IMPORTED_MODULE_1__[\"default\"].modelShareAlpha(model, true);\n        if (primaryTransformId !== -1 && secondaryTransformId !== -1) {\n            tmp.applyTransforms(primaryTransformId, secondaryTransformId, _config_SeqType__WEBPACK_IMPORTED_MODULE_4__[\"default\"].instances[this.primarySeqId].walkmerge);\n        }\n        else if (primaryTransformId !== -1) {\n            tmp.applyTransform(primaryTransformId);\n        }\n        tmp.calculateBoundsCylinder();\n        tmp.labelFaces = null;\n        tmp.labelVertices = null;\n        return tmp;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/PlayerEntity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/ProjectileEntity.ts":
/*!*********************************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/ProjectileEntity.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ProjectileEntity)\n/* harmony export */ });\n/* harmony import */ var _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config/SpotAnimType */ \"./src/js/jagex2/config/SpotAnimType.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity */ \"./src/js/jagex2/dash3d/entity/Entity.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n\n\n\nclass ProjectileEntity extends _Entity__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    // constructor\n    spotanim;\n    level;\n    srcX;\n    srcZ;\n    srcY;\n    offsetY;\n    startCycle;\n    lastCycle;\n    peakPitch;\n    arc;\n    target;\n    // runtime\n    mobile = false;\n    x = 0.0;\n    z = 0.0;\n    y = 0.0;\n    velocityX = 0.0;\n    velocityZ = 0.0;\n    velocity = 0.0;\n    velocityY = 0.0;\n    accelerationY = 0.0;\n    yaw = 0;\n    pitch = 0;\n    seqFrame = 0;\n    seqCycle = 0;\n    constructor(spotanim, level, srcX, srcY, srcZ, startCycle, lastCycle, peakPitch, arc, target, offsetY) {\n        super();\n        this.spotanim = _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[spotanim];\n        this.level = level;\n        this.srcX = srcX;\n        this.srcZ = srcZ;\n        this.srcY = srcY;\n        this.startCycle = startCycle;\n        this.lastCycle = lastCycle;\n        this.peakPitch = peakPitch;\n        this.arc = arc;\n        this.target = target;\n        this.offsetY = offsetY;\n    }\n    updateVelocity(dstX, dstY, dstZ, cycle) {\n        if (!this.mobile) {\n            const dx = dstX - this.srcX;\n            const dz = dstZ - this.srcZ;\n            const d = Math.sqrt(dx * dx + dz * dz);\n            this.x = this.srcX + (dx * this.arc) / d;\n            this.z = this.srcZ + (dz * this.arc) / d;\n            this.y = this.srcY;\n        }\n        const dt = this.lastCycle + 1 - cycle;\n        this.velocityX = (dstX - this.x) / dt;\n        this.velocityZ = (dstZ - this.z) / dt;\n        this.velocity = Math.sqrt(this.velocityX * this.velocityX + this.velocityZ * this.velocityZ);\n        if (!this.mobile) {\n            this.velocityY = -this.velocity * Math.tan(this.peakPitch * 0.02454369);\n        }\n        this.accelerationY = ((dstY - this.y - this.velocityY * dt) * 2.0) / (dt * dt);\n    }\n    update(delta) {\n        this.mobile = true;\n        this.x += this.velocityX * delta;\n        this.z += this.velocityZ * delta;\n        this.y += this.velocityY * delta + this.accelerationY * 0.5 * delta * delta;\n        this.velocityY += this.accelerationY * delta;\n        this.yaw = ((Math.atan2(this.velocityX, this.velocityZ) * 325.949 + 1024) | 0) & 0x7ff;\n        this.pitch = ((Math.atan2(this.velocityY, this.velocity) * 325.949) | 0) & 0x7ff;\n        if (!this.spotanim.seq || !this.spotanim.seq.delay) {\n            return;\n        }\n        this.seqCycle += delta;\n        while (this.seqCycle > this.spotanim.seq.delay[this.seqFrame]) {\n            this.seqCycle -= this.spotanim.seq.delay[this.seqFrame] + 1;\n            this.seqFrame++;\n            if (this.seqFrame >= this.spotanim.seq.frameCount) {\n                this.seqFrame = 0;\n            }\n        }\n    }\n    draw() {\n        const tmp = this.spotanim.getModel();\n        const model = _graphics_Model__WEBPACK_IMPORTED_MODULE_2__[\"default\"].modelShareColored(tmp, true, !this.spotanim.disposeAlpha, false);\n        if (this.spotanim.seq && this.spotanim.seq.frames) {\n            model.createLabelReferences();\n            model.applyTransform(this.spotanim.seq.frames[this.seqFrame]);\n            model.labelFaces = null;\n            model.labelVertices = null;\n        }\n        if (this.spotanim.resizeh !== 128 || this.spotanim.resizev !== 128) {\n            model.scale(this.spotanim.resizeh, this.spotanim.resizev, this.spotanim.resizeh);\n        }\n        model.rotateX(this.pitch);\n        model.calculateNormals(64 + this.spotanim.ambient, 850 + this.spotanim.contrast, -30, -50, -30, true);\n        return model;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/ProjectileEntity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/entity/SpotAnimEntity.ts":
/*!*******************************************************!*\
  !*** ./src/js/jagex2/dash3d/entity/SpotAnimEntity.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SpotAnimEntity)\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"./src/js/jagex2/dash3d/entity/Entity.ts\");\n/* harmony import */ var _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config/SpotAnimType */ \"./src/js/jagex2/config/SpotAnimType.ts\");\n/* harmony import */ var _graphics_Model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graphics/Model */ \"./src/js/jagex2/graphics/Model.ts\");\n\n\n\nclass SpotAnimEntity extends _Entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // constructor\n    type;\n    level;\n    x;\n    z;\n    y;\n    startCycle;\n    // runtime\n    seqComplete = false;\n    seqFrame = 0;\n    seqCycle = 0;\n    constructor(id, level, x, z, y, cycle, delay) {\n        super();\n        this.type = _config_SpotAnimType__WEBPACK_IMPORTED_MODULE_1__[\"default\"].instances[id];\n        this.level = level;\n        this.x = x;\n        this.z = z;\n        this.y = y;\n        this.startCycle = cycle + delay;\n    }\n    update(delta) {\n        if (!this.type.seq || !this.type.seq.delay) {\n            return;\n        }\n        for (this.seqCycle += delta; this.seqCycle > this.type.seq.delay[this.seqFrame];) {\n            this.seqCycle -= this.type.seq.delay[this.seqFrame] + 1;\n            this.seqFrame++;\n            if (this.seqFrame >= this.type.seq.frameCount) {\n                this.seqFrame = 0;\n                this.seqComplete = true;\n            }\n        }\n    }\n    draw() {\n        const tmp = this.type.getModel();\n        const model = _graphics_Model__WEBPACK_IMPORTED_MODULE_2__[\"default\"].modelShareColored(tmp, true, !this.type.disposeAlpha, false);\n        if (!this.seqComplete && this.type.seq && this.type.seq.frames) {\n            model.createLabelReferences();\n            model.applyTransform(this.type.seq.frames[this.seqFrame]);\n            model.labelFaces = null;\n            model.labelVertices = null;\n        }\n        if (this.type.resizeh !== 128 || this.type.resizev !== 128) {\n            model.scale(this.type.resizeh, this.type.resizev, this.type.resizeh);\n        }\n        if (this.type.orientation !== 0) {\n            if (this.type.orientation === 90) {\n                model.rotateY90();\n            }\n            else if (this.type.orientation === 180) {\n                model.rotateY90();\n                model.rotateY90();\n            }\n            else if (this.type.orientation === 270) {\n                model.rotateY90();\n                model.rotateY90();\n                model.rotateY90();\n            }\n        }\n        model.calculateNormals(64 + this.type.ambient, 850 + this.type.contrast, -30, -50, -30, true);\n        return model;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/entity/SpotAnimEntity.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/GroundDecoration.ts":
/*!*******************************************************!*\
  !*** ./src/js/jagex2/dash3d/type/GroundDecoration.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GroundDecoration)\n/* harmony export */ });\nclass GroundDecoration {\n    // constructor\n    y;\n    x;\n    z;\n    model;\n    bitset;\n    info; // byte\n    constructor(y, x, z, model, bitset, info) {\n        this.y = y;\n        this.x = x;\n        this.z = z;\n        this.model = model;\n        this.bitset = bitset;\n        this.info = info;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/GroundDecoration.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/Loc.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/dash3d/type/Loc.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Loc)\n/* harmony export */ });\nclass Loc {\n    // constructor\n    level;\n    y;\n    x;\n    z;\n    model;\n    entity;\n    yaw;\n    minSceneTileX;\n    maxSceneTileX;\n    minSceneTileZ;\n    maxSceneTileZ;\n    bitset;\n    info; // byte\n    // runtime\n    distance = 0;\n    cycle = 0;\n    constructor(level, y, x, z, model, entity, yaw, minSceneTileX, maxSceneTileX, minSceneTileZ, maxSceneTileZ, bitset, info) {\n        this.level = level;\n        this.y = y;\n        this.x = x;\n        this.z = z;\n        this.model = model;\n        this.entity = entity;\n        this.yaw = yaw;\n        this.minSceneTileX = minSceneTileX;\n        this.maxSceneTileX = maxSceneTileX;\n        this.minSceneTileZ = minSceneTileZ;\n        this.maxSceneTileZ = maxSceneTileZ;\n        this.bitset = bitset;\n        this.info = info;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/Loc.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/LocSpawned.ts":
/*!*************************************************!*\
  !*** ./src/js/jagex2/dash3d/type/LocSpawned.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocSpawned)\n/* harmony export */ });\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass LocSpawned extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    plane;\n    layer;\n    x;\n    z;\n    locIndex;\n    angle;\n    shape;\n    lastCycle;\n    constructor(plane, layer, x, z, locIndex, angle, shape, lastCycle) {\n        super();\n        this.plane = plane;\n        this.layer = layer;\n        this.x = x;\n        this.z = z;\n        this.locIndex = locIndex;\n        this.angle = angle;\n        this.shape = shape;\n        this.lastCycle = lastCycle;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/LocSpawned.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/LocTemporary.ts":
/*!***************************************************!*\
  !*** ./src/js/jagex2/dash3d/type/LocTemporary.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocTemporary)\n/* harmony export */ });\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass LocTemporary extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // constructor\n    plane;\n    layer;\n    x;\n    z;\n    locIndex;\n    angle;\n    shape;\n    lastLocIndex;\n    lastAngle;\n    lastShape;\n    constructor(plane, layer, x, z, locIndex, angle, shape, lastLocIndex, lastAngle, lastShape) {\n        super();\n        this.plane = plane;\n        this.layer = layer;\n        this.x = x;\n        this.z = z;\n        this.locIndex = locIndex;\n        this.angle = angle;\n        this.shape = shape;\n        this.lastLocIndex = lastLocIndex;\n        this.lastAngle = lastAngle;\n        this.lastShape = lastShape;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/LocTemporary.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/ObjStack.ts":
/*!***********************************************!*\
  !*** ./src/js/jagex2/dash3d/type/ObjStack.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ObjStack)\n/* harmony export */ });\nclass ObjStack {\n    // constructor\n    y;\n    x;\n    z;\n    topObj;\n    middleObj;\n    bottomObj;\n    bitset;\n    offset;\n    constructor(y, x, z, topObj, middleObj, bottomObj, bitset, offset) {\n        this.y = y;\n        this.x = x;\n        this.z = z;\n        this.topObj = topObj;\n        this.middleObj = middleObj;\n        this.bottomObj = bottomObj;\n        this.bitset = bitset;\n        this.offset = offset;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/ObjStack.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/Occluder.ts":
/*!***********************************************!*\
  !*** ./src/js/jagex2/dash3d/type/Occluder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Occluder)\n/* harmony export */ });\nclass Occluder {\n    // constructor\n    minTileX;\n    maxTileX;\n    minTileZ;\n    maxTileZ;\n    type;\n    minX;\n    maxX;\n    minZ;\n    maxZ;\n    minY;\n    maxY;\n    // runtime\n    mode = 0;\n    minDeltaX = 0;\n    maxDeltaX = 0;\n    minDeltaZ = 0;\n    maxDeltaZ = 0;\n    minDeltaY = 0;\n    maxDeltaY = 0;\n    constructor(minTileX, maxTileX, minTileZ, maxTileZ, type, minX, maxX, minZ, maxZ, minY, maxY) {\n        this.minTileX = minTileX;\n        this.maxTileX = maxTileX;\n        this.minTileZ = minTileZ;\n        this.maxTileZ = maxTileZ;\n        this.type = type;\n        this.minX = minX;\n        this.maxX = maxX;\n        this.minZ = minZ;\n        this.maxZ = maxZ;\n        this.minY = minY;\n        this.maxY = maxY;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/Occluder.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/Tile.ts":
/*!*******************************************!*\
  !*** ./src/js/jagex2/dash3d/type/Tile.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tile)\n/* harmony export */ });\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\nclass Tile extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // constructor\n    level;\n    x;\n    z;\n    occludeLevel;\n    locs;\n    locSpan;\n    // runtime\n    underlay = null;\n    overlay = null;\n    wall = null;\n    wallDecoration = null;\n    groundDecoration = null;\n    objStack = null;\n    bridge = null;\n    locCount = 0;\n    locSpans = 0;\n    drawLevel = 0;\n    visible = false;\n    update = false;\n    containsLocs = false;\n    checkLocSpans = 0;\n    blockLocSpans = 0;\n    inverseBlockLocSpans = 0;\n    backWallTypes = 0;\n    constructor(level, x, z) {\n        super();\n        this.occludeLevel = this.level = level;\n        this.x = x;\n        this.z = z;\n        this.locs = new _util_Arrays__WEBPACK_IMPORTED_MODULE_1__.TypedArray1d(5, null);\n        this.locSpan = new Int32Array(5);\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/Tile.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/TileOverlay.ts":
/*!**************************************************!*\
  !*** ./src/js/jagex2/dash3d/type/TileOverlay.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TileOverlay)\n/* harmony export */ });\nclass TileOverlay {\n    static tmpScreenX = new Int32Array(6);\n    static tmpScreenY = new Int32Array(6);\n    static tmpViewspaceX = new Int32Array(6);\n    static tmpViewspaceY = new Int32Array(6);\n    static tmpViewspaceZ = new Int32Array(6);\n    // prettier-ignore\n    static SHAPE_POINTS = [\n        Int8Array.of(1, 3, 5, 7),\n        Int8Array.of(1, 3, 5, 7),\n        Int8Array.of(1, 3, 5, 7),\n        Int8Array.of(1, 3, 5, 7, 6),\n        Int8Array.of(1, 3, 5, 7, 6),\n        Int8Array.of(1, 3, 5, 7, 6),\n        Int8Array.of(1, 3, 5, 7, 6),\n        Int8Array.of(1, 3, 5, 7, 2, 6),\n        Int8Array.of(1, 3, 5, 7, 2, 8),\n        Int8Array.of(1, 3, 5, 7, 2, 8),\n        Int8Array.of(1, 3, 5, 7, 11, 12),\n        Int8Array.of(1, 3, 5, 7, 11, 12),\n        Int8Array.of(1, 3, 5, 7, 13, 14)\n    ];\n    // prettier-ignore\n    static SHAPE_PATHS = [\n        Int8Array.of(0, 1, 2, 3, 0, 0, 1, 3),\n        Int8Array.of(1, 1, 2, 3, 1, 0, 1, 3),\n        Int8Array.of(0, 1, 2, 3, 1, 0, 1, 3),\n        Int8Array.of(0, 0, 1, 2, 0, 0, 2, 4, 1, 0, 4, 3),\n        Int8Array.of(0, 0, 1, 4, 0, 0, 4, 3, 1, 1, 2, 4),\n        Int8Array.of(0, 0, 4, 3, 1, 0, 1, 2, 1, 0, 2, 4),\n        Int8Array.of(0, 1, 2, 4, 1, 0, 1, 4, 1, 0, 4, 3),\n        Int8Array.of(0, 4, 1, 2, 0, 4, 2, 5, 1, 0, 4, 5, 1, 0, 5, 3),\n        Int8Array.of(0, 4, 1, 2, 0, 4, 2, 3, 0, 4, 3, 5, 1, 0, 4, 5),\n        Int8Array.of(0, 0, 4, 5, 1, 4, 1, 2, 1, 4, 2, 3, 1, 4, 3, 5),\n        Int8Array.of(0, 0, 1, 5, 0, 1, 4, 5, 0, 1, 2, 4, 1, 0, 5, 3, 1, 5, 4, 3, 1, 4, 2, 3),\n        Int8Array.of(1, 0, 1, 5, 1, 1, 4, 5, 1, 1, 2, 4, 0, 0, 5, 3, 0, 5, 4, 3, 0, 4, 2, 3),\n        Int8Array.of(1, 0, 5, 4, 1, 0, 1, 5, 0, 0, 4, 3, 0, 4, 5, 3, 0, 5, 2, 3, 0, 1, 2, 5)\n    ];\n    static FULL_SQUARE = 128;\n    static HALF_SQUARE = (this.FULL_SQUARE / 2) | 0;\n    static CORNER_SMALL = (this.FULL_SQUARE / 4) | 0;\n    static CORNER_BIG = ((this.FULL_SQUARE * 3) / 4) | 0;\n    // ----\n    // constructor\n    vertexX;\n    vertexY;\n    vertexZ;\n    triangleColorA;\n    triangleColorB;\n    triangleColorC;\n    triangleVertexA;\n    triangleVertexB;\n    triangleVertexC;\n    triangleTextureIds;\n    flat;\n    shape;\n    angle;\n    backgroundRgb;\n    foregroundRgb;\n    constructor(tileX, shape, southeastColor2, southeastY, northeastColor1, angle, southwestColor1, northwestY, foregroundRgb, southwestColor2, textureId, northwestColor2, backgroundRgb, northeastY, northeastColor2, northwestColor1, southwestY, tileZ, southeastColor1) {\n        this.flat = !(southwestY !== southeastY || southwestY !== northeastY || southwestY !== northwestY);\n        this.shape = shape;\n        this.angle = angle;\n        this.backgroundRgb = backgroundRgb;\n        this.foregroundRgb = foregroundRgb;\n        const points = TileOverlay.SHAPE_POINTS[shape];\n        const vertexCount = points.length;\n        this.vertexX = new Int32Array(vertexCount);\n        this.vertexY = new Int32Array(vertexCount);\n        this.vertexZ = new Int32Array(vertexCount);\n        const primaryColors = new Int32Array(vertexCount);\n        const secondaryColors = new Int32Array(vertexCount);\n        const sceneX = tileX * TileOverlay.FULL_SQUARE;\n        const sceneZ = tileZ * TileOverlay.FULL_SQUARE;\n        for (let v = 0; v < vertexCount; v++) {\n            let type = points[v];\n            if ((type & 0x1) === 0 && type <= 8) {\n                type = ((type - angle - angle - 1) & 0x7) + 1;\n            }\n            if (type > 8 && type <= 12) {\n                type = ((type - angle - 9) & 0x3) + 9;\n            }\n            if (type > 12 && type <= 16) {\n                type = ((type - angle - 13) & 0x3) + 13;\n            }\n            let x;\n            let z;\n            let y;\n            let color1;\n            let color2;\n            if (type === 1) {\n                x = sceneX;\n                z = sceneZ;\n                y = southwestY;\n                color1 = southwestColor1;\n                color2 = southwestColor2;\n            }\n            else if (type === 2) {\n                x = sceneX + TileOverlay.HALF_SQUARE;\n                z = sceneZ;\n                y = (southwestY + southeastY) >> 1;\n                color1 = (southwestColor1 + southeastColor1) >> 1;\n                color2 = (southwestColor2 + southeastColor2) >> 1;\n            }\n            else if (type === 3) {\n                x = sceneX + TileOverlay.FULL_SQUARE;\n                z = sceneZ;\n                y = southeastY;\n                color1 = southeastColor1;\n                color2 = southeastColor2;\n            }\n            else if (type === 4) {\n                x = sceneX + TileOverlay.FULL_SQUARE;\n                z = sceneZ + TileOverlay.HALF_SQUARE;\n                y = (southeastY + northeastY) >> 1;\n                color1 = (southeastColor1 + northeastColor1) >> 1;\n                color2 = (southeastColor2 + northeastColor2) >> 1;\n            }\n            else if (type === 5) {\n                x = sceneX + TileOverlay.FULL_SQUARE;\n                z = sceneZ + TileOverlay.FULL_SQUARE;\n                y = northeastY;\n                color1 = northeastColor1;\n                color2 = northeastColor2;\n            }\n            else if (type === 6) {\n                x = sceneX + TileOverlay.HALF_SQUARE;\n                z = sceneZ + TileOverlay.FULL_SQUARE;\n                y = (northeastY + northwestY) >> 1;\n                color1 = (northeastColor1 + northwestColor1) >> 1;\n                color2 = (northeastColor2 + northwestColor2) >> 1;\n            }\n            else if (type === 7) {\n                x = sceneX;\n                z = sceneZ + TileOverlay.FULL_SQUARE;\n                y = northwestY;\n                color1 = northwestColor1;\n                color2 = northwestColor2;\n            }\n            else if (type === 8) {\n                x = sceneX;\n                z = sceneZ + TileOverlay.HALF_SQUARE;\n                y = (northwestY + southwestY) >> 1;\n                color1 = (northwestColor1 + southwestColor1) >> 1;\n                color2 = (northwestColor2 + southwestColor2) >> 1;\n            }\n            else if (type === 9) {\n                x = sceneX + TileOverlay.HALF_SQUARE;\n                z = sceneZ + TileOverlay.CORNER_SMALL;\n                y = (southwestY + southeastY) >> 1;\n                color1 = (southwestColor1 + southeastColor1) >> 1;\n                color2 = (southwestColor2 + southeastColor2) >> 1;\n            }\n            else if (type === 10) {\n                x = sceneX + TileOverlay.CORNER_BIG;\n                z = sceneZ + TileOverlay.HALF_SQUARE;\n                y = (southeastY + northeastY) >> 1;\n                color1 = (southeastColor1 + northeastColor1) >> 1;\n                color2 = (southeastColor2 + northeastColor2) >> 1;\n            }\n            else if (type === 11) {\n                x = sceneX + TileOverlay.HALF_SQUARE;\n                z = sceneZ + TileOverlay.CORNER_BIG;\n                y = (northeastY + northwestY) >> 1;\n                color1 = (northeastColor1 + northwestColor1) >> 1;\n                color2 = (northeastColor2 + northwestColor2) >> 1;\n            }\n            else if (type === 12) {\n                x = sceneX + TileOverlay.CORNER_SMALL;\n                z = sceneZ + TileOverlay.HALF_SQUARE;\n                y = (northwestY + southwestY) >> 1;\n                color1 = (northwestColor1 + southwestColor1) >> 1;\n                color2 = (northwestColor2 + southwestColor2) >> 1;\n            }\n            else if (type === 13) {\n                x = sceneX + TileOverlay.CORNER_SMALL;\n                z = sceneZ + TileOverlay.CORNER_SMALL;\n                y = southwestY;\n                color1 = southwestColor1;\n                color2 = southwestColor2;\n            }\n            else if (type === 14) {\n                x = sceneX + TileOverlay.CORNER_BIG;\n                z = sceneZ + TileOverlay.CORNER_SMALL;\n                y = southeastY;\n                color1 = southeastColor1;\n                color2 = southeastColor2;\n            }\n            else if (type === 15) {\n                x = sceneX + TileOverlay.CORNER_BIG;\n                z = sceneZ + TileOverlay.CORNER_BIG;\n                y = northeastY;\n                color1 = northeastColor1;\n                color2 = northeastColor2;\n            }\n            else {\n                x = sceneX + TileOverlay.CORNER_SMALL;\n                z = sceneZ + TileOverlay.CORNER_BIG;\n                y = northwestY;\n                color1 = northwestColor1;\n                color2 = northwestColor2;\n            }\n            this.vertexX[v] = x;\n            this.vertexY[v] = y;\n            this.vertexZ[v] = z;\n            primaryColors[v] = color1;\n            secondaryColors[v] = color2;\n        }\n        const paths = TileOverlay.SHAPE_PATHS[shape];\n        const triangleCount = (paths.length / 4) | 0;\n        this.triangleVertexA = new Int32Array(triangleCount);\n        this.triangleVertexB = new Int32Array(triangleCount);\n        this.triangleVertexC = new Int32Array(triangleCount);\n        this.triangleColorA = new Int32Array(triangleCount);\n        this.triangleColorB = new Int32Array(triangleCount);\n        this.triangleColorC = new Int32Array(triangleCount);\n        if (textureId !== -1) {\n            this.triangleTextureIds = new Int32Array(triangleCount);\n        }\n        else {\n            this.triangleTextureIds = null;\n        }\n        let index = 0;\n        for (let t = 0; t < triangleCount; t++) {\n            const color = paths[index];\n            let a = paths[index + 1];\n            let b = paths[index + 2];\n            let c = paths[index + 3];\n            index += 4;\n            if (a < 4) {\n                a = (a - angle) & 0x3;\n            }\n            if (b < 4) {\n                b = (b - angle) & 0x3;\n            }\n            if (c < 4) {\n                c = (c - angle) & 0x3;\n            }\n            this.triangleVertexA[t] = a;\n            this.triangleVertexB[t] = b;\n            this.triangleVertexC[t] = c;\n            if (color === 0) {\n                this.triangleColorA[t] = primaryColors[a];\n                this.triangleColorB[t] = primaryColors[b];\n                this.triangleColorC[t] = primaryColors[c];\n                if (this.triangleTextureIds) {\n                    this.triangleTextureIds[t] = -1;\n                }\n            }\n            else {\n                this.triangleColorA[t] = secondaryColors[a];\n                this.triangleColorB[t] = secondaryColors[b];\n                this.triangleColorC[t] = secondaryColors[c];\n                if (this.triangleTextureIds) {\n                    this.triangleTextureIds[t] = textureId;\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/TileOverlay.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/TileOverlayShape.ts":
/*!*******************************************************!*\
  !*** ./src/js/jagex2/dash3d/type/TileOverlayShape.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TileOverlayShape)\n/* harmony export */ });\nclass TileOverlayShape {\n    static PLAIN = 0;\n    static DIAGONAL = 1;\n    static LEFT_SEMI_DIAGONAL_SMALL = 2;\n    static RIGHT_SEMI_DIAGONAL_SMALL = 3;\n    static LEFT_SEMI_DIAGONAL_BIG = 4;\n    static RIGHT_SEMI_DIAGONAL_BIG = 5;\n    static HALF_SQUARE = 6;\n    static CORNER_SMALL = 7;\n    static CORNER_BIG = 8;\n    static FAN_SMALL = 9;\n    static FAN_BIG = 10;\n    static TRAPEZIUM = 11;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/TileOverlayShape.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/TileUnderlay.ts":
/*!***************************************************!*\
  !*** ./src/js/jagex2/dash3d/type/TileUnderlay.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TileUnderlay)\n/* harmony export */ });\nclass TileUnderlay {\n    // constructor\n    southwestColor;\n    southeastColor;\n    northeastColor;\n    northwestColor;\n    textureId;\n    color;\n    flat;\n    constructor(southwestColor, southeastColor, northeastColor, northwestColor, textureId, color, flat) {\n        this.southwestColor = southwestColor;\n        this.southeastColor = southeastColor;\n        this.northeastColor = northeastColor;\n        this.northwestColor = northwestColor;\n        this.textureId = textureId;\n        this.color = color;\n        this.flat = flat;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/TileUnderlay.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/Wall.ts":
/*!*******************************************!*\
  !*** ./src/js/jagex2/dash3d/type/Wall.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Wall)\n/* harmony export */ });\nclass Wall {\n    // constructor\n    y;\n    x;\n    z;\n    typeA;\n    typeB;\n    modelA;\n    modelB;\n    bitset;\n    info; // byte\n    constructor(y, x, z, typeA, typeB, modelA, modelB, bitset, info) {\n        this.y = y;\n        this.x = x;\n        this.z = z;\n        this.typeA = typeA;\n        this.typeB = typeB;\n        this.modelA = modelA;\n        this.modelB = modelB;\n        this.bitset = bitset;\n        this.info = info;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/Wall.ts?");

/***/ }),

/***/ "./src/js/jagex2/dash3d/type/WallDecoration.ts":
/*!*****************************************************!*\
  !*** ./src/js/jagex2/dash3d/type/WallDecoration.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WallDecoration)\n/* harmony export */ });\nclass WallDecoration {\n    // constructor\n    y;\n    x;\n    z;\n    type;\n    angle;\n    model;\n    bitset;\n    info; // byte\n    constructor(y, x, z, type, angle, model, bitset, info) {\n        this.y = y;\n        this.x = x;\n        this.z = z;\n        this.type = type;\n        this.angle = angle;\n        this.model = model;\n        this.bitset = bitset;\n        this.info = info;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/dash3d/type/WallDecoration.ts?");

/***/ }),

/***/ "./src/js/jagex2/datastruct/HashTable.ts":
/*!***********************************************!*\
  !*** ./src/js/jagex2/datastruct/HashTable.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HashTable)\n/* harmony export */ });\n/* harmony import */ var _Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass HashTable {\n    // constructor\n    bucketCount;\n    buckets;\n    constructor(size) {\n        this.buckets = [];\n        this.bucketCount = size;\n        for (let i = 0; i < size; i++) {\n            this.buckets[i] = new _Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        }\n    }\n    get(key) {\n        const start = this.buckets[Number(key & BigInt(this.bucketCount - 1))];\n        const next = start.next;\n        if (!next) {\n            return null;\n        }\n        for (let node = start.next; node !== start; node = node.next) {\n            if (!node) {\n                continue;\n            }\n            if (node.key === key) {\n                return node;\n            }\n        }\n        return null;\n    }\n    put(key, value) {\n        if (value.prev) {\n            value.unlink();\n        }\n        const sentinel = this.buckets[Number(key & BigInt(this.bucketCount - 1))];\n        value.prev = sentinel.prev;\n        value.next = sentinel;\n        if (value.prev) {\n            value.prev.next = value;\n        }\n        value.next.prev = value;\n        value.key = key;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/datastruct/HashTable.ts?");

/***/ }),

/***/ "./src/js/jagex2/datastruct/Hashable.ts":
/*!**********************************************!*\
  !*** ./src/js/jagex2/datastruct/Hashable.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hashable)\n/* harmony export */ });\n/* harmony import */ var _Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass Hashable extends _Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    // constructor\n    nextHashable;\n    prevHashable;\n    constructor() {\n        super();\n        this.nextHashable = this;\n        this.prevHashable = this;\n    }\n    uncache() {\n        if (!this.prevHashable || !this.nextHashable) {\n            return;\n        }\n        this.prevHashable.nextHashable = this.nextHashable;\n        this.nextHashable.prevHashable = this.prevHashable;\n        this.nextHashable = null;\n        this.prevHashable = null;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/datastruct/Hashable.ts?");

/***/ }),

/***/ "./src/js/jagex2/datastruct/JString.ts":
/*!*********************************************!*\
  !*** ./src/js/jagex2/datastruct/JString.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JString)\n/* harmony export */ });\nclass JString {\n    // prettier-ignore\n    static BASE37_LOOKUP = [\n        '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n        'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\n        't', 'u', 'v', 'w', 'x', 'y', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    ];\n    static toBase37 = (string) => {\n        string = string.trim();\n        let l = 0n;\n        for (let i = 0; i < string.length && i < 12; i++) {\n            const c = string.charCodeAt(i);\n            l *= 37n;\n            if (c >= 0x41 && c <= 0x5a) {\n                // A-Z\n                l += BigInt(c + 1 - 0x41);\n            }\n            else if (c >= 0x61 && c <= 0x7a) {\n                // a-z\n                l += BigInt(c + 1 - 0x61);\n            }\n            else if (c >= 0x30 && c <= 0x39) {\n                // 0-9\n                l += BigInt(c + 27 - 0x30);\n            }\n        }\n        return l;\n    };\n    static fromBase37 = (value) => {\n        // >= 37 to the 12th power\n        if (value < 0n || value >= 6582952005840035281n) {\n            return 'invalid_name';\n        }\n        if (value % 37n === 0n) {\n            return 'invalid_name';\n        }\n        let len = 0;\n        const chars = Array(12);\n        while (value !== 0n) {\n            const l1 = value;\n            value /= 37n;\n            chars[11 - len++] = this.BASE37_LOOKUP[Number(l1 - value * 37n)];\n        }\n        return chars.slice(12 - len).join('');\n    };\n    static toSentenceCase = (input) => {\n        const chars = [...input.toLowerCase()];\n        let punctuation = true;\n        for (let index = 0; index < chars.length; index++) {\n            const char = chars[index];\n            if (punctuation && char >= 'a' && char <= 'z') {\n                chars[index] = char.toUpperCase();\n                punctuation = false;\n            }\n            if (char === '.' || char === '!') {\n                punctuation = true;\n            }\n        }\n        return chars.join('');\n    };\n    static toAsterisks = (str) => {\n        let temp = '';\n        for (let i = 0; i < str.length; i++) {\n            temp = temp + '*';\n        }\n        return temp;\n    };\n    static formatIPv4 = (ip) => {\n        return ((ip >> 24) & 0xff) + '.' + ((ip >> 16) & 0xff) + '.' + ((ip >> 8) & 0xff) + '.' + (ip & 0xff);\n    };\n    static formatName = (str) => {\n        if (str.length === 0) {\n            return str;\n        }\n        const chars = [...str];\n        for (let i = 0; i < chars.length; i++) {\n            if (chars[i] === '_') {\n                chars[i] = ' ';\n                if (i + 1 < chars.length && chars[i + 1] >= 'a' && chars[i + 1] <= 'z') {\n                    chars[i + 1] = String.fromCharCode(chars[i + 1].charCodeAt(0) + 'A'.charCodeAt(0) - 97);\n                }\n            }\n        }\n        if (chars[0] >= 'a' && chars[0] <= 'z') {\n            chars[0] = String.fromCharCode(chars[0].charCodeAt(0) + 'A'.charCodeAt(0) - 97);\n        }\n        return chars.join('');\n    };\n    static hashCode = (str) => {\n        const upper = str.toUpperCase();\n        let hash = 0n;\n        for (let i = 0; i < upper.length; i++) {\n            hash = hash * 61n + BigInt(upper.charCodeAt(i)) - 32n;\n            hash = (hash + (hash >> 56n)) & 0xffffffffffffffn;\n        }\n        return hash;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/datastruct/JString.ts?");

/***/ }),

/***/ "./src/js/jagex2/datastruct/LinkList.ts":
/*!**********************************************!*\
  !*** ./src/js/jagex2/datastruct/LinkList.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LinkList)\n/* harmony export */ });\n/* harmony import */ var _Linkable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\nclass LinkList {\n    // constructor\n    sentinel;\n    // runtime\n    cursor = null;\n    constructor() {\n        const head = new _Linkable__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        head.next = head;\n        head.prev = head;\n        this.sentinel = head;\n    }\n    addTail(node) {\n        if (node.prev) {\n            node.unlink();\n        }\n        node.prev = this.sentinel.prev;\n        node.next = this.sentinel;\n        if (node.prev) {\n            node.prev.next = node;\n        }\n        node.next.prev = node;\n    }\n    addHead(node) {\n        if (node.prev) {\n            node.unlink();\n        }\n        node.prev = this.sentinel;\n        node.next = this.sentinel.next;\n        node.prev.next = node;\n        if (node.next) {\n            node.next.prev = node;\n        }\n    }\n    removeHead() {\n        const node = this.sentinel.next;\n        if (node === this.sentinel) {\n            return null;\n        }\n        node?.unlink();\n        return node;\n    }\n    head() {\n        const node = this.sentinel.next;\n        if (node === this.sentinel) {\n            this.cursor = null;\n            return null;\n        }\n        this.cursor = node?.next || null;\n        return node;\n    }\n    tail() {\n        const node = this.sentinel.prev;\n        if (node === this.sentinel) {\n            this.cursor = null;\n            return null;\n        }\n        this.cursor = node?.prev || null;\n        return node;\n    }\n    next() {\n        const node = this.cursor;\n        if (node === this.sentinel) {\n            this.cursor = null;\n            return null;\n        }\n        this.cursor = node?.next || null;\n        return node;\n    }\n    prev() {\n        const node = this.cursor;\n        if (node === this.sentinel) {\n            this.cursor = null;\n            return null;\n        }\n        this.cursor = node?.prev || null;\n        return node;\n    }\n    clear() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const node = this.sentinel.next;\n            if (node === this.sentinel) {\n                return;\n            }\n            node?.unlink();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/datastruct/LinkList.ts?");

/***/ }),

/***/ "./src/js/jagex2/datastruct/Linkable.ts":
/*!**********************************************!*\
  !*** ./src/js/jagex2/datastruct/Linkable.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Linkable)\n/* harmony export */ });\nclass Linkable {\n    key;\n    next;\n    prev;\n    constructor() {\n        this.key = 0n;\n        this.next = this;\n        this.prev = this;\n    }\n    unlink() {\n        if (!this.prev || !this.next) {\n            return;\n        }\n        this.prev.next = this.next;\n        this.next.prev = this.prev;\n        this.next = null;\n        this.prev = null;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/datastruct/Linkable.ts?");

/***/ }),

/***/ "./src/js/jagex2/datastruct/LruCache.ts":
/*!**********************************************!*\
  !*** ./src/js/jagex2/datastruct/LruCache.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LruCache)\n/* harmony export */ });\n/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stack */ \"./src/js/jagex2/datastruct/Stack.ts\");\n/* harmony import */ var _HashTable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HashTable */ \"./src/js/jagex2/datastruct/HashTable.ts\");\n\n\nclass LruCache {\n    // constructor\n    capacity;\n    hashtable;\n    history;\n    available;\n    constructor(size) {\n        this.capacity = size;\n        this.available = size;\n        this.hashtable = new _HashTable__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1024);\n        this.history = new _Stack__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    }\n    get(key) {\n        const node = this.hashtable.get(key);\n        if (node) {\n            this.history.push(node);\n        }\n        return node;\n    }\n    put(key, value) {\n        if (this.available === 0) {\n            const node = this.history.pop();\n            node?.unlink();\n            node?.uncache();\n        }\n        else {\n            this.available--;\n        }\n        this.hashtable.put(key, value);\n        this.history.push(value);\n    }\n    clear() {\n        const node = this.history.pop();\n        if (!node) {\n            this.available = this.capacity;\n            return;\n        }\n        node.unlink();\n        node.uncache();\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/datastruct/LruCache.ts?");

/***/ }),

/***/ "./src/js/jagex2/datastruct/Stack.ts":
/*!*******************************************!*\
  !*** ./src/js/jagex2/datastruct/Stack.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _Hashable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hashable */ \"./src/js/jagex2/datastruct/Hashable.ts\");\n\nclass Stack {\n    head;\n    constructor() {\n        this.head = new _Hashable__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    }\n    push(node) {\n        if (node.prevHashable) {\n            node.uncache();\n        }\n        node.prevHashable = this.head.prevHashable;\n        node.nextHashable = this.head;\n        if (node.prevHashable) {\n            node.prevHashable.nextHashable = node;\n        }\n        node.nextHashable.prevHashable = node;\n    }\n    pop() {\n        const node = this.head.nextHashable;\n        if (node === this.head) {\n            return null;\n        }\n        else {\n            node?.uncache();\n            return node;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/datastruct/Stack.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/AnimBase.ts":
/*!********************************************!*\
  !*** ./src/js/jagex2/graphics/AnimBase.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AnimBase)\n/* harmony export */ });\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\nclass AnimBase {\n    static instances = [];\n    static unpack = (models) => {\n        const head = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('base_head.dat'));\n        const type = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('base_type.dat'));\n        const label = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('base_label.dat'));\n        const total = head.g2;\n        head.pos += 2; // const count = head.g2;\n        for (let i = 0; i < total; i++) {\n            const id = head.g2;\n            const length = head.g1;\n            const transformTypes = new Uint8Array(length);\n            const groupLabels = new _util_Arrays__WEBPACK_IMPORTED_MODULE_1__.TypedArray1d(length, null);\n            for (let j = 0; j < length; j++) {\n                transformTypes[j] = type.g1;\n                const groupCount = label.g1;\n                const labels = new Uint8Array(groupCount);\n                for (let k = 0; k < groupCount; k++) {\n                    labels[k] = label.g1;\n                }\n                groupLabels[j] = labels;\n            }\n            this.instances[id] = new AnimBase();\n            this.instances[id].length = length;\n            this.instances[id].types = transformTypes;\n            this.instances[id].labels = groupLabels;\n        }\n    };\n    // ----\n    length = 0;\n    types = null;\n    labels = null;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/AnimBase.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/AnimFrame.ts":
/*!*********************************************!*\
  !*** ./src/js/jagex2/graphics/AnimFrame.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AnimFrame)\n/* harmony export */ });\n/* harmony import */ var _AnimBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimBase */ \"./src/js/jagex2/graphics/AnimBase.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n\n\nclass AnimFrame {\n    static instances = [];\n    static unpack = (models) => {\n        const head = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](models.read('frame_head.dat'));\n        const tran1 = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](models.read('frame_tran1.dat'));\n        const tran2 = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](models.read('frame_tran2.dat'));\n        const del = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](models.read('frame_del.dat'));\n        const total = head.g2;\n        head.pos += 2; // const count = head.g2;\n        const labels = new Int32Array(500);\n        const x = new Int32Array(500);\n        const y = new Int32Array(500);\n        const z = new Int32Array(500);\n        for (let i = 0; i < total; i++) {\n            const id = head.g2;\n            const frame = (this.instances[id] = new AnimFrame());\n            frame.delay = del.g1;\n            const baseId = head.g2;\n            const base = _AnimBase__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instances[baseId];\n            frame.base = base;\n            const groupCount = head.g1;\n            let lastGroup = -1;\n            let current = 0;\n            for (let j = 0; j < groupCount; j++) {\n                if (!base.types) {\n                    throw new Error('SeqBase not loaded!!!');\n                }\n                const flags = tran1.g1;\n                if (flags > 0) {\n                    if (base.types[j] !== 0) {\n                        for (let group = j - 1; group > lastGroup; group--) {\n                            if (base.types[group] === 0) {\n                                labels[current] = group;\n                                x[current] = 0;\n                                y[current] = 0;\n                                z[current] = 0;\n                                current++;\n                                break;\n                            }\n                        }\n                    }\n                    labels[current] = j;\n                    let defaultValue = 0;\n                    if (base.types[labels[current]] === 3) {\n                        defaultValue = 128;\n                    }\n                    if ((flags & 0x1) === 0) {\n                        x[current] = defaultValue;\n                    }\n                    else {\n                        x[current] = tran2.gsmart;\n                    }\n                    if ((flags & 0x2) === 0) {\n                        y[current] = defaultValue;\n                    }\n                    else {\n                        y[current] = tran2.gsmart;\n                    }\n                    if ((flags & 0x4) === 0) {\n                        z[current] = defaultValue;\n                    }\n                    else {\n                        z[current] = tran2.gsmart;\n                    }\n                    lastGroup = j;\n                    current++;\n                }\n            }\n            frame.length = current;\n            frame.bases = new Int32Array(current);\n            frame.x = new Int32Array(current);\n            frame.y = new Int32Array(current);\n            frame.z = new Int32Array(current);\n            for (let j = 0; j < current; j++) {\n                frame.bases[j] = labels[j];\n                frame.x[j] = x[j];\n                frame.y[j] = y[j];\n                frame.z[j] = z[j];\n            }\n        }\n    };\n    // ----\n    delay = 0;\n    base = null;\n    length = 0;\n    bases = null;\n    x = null;\n    y = null;\n    z = null;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/AnimFrame.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Canvas.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/graphics/Canvas.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canvas: () => (/* binding */ canvas),\n/* harmony export */   canvas2d: () => (/* binding */ canvas2d),\n/* harmony export */   jpeg2d: () => (/* binding */ jpeg2d),\n/* harmony export */   jpegCanvas: () => (/* binding */ jpegCanvas),\n/* harmony export */   jpegImg: () => (/* binding */ jpegImg)\n/* harmony export */ });\nconst canvas = document.getElementById('canvas');\nconst canvas2d = canvas.getContext('2d', { willReadFrequently: true });\nconst jpegCanvas = document.createElement('canvas');\nconst jpegImg = document.createElement('img');\nconst jpeg2d = jpegCanvas.getContext('2d', { willReadFrequently: true });\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Canvas.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Colors.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/graphics/Colors.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Colors)\n/* harmony export */ });\nclass Colors {\n    // ---- these are in rgb 24 bits\n    static RED = 0xff0000; // 16711680\n    static GREEN = 0xff00; // 65280\n    static BLUE = 0xff; // 255\n    static YELLOW = 0xffff00; // 16776960\n    static CYAN = 0xffff; // 65535\n    static MAGENTA = 0xff00ff; // 16711935\n    static WHITE = 0xffffff; // 16777215\n    static BLACK = 0x0; // 0\n    static LIGHTRED = 0xff9040; // 16748608\n    static DARKRED = 0x800000; // 8388608\n    static DARKBLUE = 0x80; // 128\n    static ORANGE1 = 0xffb000; // 16756736\n    static ORANGE2 = 0xff7000; // 16740352\n    static ORANGE3 = 0xff3000; // 16723968\n    static GREEN1 = 0xc0ff00; // 12648192\n    static GREEN2 = 0x80ff00; // 8453888\n    static GREEN3 = 0x40ff00; // 4259584\n    // other\n    static PROGRESS_RED = 0x8c1111; // 9179409\n    static OPTIONS_MENU = 0x5d5447; // 6116423\n    static SCROLLBAR_TRACK = 0x23201b; // 2301979\n    static SCROLLBAR_GRIP_FOREGROUND = 0x4d4233; // 5063219\n    static SCROLLBAR_GRIP_HIGHLIGHT = 0x766654; // 7759444\n    static SCROLLBAR_GRIP_LOWLIGHT = 0x332d25; // 3353893\n    static TRADE_MESSAGE = 0x800080; // 8388736\n    static DUEL_MESSAGE = 0xcbb789; // 13350793\n    static CHAT_COLORS = Int32Array.of(Colors.YELLOW, Colors.RED, Colors.GREEN, Colors.CYAN, Colors.MAGENTA, Colors.WHITE);\n    // ---- these are in hsl 16 bits\n    // hair\n    static HAIR_DARK_BROWN = 6798;\n    static HAIR_WHITE = 107;\n    static HAIR_LIGHT_GREY = 10283;\n    static HAIR_DARK_GREY = 16;\n    static HAIR_APRICOT = 4797;\n    static HAIR_STRAW = 7744;\n    static HAIR_LIGHT_BROWN = 5799;\n    static HAIR_BROWN = 4634;\n    static HAIR_TURQUOISE = 33697;\n    static HAIR_GREEN = 22433;\n    static HAIR_GINGER = 2983;\n    static HAIR_MAGENTA = 54193;\n    // body\n    static BODY_KHAKI = 8741;\n    static BODY_CHARCOAL = 12;\n    static BODY_CRIMSON = 64030;\n    static BODY_NAVY = 43162;\n    static BODY_STRAW = 7735;\n    static BODY_WHITE = 8404;\n    static BODY_RED = 1701;\n    static BODY_BLUE = 38430;\n    static BODY_GREEN = 24094;\n    static BODY_YELLOW = 10153;\n    static BODY_PURPLE = 56621;\n    static BODY_ORANGE = 4783;\n    static BODY_ROSE = 1341;\n    static BODY_LIME = 16578;\n    static BODY_CYAN = 35003;\n    static BODY_EMERALD = 25239;\n    static BODY_RECOLOR_KHAKI = 9104;\n    static BODY_RECOLOR_CHARCOAL = 10275;\n    static BODY_RECOLOR_CRIMSON = 7595;\n    static BODY_RECOLOR_NAVY = 3610;\n    static BODY_RECOLOR_STRAW = 7975;\n    static BODY_RECOLOR_WHITE = 8526;\n    static BODY_RECOLOR_RED = 918;\n    static BODY_RECOLOR_BLUE = 38802;\n    static BODY_RECOLOR_GREEN = 24466;\n    static BODY_RECOLOR_YELLOW = 10145;\n    static BODY_RECOLOR_PURPLE = 58654;\n    static BODY_RECOLOR_ORANGE = 5027;\n    static BODY_RECOLOR_ROSE = 1457;\n    static BODY_RECOLOR_LIME = 16565;\n    static BODY_RECOLOR_CYAN = 34991;\n    static BODY_RECOLOR_EMERALD = 25486;\n    // feet\n    static FEET_BROWN = 4626;\n    static FEET_KHAKI = 11146;\n    static FEET_ASHEN = 6439;\n    static FEET_DARK = 12;\n    static FEET_TERRACOTTA = 4758;\n    static FEET_GREY = 10270;\n    // skin\n    static SKIN = 4574;\n    static SKIN_DARKER = 4550;\n    static SKIN_DARKER_DARKER = 4537;\n    static SKIN_DARKER_DARKER_DARKER = 5681;\n    static SKIN_DARKER_DARKER_DARKER_DARKER = 5673;\n    static SKIN_DARKER_DARKER_DARKER_DARKER_DARKER = 5790;\n    static SKIN_DARKER_DARKER_DARKER_DARKER_DARKER_DARKER = 6806;\n    static SKIN_DARKER_DARKER_DARKER_DARKER_DARKER_DARKER_DARKER = 8076;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Colors.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Draw2D.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/graphics/Draw2D.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Draw2D)\n/* harmony export */ });\n/* harmony import */ var _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datastruct/Hashable */ \"./src/js/jagex2/datastruct/Hashable.ts\");\n\nclass Draw2D extends _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static pixels = new Int32Array();\n    static width2d = 0;\n    static height2d = 0;\n    static top = 0;\n    static bottom = 0;\n    static left = 0;\n    static right = 0;\n    static boundX = 0;\n    static centerX2d = 0;\n    static centerY2d = 0;\n    static bind = (pixels, width, height) => {\n        this.pixels = pixels;\n        this.width2d = width;\n        this.height2d = height;\n        this.setBounds(0, 0, width, height);\n    };\n    static resetBounds = () => {\n        this.left = 0;\n        this.top = 0;\n        this.right = this.width2d;\n        this.bottom = this.height2d;\n        this.boundX = this.right - 1;\n        this.centerX2d = (this.right / 2) | 0;\n    };\n    static setBounds = (left, top, right, bottom) => {\n        if (left < 0) {\n            left = 0;\n        }\n        if (top < 0) {\n            top = 0;\n        }\n        if (right > this.width2d) {\n            right = this.width2d;\n        }\n        if (bottom > this.height2d) {\n            bottom = this.height2d;\n        }\n        this.top = top;\n        this.bottom = bottom;\n        this.left = left;\n        this.right = right;\n        this.boundX = this.right - 1;\n        this.centerX2d = (this.right / 2) | 0;\n        this.centerY2d = (this.bottom / 2) | 0;\n    };\n    static clear = () => {\n        const len = this.width2d * this.height2d;\n        for (let i = 0; i < len; i++) {\n            this.pixels[i] = 0;\n        }\n    };\n    // draw a 1px border rectangle\n    static drawRect = (x, y, w, h, color) => {\n        this.drawHorizontalLine(x, y, color, w);\n        this.drawHorizontalLine(x, y + h - 1, color, w);\n        this.drawVerticalLine(x, y, color, h);\n        this.drawVerticalLine(x + w - 1, y, color, h);\n    };\n    static drawHorizontalLine = (x, y, color, width) => {\n        if (y < this.top || y >= this.bottom) {\n            return;\n        }\n        if (x < this.left) {\n            width -= this.left - x;\n            x = this.left;\n        }\n        if (x + width > this.right) {\n            width = this.right - x;\n        }\n        const off = x + y * this.width2d;\n        for (let i = 0; i < width; i++) {\n            this.pixels[off + i] = color;\n        }\n    };\n    static drawVerticalLine = (x, y, color, width) => {\n        if (x < this.left || x >= this.right) {\n            return;\n        }\n        if (y < this.top) {\n            width -= this.top - y;\n            y = this.top;\n        }\n        if (y + width > this.bottom) {\n            width = this.bottom - y;\n        }\n        const off = x + y * this.width2d;\n        for (let i = 0; i < width; i++) {\n            this.pixels[off + i * this.width2d] = color;\n        }\n    };\n    static drawLine = (x1, y1, x2, y2, color) => {\n        const dx = Math.abs(x2 - x1);\n        const dy = Math.abs(y2 - y1);\n        const sx = x1 < x2 ? 1 : -1;\n        const sy = y1 < y2 ? 1 : -1;\n        let err = dx - dy;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (x1 >= this.left && x1 < this.right && y1 >= this.top && y1 < this.bottom) {\n                this.pixels[x1 + y1 * this.width2d] = color;\n            }\n            if (x1 === x2 && y1 === y2) {\n                break;\n            }\n            const e2 = 2 * err;\n            if (e2 > -dy) {\n                err = err - dy;\n                x1 = x1 + sx;\n            }\n            if (e2 < dx) {\n                err = err + dx;\n                y1 = y1 + sy;\n            }\n        }\n    };\n    // fill in a rectangle area\n    static fillRect = (x, y, width, height, color) => {\n        if (x < this.left) {\n            width -= this.left - x;\n            x = this.left;\n        }\n        if (y < this.top) {\n            height -= this.top - y;\n            y = this.top;\n        }\n        if (x + width > this.right) {\n            width = this.right - x;\n        }\n        if (y + height > this.bottom) {\n            height = this.bottom - y;\n        }\n        const step = this.width2d - width;\n        let offset = x + y * this.width2d;\n        for (let i = -height; i < 0; i++) {\n            for (let j = -width; j < 0; j++) {\n                this.pixels[offset++] = color;\n            }\n            offset += step;\n        }\n    };\n    static fillRectAlpha(x, y, width, height, rgb, alpha) {\n        if (x < this.left) {\n            width -= this.left - x;\n            x = this.left;\n        }\n        if (y < this.top) {\n            height -= this.top - y;\n            y = this.top;\n        }\n        if (x + width > this.right) {\n            width = this.right - x;\n        }\n        if (y + height > this.bottom) {\n            height = this.bottom - y;\n        }\n        const invAlpha = 256 - alpha;\n        const r0 = ((rgb >> 16) & 0xff) * alpha;\n        const g0 = ((rgb >> 8) & 0xff) * alpha;\n        const b0 = (rgb & 0xff) * alpha;\n        const step = this.width2d - width;\n        let offset = x + y * this.width2d;\n        for (let i = 0; i < height; i++) {\n            for (let j = -width; j < 0; j++) {\n                const r1 = ((this.pixels[offset] >> 16) & 0xff) * invAlpha;\n                const g1 = ((this.pixels[offset] >> 8) & 0xff) * invAlpha;\n                const b1 = (this.pixels[offset] & 0xff) * invAlpha;\n                const color = (((r0 + r1) >> 8) << 16) + (((g0 + g1) >> 8) << 8) + ((b0 + b1) >> 8);\n                this.pixels[offset++] = color;\n            }\n            offset += step;\n        }\n    }\n    static fillCircle(xCenter, yCenter, yRadius, rgb, alpha) {\n        const invAlpha = 256 - alpha;\n        const r0 = ((rgb >> 16) & 0xff) * alpha;\n        const g0 = ((rgb >> 8) & 0xff) * alpha;\n        const b0 = (rgb & 0xff) * alpha;\n        let yStart = yCenter - yRadius;\n        if (yStart < 0) {\n            yStart = 0;\n        }\n        let yEnd = yCenter + yRadius;\n        if (yEnd >= this.height2d) {\n            yEnd = this.height2d - 1;\n        }\n        for (let y = yStart; y <= yEnd; y++) {\n            const midpoint = y - yCenter;\n            const xRadius = Math.sqrt(yRadius * yRadius - midpoint * midpoint) | 0;\n            let xStart = xCenter - xRadius;\n            if (xStart < 0) {\n                xStart = 0;\n            }\n            let xEnd = xCenter + xRadius;\n            if (xEnd >= this.width2d) {\n                xEnd = this.width2d - 1;\n            }\n            let offset = xStart + y * this.width2d;\n            for (let x = xStart; x <= xEnd; x++) {\n                const r1 = ((this.pixels[offset] >> 16) & 0xff) * invAlpha;\n                const g1 = ((this.pixels[offset] >> 8) & 0xff) * invAlpha;\n                const b1 = (this.pixels[offset] & 0xff) * invAlpha;\n                const color = (((r0 + r1) >> 8) << 16) + (((g0 + g1) >> 8) << 8) + ((b0 + b1) >> 8);\n                this.pixels[offset++] = color;\n            }\n        }\n    }\n    static setPixel = (x, y, color) => {\n        if (x < this.left || x >= this.right || y < this.top || y >= this.bottom) {\n            return;\n        }\n        this.pixels[x + y * this.width2d] = color;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Draw2D.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Draw3D.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/graphics/Draw3D.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Draw3D)\n/* harmony export */ });\n/* harmony import */ var _Draw2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _Pix8__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pix8 */ \"./src/js/jagex2/graphics/Pix8.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n// noinspection JSSuspiciousNameCombination,DuplicatedCode\nclass Draw3D extends _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static lowMemory = false;\n    static reciprocal15 = new Int32Array(512);\n    static reciprocal16 = new Int32Array(2048);\n    static sin = new Int32Array(2048);\n    static cos = new Int32Array(2048);\n    static palette = new Int32Array(65536);\n    static textures = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.TypedArray1d(50, null);\n    static textureCount = 0;\n    static lineOffset = new Int32Array();\n    static centerX = 0;\n    static centerY = 0;\n    static jagged = true;\n    static clipX = false;\n    static alpha = 0;\n    static texelPool = null;\n    static activeTexels = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.TypedArray1d(50, null);\n    static poolSize = 0;\n    static cycle = 0;\n    static textureCycle = new Int32Array(50);\n    static texturePalette = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.TypedArray1d(50, null);\n    static opaque = false;\n    static textureTranslucent = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.TypedArray1d(50, false);\n    static averageTextureRGB = new Int32Array(50);\n    static {\n        for (let i = 1; i < 512; i++) {\n            this.reciprocal15[i] = (32768 / i) | 0;\n        }\n        for (let i = 1; i < 2048; i++) {\n            this.reciprocal16[i] = (65536 / i) | 0;\n        }\n        for (let i = 0; i < 2048; i++) {\n            // angular frequency: 2 * pi / 2048 = 0.0030679615757712823\n            // * 65536 = maximum amplitude\n            this.sin[i] = (Math.sin(i * 0.0030679615757712823) * 65536.0) | 0;\n            this.cos[i] = (Math.cos(i * 0.0030679615757712823) * 65536.0) | 0;\n        }\n    }\n    static unload = () => {\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.reciprocal15 = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.reciprocal15 = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.sin = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.cos = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.lineOffset = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.textures = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.textureTranslucent = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.averageTextureRGB = null;\n        this.texelPool = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.activeTexels = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.textureCycle = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.palette = null;\n        // @ts-expect-error Force unload. This happens when the browser reloads entirely.\n        this.texturePalette = null;\n        console.log('Draw3D unloaded!');\n    };\n    static init2D = () => {\n        this.lineOffset = new Int32Array(this.height2d);\n        for (let y = 0; y < this.height2d; y++) {\n            this.lineOffset[y] = this.width2d * y;\n        }\n        this.centerX = (this.width2d / 2) | 0;\n        this.centerY = (this.height2d / 2) | 0;\n    };\n    static init3D = (width, height) => {\n        this.lineOffset = new Int32Array(height);\n        for (let y = 0; y < height; y++) {\n            this.lineOffset[y] = width * y;\n        }\n        this.centerX = (width / 2) | 0;\n        this.centerY = (height / 2) | 0;\n    };\n    static clearTexels = () => {\n        this.texelPool = null;\n        this.activeTexels.fill(null);\n    };\n    static unpackTextures = (textures) => {\n        this.textureCount = 0;\n        for (let i = 0; i < 50; i++) {\n            try {\n                this.textures[i] = _Pix8__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromArchive(textures, i.toString());\n                if (this.lowMemory && this.textures[i]?.cropW === 128) {\n                    this.textures[i]?.shrink();\n                }\n                else {\n                    this.textures[i]?.crop();\n                }\n                this.textureCount++;\n            }\n            catch (err) {\n                /* empty */\n            }\n        }\n    };\n    static getAverageTextureRGB = (id) => {\n        if (this.averageTextureRGB[id] !== 0) {\n            return this.averageTextureRGB[id];\n        }\n        const palette = this.texturePalette[id];\n        if (!palette) {\n            return 0;\n        }\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        const length = palette.length;\n        for (let i = 0; i < length; i++) {\n            r += (palette[i] >> 16) & 0xff;\n            g += (palette[i] >> 8) & 0xff;\n            b += palette[i] & 0xff;\n        }\n        let rgb = (((r / length) | 0) << 16) + (((g / length) | 0) << 8) + ((b / length) | 0);\n        rgb = this.setGamma(rgb, 1.4);\n        if (rgb === 0) {\n            rgb = 1;\n        }\n        this.averageTextureRGB[id] = rgb;\n        return rgb;\n    };\n    static setBrightness = (brightness) => {\n        const randomBrightness = brightness + Math.random() * 0.03 - 0.015;\n        let offset = 0;\n        for (let y = 0; y < 512; y++) {\n            const hue = ((y / 8) | 0) / 64.0 + 0.0078125;\n            const saturation = (y & 0x7) / 8.0 + 0.0625;\n            for (let x = 0; x < 128; x++) {\n                const lightness = x / 128.0;\n                let r = lightness;\n                let g = lightness;\n                let b = lightness;\n                if (saturation !== 0.0) {\n                    let q;\n                    if (lightness < 0.5) {\n                        q = lightness * (saturation + 1.0);\n                    }\n                    else {\n                        q = lightness + saturation - lightness * saturation;\n                    }\n                    const p = lightness * 2.0 - q;\n                    let t = hue + 0.3333333333333333;\n                    if (t > 1.0) {\n                        t--;\n                    }\n                    let d11 = hue - 0.3333333333333333;\n                    if (d11 < 0.0) {\n                        d11++;\n                    }\n                    if (t * 6.0 < 1.0) {\n                        r = p + (q - p) * 6.0 * t;\n                    }\n                    else if (t * 2.0 < 1.0) {\n                        r = q;\n                    }\n                    else if (t * 3.0 < 2.0) {\n                        r = p + (q - p) * (0.6666666666666666 - t) * 6.0;\n                    }\n                    else {\n                        r = p;\n                    }\n                    if (hue * 6.0 < 1.0) {\n                        g = p + (q - p) * 6.0 * hue;\n                    }\n                    else if (hue * 2.0 < 1.0) {\n                        g = q;\n                    }\n                    else if (hue * 3.0 < 2.0) {\n                        g = p + (q - p) * (0.6666666666666666 - hue) * 6.0;\n                    }\n                    else {\n                        g = p;\n                    }\n                    if (d11 * 6.0 < 1.0) {\n                        b = p + (q - p) * 6.0 * d11;\n                    }\n                    else if (d11 * 2.0 < 1.0) {\n                        b = q;\n                    }\n                    else if (d11 * 3.0 < 2.0) {\n                        b = p + (q - p) * (0.6666666666666666 - d11) * 6.0;\n                    }\n                    else {\n                        b = p;\n                    }\n                }\n                const intR = (r * 256.0) | 0;\n                const intG = (g * 256.0) | 0;\n                const intB = (b * 256.0) | 0;\n                const rgb = (intR << 16) + (intG << 8) + intB;\n                this.palette[offset++] = this.setGamma(rgb, randomBrightness);\n            }\n        }\n        for (let id = 0; id < 50; id++) {\n            const texture = this.textures[id];\n            if (!texture) {\n                continue;\n            }\n            const palette = texture.palette;\n            this.texturePalette[id] = new Int32Array(palette.length);\n            for (let i = 0; i < palette.length; i++) {\n                const texturePalette = this.texturePalette[id];\n                if (!texturePalette) {\n                    continue;\n                }\n                texturePalette[i] = this.setGamma(palette[i], randomBrightness);\n            }\n        }\n        for (let id = 0; id < 50; id++) {\n            this.pushTexture(id);\n        }\n    };\n    static setGamma = (rgb, gamma) => {\n        const r = (rgb >> 16) / 256.0;\n        const g = ((rgb >> 8) & 0xff) / 256.0;\n        const b = (rgb & 0xff) / 256.0;\n        const powR = Math.pow(r, gamma);\n        const powG = Math.pow(g, gamma);\n        const powB = Math.pow(b, gamma);\n        const intR = (powR * 256.0) | 0;\n        const intG = (powG * 256.0) | 0;\n        const intB = (powB * 256.0) | 0;\n        return (intR << 16) + (intG << 8) + intB;\n    };\n    static initPool = (size) => {\n        if (this.texelPool) {\n            return;\n        }\n        this.poolSize = size;\n        if (this.lowMemory) {\n            this.texelPool = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.Int32Array2d(size, 16384);\n        }\n        else {\n            this.texelPool = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.Int32Array2d(size, 65536);\n        }\n        this.activeTexels.fill(null);\n    };\n    static fillGouraudTriangle = (xA, xB, xC, yA, yB, yC, colorA, colorB, colorC) => {\n        let xStepAB = 0;\n        let colorStepAB = 0;\n        if (yB !== yA) {\n            xStepAB = (((xB - xA) << 16) / (yB - yA)) | 0;\n            colorStepAB = (((colorB - colorA) << 15) / (yB - yA)) | 0;\n        }\n        let xStepBC = 0;\n        let colorStepBC = 0;\n        if (yC !== yB) {\n            xStepBC = (((xC - xB) << 16) / (yC - yB)) | 0;\n            colorStepBC = (((colorC - colorB) << 15) / (yC - yB)) | 0;\n        }\n        let xStepAC = 0;\n        let colorStepAC = 0;\n        if (yC !== yA) {\n            xStepAC = (((xA - xC) << 16) / (yA - yC)) | 0;\n            colorStepAC = (((colorA - colorC) << 15) / (yA - yC)) | 0;\n        }\n        if (yA <= yB && yA <= yC) {\n            if (yA < this.bottom) {\n                if (yB > this.bottom) {\n                    yB = this.bottom;\n                }\n                if (yC > this.bottom) {\n                    yC = this.bottom;\n                }\n                if (yB < yC) {\n                    xC = xA <<= 0x10;\n                    colorC = colorA <<= 0xf;\n                    if (yA < 0) {\n                        xC -= xStepAC * yA;\n                        xA -= xStepAB * yA;\n                        colorC -= colorStepAC * yA;\n                        colorA -= colorStepAB * yA;\n                        yA = 0;\n                    }\n                    xB <<= 0x10;\n                    colorB <<= 0xf;\n                    if (yB < 0) {\n                        xB -= xStepBC * yB;\n                        colorB -= colorStepBC * yB;\n                        yB = 0;\n                    }\n                    if ((yA !== yB && xStepAC < xStepAB) || (yA === yB && xStepAC > xStepBC)) {\n                        yC -= yB;\n                        yB -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yB--;\n                            if (yB < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xC >> 16, xB >> 16, colorC >> 7, colorB >> 7, this.pixels, yA, 0);\n                                    xC += xStepAC;\n                                    xB += xStepBC;\n                                    colorC += colorStepAC;\n                                    colorB += colorStepBC;\n                                    yA += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xC >> 16, xA >> 16, colorC >> 7, colorA >> 7, this.pixels, yA, 0);\n                            xC += xStepAC;\n                            xA += xStepAB;\n                            colorC += colorStepAC;\n                            colorA += colorStepAB;\n                            yA += this.width2d;\n                        }\n                    }\n                    else {\n                        yC -= yB;\n                        yB -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yB--;\n                            if (yB < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xB >> 16, xC >> 16, colorB >> 7, colorC >> 7, this.pixels, yA, 0);\n                                    xC += xStepAC;\n                                    xB += xStepBC;\n                                    colorC += colorStepAC;\n                                    colorB += colorStepBC;\n                                    yA += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xA >> 16, xC >> 16, colorA >> 7, colorC >> 7, this.pixels, yA, 0);\n                            xC += xStepAC;\n                            xA += xStepAB;\n                            colorC += colorStepAC;\n                            colorA += colorStepAB;\n                            yA += this.width2d;\n                        }\n                    }\n                }\n                else {\n                    xB = xA <<= 0x10;\n                    colorB = colorA <<= 0xf;\n                    if (yA < 0) {\n                        xB -= xStepAC * yA;\n                        xA -= xStepAB * yA;\n                        colorB -= colorStepAC * yA;\n                        colorA -= colorStepAB * yA;\n                        yA = 0;\n                    }\n                    xC <<= 0x10;\n                    colorC <<= 0xf;\n                    if (yC < 0) {\n                        xC -= xStepBC * yC;\n                        colorC -= colorStepBC * yC;\n                        yC = 0;\n                    }\n                    if ((yA !== yC && xStepAC < xStepAB) || (yA === yC && xStepBC > xStepAB)) {\n                        yB -= yC;\n                        yC -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yB--;\n                                    if (yB < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xC >> 16, xA >> 16, colorC >> 7, colorA >> 7, this.pixels, yA, 0);\n                                    xC += xStepBC;\n                                    xA += xStepAB;\n                                    colorC += colorStepBC;\n                                    colorA += colorStepAB;\n                                    yA += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xB >> 16, xA >> 16, colorB >> 7, colorA >> 7, this.pixels, yA, 0);\n                            xB += xStepAC;\n                            xA += xStepAB;\n                            colorB += colorStepAC;\n                            colorA += colorStepAB;\n                            yA += this.width2d;\n                        }\n                    }\n                    else {\n                        yB -= yC;\n                        yC -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yB--;\n                                    if (yB < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xA >> 16, xC >> 16, colorA >> 7, colorC >> 7, this.pixels, yA, 0);\n                                    xC += xStepBC;\n                                    xA += xStepAB;\n                                    colorC += colorStepBC;\n                                    colorA += colorStepAB;\n                                    yA += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xA >> 16, xB >> 16, colorA >> 7, colorB >> 7, this.pixels, yA, 0);\n                            xB += xStepAC;\n                            xA += xStepAB;\n                            colorB += colorStepAC;\n                            colorA += colorStepAB;\n                            yA += this.width2d;\n                        }\n                    }\n                }\n            }\n        }\n        else if (yB <= yC) {\n            if (yB < this.bottom) {\n                if (yC > this.bottom) {\n                    yC = this.bottom;\n                }\n                if (yA > this.bottom) {\n                    yA = this.bottom;\n                }\n                if (yC < yA) {\n                    xA = xB <<= 0x10;\n                    colorA = colorB <<= 0xf;\n                    if (yB < 0) {\n                        xA -= xStepAB * yB;\n                        xB -= xStepBC * yB;\n                        colorA -= colorStepAB * yB;\n                        colorB -= colorStepBC * yB;\n                        yB = 0;\n                    }\n                    xC <<= 0x10;\n                    colorC <<= 0xf;\n                    if (yC < 0) {\n                        xC -= xStepAC * yC;\n                        colorC -= colorStepAC * yC;\n                        yC = 0;\n                    }\n                    if ((yB !== yC && xStepAB < xStepBC) || (yB === yC && xStepAB > xStepAC)) {\n                        yA -= yC;\n                        yC -= yB;\n                        yB = this.lineOffset[yB];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yA--;\n                                    if (yA < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xA >> 16, xC >> 16, colorA >> 7, colorC >> 7, this.pixels, yB, 0);\n                                    xA += xStepAB;\n                                    xC += xStepAC;\n                                    colorA += colorStepAB;\n                                    colorC += colorStepAC;\n                                    yB += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xA >> 16, xB >> 16, colorA >> 7, colorB >> 7, this.pixels, yB, 0);\n                            xA += xStepAB;\n                            xB += xStepBC;\n                            colorA += colorStepAB;\n                            colorB += colorStepBC;\n                            yB += this.width2d;\n                        }\n                    }\n                    else {\n                        yA -= yC;\n                        yC -= yB;\n                        yB = this.lineOffset[yB];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yA--;\n                                    if (yA < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xC >> 16, xA >> 16, colorC >> 7, colorA >> 7, this.pixels, yB, 0);\n                                    xA += xStepAB;\n                                    xC += xStepAC;\n                                    colorA += colorStepAB;\n                                    colorC += colorStepAC;\n                                    yB += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xB >> 16, xA >> 16, colorB >> 7, colorA >> 7, this.pixels, yB, 0);\n                            xA += xStepAB;\n                            xB += xStepBC;\n                            colorA += colorStepAB;\n                            colorB += colorStepBC;\n                            yB += this.width2d;\n                        }\n                    }\n                }\n                else {\n                    xC = xB <<= 0x10;\n                    colorC = colorB <<= 0xf;\n                    if (yB < 0) {\n                        xC -= xStepAB * yB;\n                        xB -= xStepBC * yB;\n                        colorC -= colorStepAB * yB;\n                        colorB -= colorStepBC * yB;\n                        yB = 0;\n                    }\n                    xA <<= 0x10;\n                    colorA <<= 0xf;\n                    if (yA < 0) {\n                        xA -= xStepAC * yA;\n                        colorA -= colorStepAC * yA;\n                        yA = 0;\n                    }\n                    yC -= yA;\n                    yA -= yB;\n                    yB = this.lineOffset[yB];\n                    if (xStepAB < xStepBC) {\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yA--;\n                            if (yA < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xA >> 16, xB >> 16, colorA >> 7, colorB >> 7, this.pixels, yB, 0);\n                                    xA += xStepAC;\n                                    xB += xStepBC;\n                                    colorA += colorStepAC;\n                                    colorB += colorStepBC;\n                                    yB += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xC >> 16, xB >> 16, colorC >> 7, colorB >> 7, this.pixels, yB, 0);\n                            xC += xStepAB;\n                            xB += xStepBC;\n                            colorC += colorStepAB;\n                            colorB += colorStepBC;\n                            yB += this.width2d;\n                        }\n                    }\n                    else {\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yA--;\n                            if (yA < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawGouraudScanline(xB >> 16, xA >> 16, colorB >> 7, colorA >> 7, this.pixels, yB, 0);\n                                    xA += xStepAC;\n                                    xB += xStepBC;\n                                    colorA += colorStepAC;\n                                    colorB += colorStepBC;\n                                    yB += this.width2d;\n                                }\n                            }\n                            this.drawGouraudScanline(xB >> 16, xC >> 16, colorB >> 7, colorC >> 7, this.pixels, yB, 0);\n                            xC += xStepAB;\n                            xB += xStepBC;\n                            colorC += colorStepAB;\n                            colorB += colorStepBC;\n                            yB += this.width2d;\n                        }\n                    }\n                }\n            }\n        }\n        else if (yC < this.bottom) {\n            if (yA > this.bottom) {\n                yA = this.bottom;\n            }\n            if (yB > this.bottom) {\n                yB = this.bottom;\n            }\n            if (yA < yB) {\n                xB = xC <<= 0x10;\n                colorB = colorC <<= 0xf;\n                if (yC < 0) {\n                    xB -= xStepBC * yC;\n                    xC -= xStepAC * yC;\n                    colorB -= colorStepBC * yC;\n                    colorC -= colorStepAC * yC;\n                    yC = 0;\n                }\n                xA <<= 0x10;\n                colorA <<= 0xf;\n                if (yA < 0) {\n                    xA -= xStepAB * yA;\n                    colorA -= colorStepAB * yA;\n                    yA = 0;\n                }\n                yB -= yA;\n                yA -= yC;\n                yC = this.lineOffset[yC];\n                if (xStepBC < xStepAC) {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yA--;\n                        if (yA < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yB--;\n                                if (yB < 0) {\n                                    return;\n                                }\n                                this.drawGouraudScanline(xB >> 16, xA >> 16, colorB >> 7, colorA >> 7, this.pixels, yC, 0);\n                                xB += xStepBC;\n                                xA += xStepAB;\n                                colorB += colorStepBC;\n                                colorA += colorStepAB;\n                                yC += this.width2d;\n                            }\n                        }\n                        this.drawGouraudScanline(xB >> 16, xC >> 16, colorB >> 7, colorC >> 7, this.pixels, yC, 0);\n                        xB += xStepBC;\n                        xC += xStepAC;\n                        colorB += colorStepBC;\n                        colorC += colorStepAC;\n                        yC += this.width2d;\n                    }\n                }\n                else {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yA--;\n                        if (yA < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yB--;\n                                if (yB < 0) {\n                                    return;\n                                }\n                                this.drawGouraudScanline(xA >> 16, xB >> 16, colorA >> 7, colorB >> 7, this.pixels, yC, 0);\n                                xB += xStepBC;\n                                xA += xStepAB;\n                                colorB += colorStepBC;\n                                colorA += colorStepAB;\n                                yC += this.width2d;\n                            }\n                        }\n                        this.drawGouraudScanline(xC >> 16, xB >> 16, colorC >> 7, colorB >> 7, this.pixels, yC, 0);\n                        xB += xStepBC;\n                        xC += xStepAC;\n                        colorB += colorStepBC;\n                        colorC += colorStepAC;\n                        yC += this.width2d;\n                    }\n                }\n            }\n            else {\n                xA = xC <<= 0x10;\n                colorA = colorC <<= 0xf;\n                if (yC < 0) {\n                    xA -= xStepBC * yC;\n                    xC -= xStepAC * yC;\n                    colorA -= colorStepBC * yC;\n                    colorC -= colorStepAC * yC;\n                    yC = 0;\n                }\n                xB <<= 0x10;\n                colorB <<= 0xf;\n                if (yB < 0) {\n                    xB -= xStepAB * yB;\n                    colorB -= colorStepAB * yB;\n                    yB = 0;\n                }\n                yA -= yB;\n                yB -= yC;\n                yC = this.lineOffset[yC];\n                if (xStepBC < xStepAC) {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yB--;\n                        if (yB < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yA--;\n                                if (yA < 0) {\n                                    return;\n                                }\n                                this.drawGouraudScanline(xB >> 16, xC >> 16, colorB >> 7, colorC >> 7, this.pixels, yC, 0);\n                                xB += xStepAB;\n                                xC += xStepAC;\n                                colorB += colorStepAB;\n                                colorC += colorStepAC;\n                                yC += this.width2d;\n                            }\n                        }\n                        this.drawGouraudScanline(xA >> 16, xC >> 16, colorA >> 7, colorC >> 7, this.pixels, yC, 0);\n                        xA += xStepBC;\n                        xC += xStepAC;\n                        colorA += colorStepBC;\n                        colorC += colorStepAC;\n                        yC += this.width2d;\n                    }\n                }\n                else {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yB--;\n                        if (yB < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yA--;\n                                if (yA < 0) {\n                                    return;\n                                }\n                                this.drawGouraudScanline(xC >> 16, xB >> 16, colorC >> 7, colorB >> 7, this.pixels, yC, 0);\n                                xB += xStepAB;\n                                xC += xStepAC;\n                                colorB += colorStepAB;\n                                colorC += colorStepAC;\n                                yC += this.width2d;\n                            }\n                        }\n                        this.drawGouraudScanline(xC >> 16, xA >> 16, colorC >> 7, colorA >> 7, this.pixels, yC, 0);\n                        xA += xStepBC;\n                        xC += xStepAC;\n                        colorA += colorStepBC;\n                        colorC += colorStepAC;\n                        yC += this.width2d;\n                    }\n                }\n            }\n        }\n    };\n    static drawGouraudScanline = (x0, x1, color0, color1, dst, offset, length) => {\n        let rgb;\n        if (this.jagged) {\n            let colorStep;\n            if (this.clipX) {\n                if (x1 - x0 > 3) {\n                    colorStep = ((color1 - color0) / (x1 - x0)) | 0;\n                }\n                else {\n                    colorStep = 0;\n                }\n                if (x1 > this.boundX) {\n                    x1 = this.boundX;\n                }\n                if (x0 < 0) {\n                    color0 -= x0 * colorStep;\n                    x0 = 0;\n                }\n                if (x0 >= x1) {\n                    return;\n                }\n                offset += x0;\n                length = (x1 - x0) >> 2;\n                colorStep <<= 0x2;\n            }\n            else if (x0 < x1) {\n                offset += x0;\n                length = (x1 - x0) >> 2;\n                if (length > 0) {\n                    colorStep = ((color1 - color0) * this.reciprocal15[length]) >> 15;\n                }\n                else {\n                    colorStep = 0;\n                }\n            }\n            else {\n                return;\n            }\n            if (this.alpha === 0) {\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    length--;\n                    if (length < 0) {\n                        length = (x1 - x0) & 0x3;\n                        if (length > 0) {\n                            rgb = this.palette[color0 >> 8];\n                            do {\n                                dst[offset++] = rgb;\n                                length--;\n                            } while (length > 0);\n                            return;\n                        }\n                        break;\n                    }\n                    rgb = this.palette[color0 >> 8];\n                    color0 += colorStep;\n                    dst[offset++] = rgb;\n                    dst[offset++] = rgb;\n                    dst[offset++] = rgb;\n                    dst[offset++] = rgb;\n                }\n            }\n            else {\n                const alpha = this.alpha;\n                const invAlpha = 256 - this.alpha;\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    length--;\n                    if (length < 0) {\n                        length = (x1 - x0) & 0x3;\n                        if (length > 0) {\n                            rgb = this.palette[color0 >> 8];\n                            rgb = ((((rgb & 0xff00ff) * invAlpha) >> 8) & 0xff00ff) + ((((rgb & 0xff00) * invAlpha) >> 8) & 0xff00);\n                            do {\n                                dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n                                length--;\n                            } while (length > 0);\n                        }\n                        break;\n                    }\n                    rgb = this.palette[color0 >> 8];\n                    color0 += colorStep;\n                    rgb = ((((rgb & 0xff00ff) * invAlpha) >> 8) & 0xff00ff) + ((((rgb & 0xff00) * invAlpha) >> 8) & 0xff00);\n                    dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n                    dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n                    dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n                    dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n                }\n            }\n        }\n        else if (x0 < x1) {\n            const colorStep = ((color1 - color0) / (x1 - x0)) | 0;\n            if (this.clipX) {\n                if (x1 > this.boundX) {\n                    x1 = this.boundX;\n                }\n                if (x0 < 0) {\n                    color0 -= x0 * colorStep;\n                    x0 = 0;\n                }\n                if (x0 >= x1) {\n                    return;\n                }\n            }\n            offset += x0;\n            length = x1 - x0;\n            if (this.alpha === 0) {\n                do {\n                    dst[offset++] = this.palette[color0 >> 8];\n                    color0 += colorStep;\n                    length--;\n                } while (length > 0);\n            }\n            else {\n                const alpha = this.alpha;\n                const invAlpha = 256 - this.alpha;\n                do {\n                    rgb = this.palette[color0 >> 8];\n                    color0 += colorStep;\n                    rgb = ((((rgb & 0xff00ff) * invAlpha) >> 8) & 0xff00ff) + ((((rgb & 0xff00) * invAlpha) >> 8) & 0xff00);\n                    dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n                    length--;\n                } while (length > 0);\n            }\n        }\n    };\n    static fillTriangle = (x0, x1, x2, y0, y1, y2, color) => {\n        let xStepAB = 0;\n        if (y1 !== y0) {\n            xStepAB = (((x1 - x0) << 16) / (y1 - y0)) | 0;\n        }\n        let xStepBC = 0;\n        if (y2 !== y1) {\n            xStepBC = (((x2 - x1) << 16) / (y2 - y1)) | 0;\n        }\n        let xStepAC = 0;\n        if (y2 !== y0) {\n            xStepAC = (((x0 - x2) << 16) / (y0 - y2)) | 0;\n        }\n        if (y0 <= y1 && y0 <= y2) {\n            if (y0 < this.bottom) {\n                if (y1 > this.bottom) {\n                    y1 = this.bottom;\n                }\n                if (y2 > this.bottom) {\n                    y2 = this.bottom;\n                }\n                if (y1 < y2) {\n                    x2 = x0 <<= 0x10;\n                    if (y0 < 0) {\n                        x2 -= xStepAC * y0;\n                        x0 -= xStepAB * y0;\n                        y0 = 0;\n                    }\n                    x1 <<= 0x10;\n                    if (y1 < 0) {\n                        x1 -= xStepBC * y1;\n                        y1 = 0;\n                    }\n                    if ((y0 !== y1 && xStepAC < xStepAB) || (y0 === y1 && xStepAC > xStepBC)) {\n                        y2 -= y1;\n                        y1 -= y0;\n                        y0 = this.lineOffset[y0];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y1--;\n                            if (y1 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y2--;\n                                    if (y2 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x2 >> 16, x1 >> 16, this.pixels, y0, color);\n                                    x2 += xStepAC;\n                                    x1 += xStepBC;\n                                    y0 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x2 >> 16, x0 >> 16, this.pixels, y0, color);\n                            x2 += xStepAC;\n                            x0 += xStepAB;\n                            y0 += this.width2d;\n                        }\n                    }\n                    else {\n                        y2 -= y1;\n                        y1 -= y0;\n                        y0 = this.lineOffset[y0];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y1--;\n                            if (y1 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y2--;\n                                    if (y2 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x1 >> 16, x2 >> 16, this.pixels, y0, color);\n                                    x2 += xStepAC;\n                                    x1 += xStepBC;\n                                    y0 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x0 >> 16, x2 >> 16, this.pixels, y0, color);\n                            x2 += xStepAC;\n                            x0 += xStepAB;\n                            y0 += this.width2d;\n                        }\n                    }\n                }\n                else {\n                    x1 = x0 <<= 0x10;\n                    if (y0 < 0) {\n                        x1 -= xStepAC * y0;\n                        x0 -= xStepAB * y0;\n                        y0 = 0;\n                    }\n                    x2 <<= 0x10;\n                    if (y2 < 0) {\n                        x2 -= xStepBC * y2;\n                        y2 = 0;\n                    }\n                    if ((y0 !== y2 && xStepAC < xStepAB) || (y0 === y2 && xStepBC > xStepAB)) {\n                        y1 -= y2;\n                        y2 -= y0;\n                        y0 = this.lineOffset[y0];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y2--;\n                            if (y2 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y1--;\n                                    if (y1 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x2 >> 16, x0 >> 16, this.pixels, y0, color);\n                                    x2 += xStepBC;\n                                    x0 += xStepAB;\n                                    y0 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x1 >> 16, x0 >> 16, this.pixels, y0, color);\n                            x1 += xStepAC;\n                            x0 += xStepAB;\n                            y0 += this.width2d;\n                        }\n                    }\n                    else {\n                        y1 -= y2;\n                        y2 -= y0;\n                        y0 = this.lineOffset[y0];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y2--;\n                            if (y2 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y1--;\n                                    if (y1 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x0 >> 16, x2 >> 16, this.pixels, y0, color);\n                                    x2 += xStepBC;\n                                    x0 += xStepAB;\n                                    y0 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x0 >> 16, x1 >> 16, this.pixels, y0, color);\n                            x1 += xStepAC;\n                            x0 += xStepAB;\n                            y0 += this.width2d;\n                        }\n                    }\n                }\n            }\n        }\n        else if (y1 <= y2) {\n            if (y1 < this.bottom) {\n                if (y2 > this.bottom) {\n                    y2 = this.bottom;\n                }\n                if (y0 > this.bottom) {\n                    y0 = this.bottom;\n                }\n                if (y2 < y0) {\n                    x0 = x1 <<= 0x10;\n                    if (y1 < 0) {\n                        x0 -= xStepAB * y1;\n                        x1 -= xStepBC * y1;\n                        y1 = 0;\n                    }\n                    x2 <<= 0x10;\n                    if (y2 < 0) {\n                        x2 -= xStepAC * y2;\n                        y2 = 0;\n                    }\n                    if ((y1 !== y2 && xStepAB < xStepBC) || (y1 === y2 && xStepAB > xStepAC)) {\n                        y0 -= y2;\n                        y2 -= y1;\n                        y1 = this.lineOffset[y1];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y2--;\n                            if (y2 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y0--;\n                                    if (y0 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x0 >> 16, x2 >> 16, this.pixels, y1, color);\n                                    x0 += xStepAB;\n                                    x2 += xStepAC;\n                                    y1 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x0 >> 16, x1 >> 16, this.pixels, y1, color);\n                            x0 += xStepAB;\n                            x1 += xStepBC;\n                            y1 += this.width2d;\n                        }\n                    }\n                    else {\n                        y0 -= y2;\n                        y2 -= y1;\n                        y1 = this.lineOffset[y1];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y2--;\n                            if (y2 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y0--;\n                                    if (y0 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x2 >> 16, x0 >> 16, this.pixels, y1, color);\n                                    x0 += xStepAB;\n                                    x2 += xStepAC;\n                                    y1 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x1 >> 16, x0 >> 16, this.pixels, y1, color);\n                            x0 += xStepAB;\n                            x1 += xStepBC;\n                            y1 += this.width2d;\n                        }\n                    }\n                }\n                else {\n                    x2 = x1 <<= 0x10;\n                    if (y1 < 0) {\n                        x2 -= xStepAB * y1;\n                        x1 -= xStepBC * y1;\n                        y1 = 0;\n                    }\n                    x0 <<= 0x10;\n                    if (y0 < 0) {\n                        x0 -= xStepAC * y0;\n                        y0 = 0;\n                    }\n                    if (xStepAB < xStepBC) {\n                        y2 -= y0;\n                        y0 -= y1;\n                        y1 = this.lineOffset[y1];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y0--;\n                            if (y0 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y2--;\n                                    if (y2 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x0 >> 16, x1 >> 16, this.pixels, y1, color);\n                                    x0 += xStepAC;\n                                    x1 += xStepBC;\n                                    y1 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x2 >> 16, x1 >> 16, this.pixels, y1, color);\n                            x2 += xStepAB;\n                            x1 += xStepBC;\n                            y1 += this.width2d;\n                        }\n                    }\n                    else {\n                        y2 -= y0;\n                        y0 -= y1;\n                        y1 = this.lineOffset[y1];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            y0--;\n                            if (y0 < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    y2--;\n                                    if (y2 < 0) {\n                                        return;\n                                    }\n                                    this.drawScanline(x1 >> 16, x0 >> 16, this.pixels, y1, color);\n                                    x0 += xStepAC;\n                                    x1 += xStepBC;\n                                    y1 += this.width2d;\n                                }\n                            }\n                            this.drawScanline(x1 >> 16, x2 >> 16, this.pixels, y1, color);\n                            x2 += xStepAB;\n                            x1 += xStepBC;\n                            y1 += this.width2d;\n                        }\n                    }\n                }\n            }\n        }\n        else if (y2 < this.bottom) {\n            if (y0 > this.bottom) {\n                y0 = this.bottom;\n            }\n            if (y1 > this.bottom) {\n                y1 = this.bottom;\n            }\n            if (y0 < y1) {\n                x1 = x2 <<= 0x10;\n                if (y2 < 0) {\n                    x1 -= xStepBC * y2;\n                    x2 -= xStepAC * y2;\n                    y2 = 0;\n                }\n                x0 <<= 0x10;\n                if (y0 < 0) {\n                    x0 -= xStepAB * y0;\n                    y0 = 0;\n                }\n                if (xStepBC < xStepAC) {\n                    y1 -= y0;\n                    y0 -= y2;\n                    y2 = this.lineOffset[y2];\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        y0--;\n                        if (y0 < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                y1--;\n                                if (y1 < 0) {\n                                    return;\n                                }\n                                this.drawScanline(x1 >> 16, x0 >> 16, this.pixels, y2, color);\n                                x1 += xStepBC;\n                                x0 += xStepAB;\n                                y2 += this.width2d;\n                            }\n                        }\n                        this.drawScanline(x1 >> 16, x2 >> 16, this.pixels, y2, color);\n                        x1 += xStepBC;\n                        x2 += xStepAC;\n                        y2 += this.width2d;\n                    }\n                }\n                else {\n                    y1 -= y0;\n                    y0 -= y2;\n                    y2 = this.lineOffset[y2];\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        y0--;\n                        if (y0 < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                y1--;\n                                if (y1 < 0) {\n                                    return;\n                                }\n                                this.drawScanline(x0 >> 16, x1 >> 16, this.pixels, y2, color);\n                                x1 += xStepBC;\n                                x0 += xStepAB;\n                                y2 += this.width2d;\n                            }\n                        }\n                        this.drawScanline(x2 >> 16, x1 >> 16, this.pixels, y2, color);\n                        x1 += xStepBC;\n                        x2 += xStepAC;\n                        y2 += this.width2d;\n                    }\n                }\n            }\n            else {\n                x0 = x2 <<= 0x10;\n                if (y2 < 0) {\n                    x0 -= xStepBC * y2;\n                    x2 -= xStepAC * y2;\n                    y2 = 0;\n                }\n                x1 <<= 0x10;\n                if (y1 < 0) {\n                    x1 -= xStepAB * y1;\n                    y1 = 0;\n                }\n                if (xStepBC < xStepAC) {\n                    y0 -= y1;\n                    y1 -= y2;\n                    y2 = this.lineOffset[y2];\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        y1--;\n                        if (y1 < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                y0--;\n                                if (y0 < 0) {\n                                    return;\n                                }\n                                this.drawScanline(x1 >> 16, x2 >> 16, this.pixels, y2, color);\n                                x1 += xStepAB;\n                                x2 += xStepAC;\n                                y2 += this.width2d;\n                            }\n                        }\n                        this.drawScanline(x0 >> 16, x2 >> 16, this.pixels, y2, color);\n                        x0 += xStepBC;\n                        x2 += xStepAC;\n                        y2 += this.width2d;\n                    }\n                }\n                else {\n                    y0 -= y1;\n                    y1 -= y2;\n                    y2 = this.lineOffset[y2];\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        y1--;\n                        if (y1 < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                y0--;\n                                if (y0 < 0) {\n                                    return;\n                                }\n                                this.drawScanline(x2 >> 16, x1 >> 16, this.pixels, y2, color);\n                                x1 += xStepAB;\n                                x2 += xStepAC;\n                                y2 += this.width2d;\n                            }\n                        }\n                        this.drawScanline(x2 >> 16, x0 >> 16, this.pixels, y2, color);\n                        x0 += xStepBC;\n                        x2 += xStepAC;\n                        y2 += this.width2d;\n                    }\n                }\n            }\n        }\n    };\n    static fillTexturedTriangle = (xA, xB, xC, yA, yB, yC, shadeA, shadeB, shadeC, originX, originY, originZ, txB, txC, tyB, tyC, tzB, tzC, texture) => {\n        const texels = this.getTexels(texture);\n        this.opaque = !this.textureTranslucent[texture];\n        const verticalX = originX - txB;\n        const verticalY = originY - tyB;\n        const verticalZ = originZ - tzB;\n        const horizontalX = txC - originX;\n        const horizontalY = tyC - originY;\n        const horizontalZ = tzC - originZ;\n        let u = (horizontalX * originY - horizontalY * originX) << 14;\n        const uStride = (horizontalY * originZ - horizontalZ * originY) << 8;\n        const uStepVertical = (horizontalZ * originX - horizontalX * originZ) << 5;\n        let v = (verticalX * originY - verticalY * originX) << 14;\n        const vStride = (verticalY * originZ - verticalZ * originY) << 8;\n        const vStepVertical = (verticalZ * originX - verticalX * originZ) << 5;\n        let w = (verticalY * horizontalX - verticalX * horizontalY) << 14;\n        const wStride = (verticalZ * horizontalY - verticalY * horizontalZ) << 8;\n        const wStepVertical = (verticalX * horizontalZ - verticalZ * horizontalX) << 5;\n        let xStepAB = 0;\n        let shadeStepAB = 0;\n        if (yB !== yA) {\n            xStepAB = (((xB - xA) << 16) / (yB - yA)) | 0;\n            shadeStepAB = (((shadeB - shadeA) << 16) / (yB - yA)) | 0;\n        }\n        let xStepBC = 0;\n        let shadeStepBC = 0;\n        if (yC !== yB) {\n            xStepBC = (((xC - xB) << 16) / (yC - yB)) | 0;\n            shadeStepBC = (((shadeC - shadeB) << 16) / (yC - yB)) | 0;\n        }\n        let xStepAC = 0;\n        let shadeStepAC = 0;\n        if (yC !== yA) {\n            xStepAC = (((xA - xC) << 16) / (yA - yC)) | 0;\n            shadeStepAC = (((shadeA - shadeC) << 16) / (yA - yC)) | 0;\n        }\n        if (yA <= yB && yA <= yC) {\n            if (yA < this.bottom) {\n                if (yB > this.bottom) {\n                    yB = this.bottom;\n                }\n                if (yC > this.bottom) {\n                    yC = this.bottom;\n                }\n                if (yB < yC) {\n                    xC = xA <<= 0x10;\n                    shadeC = shadeA <<= 0x10;\n                    if (yA < 0) {\n                        xC -= xStepAC * yA;\n                        xA -= xStepAB * yA;\n                        shadeC -= shadeStepAC * yA;\n                        shadeA -= shadeStepAB * yA;\n                        yA = 0;\n                    }\n                    xB <<= 0x10;\n                    shadeB <<= 0x10;\n                    if (yB < 0) {\n                        xB -= xStepBC * yB;\n                        shadeB -= shadeStepBC * yB;\n                        yB = 0;\n                    }\n                    const dy = yA - this.centerY;\n                    u += uStepVertical * dy;\n                    v += vStepVertical * dy;\n                    w += wStepVertical * dy;\n                    u |= 0;\n                    v |= 0;\n                    w |= 0;\n                    if ((yA !== yB && xStepAC < xStepAB) || (yA === yB && xStepAC > xStepBC)) {\n                        yC -= yB;\n                        yB -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yB--;\n                            if (yB < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xC >> 16, xB >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeB >> 8);\n                                    xC += xStepAC;\n                                    xB += xStepBC;\n                                    shadeC += shadeStepAC;\n                                    shadeB += shadeStepBC;\n                                    yA += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xC >> 16, xA >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeA >> 8);\n                            xC += xStepAC;\n                            xA += xStepAB;\n                            shadeC += shadeStepAC;\n                            shadeA += shadeStepAB;\n                            yA += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                    else {\n                        yC -= yB;\n                        yB -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yB--;\n                            if (yB < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xB >> 16, xC >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeC >> 8);\n                                    xC += xStepAC;\n                                    xB += xStepBC;\n                                    shadeC += shadeStepAC;\n                                    shadeB += shadeStepBC;\n                                    yA += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xA >> 16, xC >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeC >> 8);\n                            xC += xStepAC;\n                            xA += xStepAB;\n                            shadeC += shadeStepAC;\n                            shadeA += shadeStepAB;\n                            yA += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                }\n                else {\n                    xB = xA <<= 0x10;\n                    shadeB = shadeA <<= 0x10;\n                    if (yA < 0) {\n                        xB -= xStepAC * yA;\n                        xA -= xStepAB * yA;\n                        shadeB -= shadeStepAC * yA;\n                        shadeA -= shadeStepAB * yA;\n                        yA = 0;\n                    }\n                    xC <<= 0x10;\n                    shadeC <<= 0x10;\n                    if (yC < 0) {\n                        xC -= xStepBC * yC;\n                        shadeC -= shadeStepBC * yC;\n                        yC = 0;\n                    }\n                    const dy = yA - this.centerY;\n                    u += uStepVertical * dy;\n                    v += vStepVertical * dy;\n                    w += wStepVertical * dy;\n                    u |= 0;\n                    v |= 0;\n                    w |= 0;\n                    if ((yA === yC || xStepAC >= xStepAB) && (yA !== yC || xStepBC <= xStepAB)) {\n                        yB -= yC;\n                        yC -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yB--;\n                                    if (yB < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xA >> 16, xC >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeC >> 8);\n                                    xC += xStepBC;\n                                    xA += xStepAB;\n                                    shadeC += shadeStepBC;\n                                    shadeA += shadeStepAB;\n                                    yA += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xA >> 16, xB >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeB >> 8);\n                            xB += xStepAC;\n                            xA += xStepAB;\n                            shadeB += shadeStepAC;\n                            shadeA += shadeStepAB;\n                            yA += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                    else {\n                        yB -= yC;\n                        yC -= yA;\n                        yA = this.lineOffset[yA];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yB--;\n                                    if (yB < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xC >> 16, xA >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeA >> 8);\n                                    xC += xStepBC;\n                                    xA += xStepAB;\n                                    shadeC += shadeStepBC;\n                                    shadeA += shadeStepAB;\n                                    yA += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xB >> 16, xA >> 16, this.pixels, yA, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeA >> 8);\n                            xB += xStepAC;\n                            xA += xStepAB;\n                            shadeB += shadeStepAC;\n                            shadeA += shadeStepAB;\n                            yA += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                }\n            }\n        }\n        else if (yB <= yC) {\n            if (yB < this.bottom) {\n                if (yC > this.bottom) {\n                    yC = this.bottom;\n                }\n                if (yA > this.bottom) {\n                    yA = this.bottom;\n                }\n                if (yC < yA) {\n                    xA = xB <<= 0x10;\n                    shadeA = shadeB <<= 0x10;\n                    if (yB < 0) {\n                        xA -= xStepAB * yB;\n                        xB -= xStepBC * yB;\n                        shadeA -= shadeStepAB * yB;\n                        shadeB -= shadeStepBC * yB;\n                        yB = 0;\n                    }\n                    xC <<= 0x10;\n                    shadeC <<= 0x10;\n                    if (yC < 0) {\n                        xC -= xStepAC * yC;\n                        shadeC -= shadeStepAC * yC;\n                        yC = 0;\n                    }\n                    const dy = yB - this.centerY;\n                    u += uStepVertical * dy;\n                    v += vStepVertical * dy;\n                    w += wStepVertical * dy;\n                    u |= 0;\n                    v |= 0;\n                    w |= 0;\n                    if ((yB !== yC && xStepAB < xStepBC) || (yB === yC && xStepAB > xStepAC)) {\n                        yA -= yC;\n                        yC -= yB;\n                        yB = this.lineOffset[yB];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yA--;\n                                    if (yA < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xA >> 16, xC >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeC >> 8);\n                                    xA += xStepAB;\n                                    xC += xStepAC;\n                                    shadeA += shadeStepAB;\n                                    shadeC += shadeStepAC;\n                                    yB += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xA >> 16, xB >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeB >> 8);\n                            xA += xStepAB;\n                            xB += xStepBC;\n                            shadeA += shadeStepAB;\n                            shadeB += shadeStepBC;\n                            yB += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                    else {\n                        yA -= yC;\n                        yC -= yB;\n                        yB = this.lineOffset[yB];\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yC--;\n                            if (yC < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yA--;\n                                    if (yA < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xC >> 16, xA >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeA >> 8);\n                                    xA += xStepAB;\n                                    xC += xStepAC;\n                                    shadeA += shadeStepAB;\n                                    shadeC += shadeStepAC;\n                                    yB += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xB >> 16, xA >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeA >> 8);\n                            xA += xStepAB;\n                            xB += xStepBC;\n                            shadeA += shadeStepAB;\n                            shadeB += shadeStepBC;\n                            yB += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                }\n                else {\n                    xC = xB <<= 0x10;\n                    shadeC = shadeB <<= 0x10;\n                    if (yB < 0) {\n                        xC -= xStepAB * yB;\n                        xB -= xStepBC * yB;\n                        shadeC -= shadeStepAB * yB;\n                        shadeB -= shadeStepBC * yB;\n                        yB = 0;\n                    }\n                    xA <<= 0x10;\n                    shadeA <<= 0x10;\n                    if (yA < 0) {\n                        xA -= xStepAC * yA;\n                        shadeA -= shadeStepAC * yA;\n                        yA = 0;\n                    }\n                    const dy = yB - this.centerY;\n                    u += uStepVertical * dy;\n                    v += vStepVertical * dy;\n                    w += wStepVertical * dy;\n                    u |= 0;\n                    v |= 0;\n                    w |= 0;\n                    yC -= yA;\n                    yA -= yB;\n                    yB = this.lineOffset[yB];\n                    if (xStepAB < xStepBC) {\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yA--;\n                            if (yA < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xA >> 16, xB >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeB >> 8);\n                                    xA += xStepAC;\n                                    xB += xStepBC;\n                                    shadeA += shadeStepAC;\n                                    shadeB += shadeStepBC;\n                                    yB += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xC >> 16, xB >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeB >> 8);\n                            xC += xStepAB;\n                            xB += xStepBC;\n                            shadeC += shadeStepAB;\n                            shadeB += shadeStepBC;\n                            yB += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                    else {\n                        // eslint-disable-next-line no-constant-condition\n                        while (true) {\n                            yA--;\n                            if (yA < 0) {\n                                // eslint-disable-next-line no-constant-condition\n                                while (true) {\n                                    yC--;\n                                    if (yC < 0) {\n                                        return;\n                                    }\n                                    this.drawTexturedScanline(xB >> 16, xA >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeA >> 8);\n                                    xA += xStepAC;\n                                    xB += xStepBC;\n                                    shadeA += shadeStepAC;\n                                    shadeB += shadeStepBC;\n                                    yB += this.width2d;\n                                    u += uStepVertical;\n                                    v += vStepVertical;\n                                    w += wStepVertical;\n                                    u |= 0;\n                                    v |= 0;\n                                    w |= 0;\n                                }\n                            }\n                            this.drawTexturedScanline(xB >> 16, xC >> 16, this.pixels, yB, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeC >> 8);\n                            xC += xStepAB;\n                            xB += xStepBC;\n                            shadeC += shadeStepAB;\n                            shadeB += shadeStepBC;\n                            yB += this.width2d;\n                            u += uStepVertical;\n                            v += vStepVertical;\n                            w += wStepVertical;\n                            u |= 0;\n                            v |= 0;\n                            w |= 0;\n                        }\n                    }\n                }\n            }\n        }\n        else if (yC < this.bottom) {\n            if (yA > this.bottom) {\n                yA = this.bottom;\n            }\n            if (yB > this.bottom) {\n                yB = this.bottom;\n            }\n            if (yA < yB) {\n                xB = xC <<= 0x10;\n                shadeB = shadeC <<= 0x10;\n                if (yC < 0) {\n                    xB -= xStepBC * yC;\n                    xC -= xStepAC * yC;\n                    shadeB -= shadeStepBC * yC;\n                    shadeC -= shadeStepAC * yC;\n                    yC = 0;\n                }\n                xA <<= 0x10;\n                shadeA <<= 0x10;\n                if (yA < 0) {\n                    xA -= xStepAB * yA;\n                    shadeA -= shadeStepAB * yA;\n                    yA = 0;\n                }\n                const dy = yC - this.centerY;\n                u += uStepVertical * dy;\n                v += vStepVertical * dy;\n                w += wStepVertical * dy;\n                u |= 0;\n                v |= 0;\n                w |= 0;\n                yB -= yA;\n                yA -= yC;\n                yC = this.lineOffset[yC];\n                if (xStepBC < xStepAC) {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yA--;\n                        if (yA < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yB--;\n                                if (yB < 0) {\n                                    return;\n                                }\n                                this.drawTexturedScanline(xB >> 16, xA >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeA >> 8);\n                                xB += xStepBC;\n                                xA += xStepAB;\n                                shadeB += shadeStepBC;\n                                shadeA += shadeStepAB;\n                                yC += this.width2d;\n                                u += uStepVertical;\n                                v += vStepVertical;\n                                w += wStepVertical;\n                                u |= 0;\n                                v |= 0;\n                                w |= 0;\n                            }\n                        }\n                        this.drawTexturedScanline(xB >> 16, xC >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeC >> 8);\n                        xB += xStepBC;\n                        xC += xStepAC;\n                        shadeB += shadeStepBC;\n                        shadeC += shadeStepAC;\n                        yC += this.width2d;\n                        u += uStepVertical;\n                        v += vStepVertical;\n                        w += wStepVertical;\n                        u |= 0;\n                        v |= 0;\n                        w |= 0;\n                    }\n                }\n                else {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yA--;\n                        if (yA < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yB--;\n                                if (yB < 0) {\n                                    return;\n                                }\n                                this.drawTexturedScanline(xA >> 16, xB >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeB >> 8);\n                                xB += xStepBC;\n                                xA += xStepAB;\n                                shadeB += shadeStepBC;\n                                shadeA += shadeStepAB;\n                                yC += this.width2d;\n                                u += uStepVertical;\n                                v += vStepVertical;\n                                w += wStepVertical;\n                                u |= 0;\n                                v |= 0;\n                                w |= 0;\n                            }\n                        }\n                        this.drawTexturedScanline(xC >> 16, xB >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeB >> 8);\n                        xB += xStepBC;\n                        xC += xStepAC;\n                        shadeB += shadeStepBC;\n                        shadeC += shadeStepAC;\n                        yC += this.width2d;\n                        u += uStepVertical;\n                        v += vStepVertical;\n                        w += wStepVertical;\n                        u |= 0;\n                        v |= 0;\n                        w |= 0;\n                    }\n                }\n            }\n            else {\n                xA = xC <<= 0x10;\n                shadeA = shadeC <<= 0x10;\n                if (yC < 0) {\n                    xA -= xStepBC * yC;\n                    xC -= xStepAC * yC;\n                    shadeA -= shadeStepBC * yC;\n                    shadeC -= shadeStepAC * yC;\n                    yC = 0;\n                }\n                xB <<= 0x10;\n                shadeB <<= 0x10;\n                if (yB < 0) {\n                    xB -= xStepAB * yB;\n                    shadeB -= shadeStepAB * yB;\n                    yB = 0;\n                }\n                const dy = yC - this.centerY;\n                u += uStepVertical * dy;\n                v += vStepVertical * dy;\n                w += wStepVertical * dy;\n                u |= 0;\n                v |= 0;\n                w |= 0;\n                yA -= yB;\n                yB -= yC;\n                yC = this.lineOffset[yC];\n                if (xStepBC < xStepAC) {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yB--;\n                        if (yB < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yA--;\n                                if (yA < 0) {\n                                    return;\n                                }\n                                this.drawTexturedScanline(xB >> 16, xC >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeB >> 8, shadeC >> 8);\n                                xB += xStepAB;\n                                xC += xStepAC;\n                                shadeB += shadeStepAB;\n                                shadeC += shadeStepAC;\n                                yC += this.width2d;\n                                u += uStepVertical;\n                                v += vStepVertical;\n                                w += wStepVertical;\n                                u |= 0;\n                                v |= 0;\n                                w |= 0;\n                            }\n                        }\n                        this.drawTexturedScanline(xA >> 16, xC >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeA >> 8, shadeC >> 8);\n                        xA += xStepBC;\n                        xC += xStepAC;\n                        shadeA += shadeStepBC;\n                        shadeC += shadeStepAC;\n                        yC += this.width2d;\n                        u += uStepVertical;\n                        v += vStepVertical;\n                        w += wStepVertical;\n                        u |= 0;\n                        v |= 0;\n                        w |= 0;\n                    }\n                }\n                else {\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        yB--;\n                        if (yB < 0) {\n                            // eslint-disable-next-line no-constant-condition\n                            while (true) {\n                                yA--;\n                                if (yA < 0) {\n                                    return;\n                                }\n                                this.drawTexturedScanline(xC >> 16, xB >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeB >> 8);\n                                xB += xStepAB;\n                                xC += xStepAC;\n                                shadeB += shadeStepAB;\n                                shadeC += shadeStepAC;\n                                yC += this.width2d;\n                                u += uStepVertical;\n                                v += vStepVertical;\n                                w += wStepVertical;\n                                u |= 0;\n                                v |= 0;\n                                w |= 0;\n                            }\n                        }\n                        this.drawTexturedScanline(xC >> 16, xA >> 16, this.pixels, yC, texels, 0, 0, u, v, w, uStride, vStride, wStride, shadeC >> 8, shadeA >> 8);\n                        xA += xStepBC;\n                        xC += xStepAC;\n                        shadeA += shadeStepBC;\n                        shadeC += shadeStepAC;\n                        yC += this.width2d;\n                        u += uStepVertical;\n                        v += vStepVertical;\n                        w += wStepVertical;\n                        u |= 0;\n                        v |= 0;\n                        w |= 0;\n                    }\n                }\n            }\n        }\n    };\n    static drawTexturedScanline = (xA, xB, dst, offset, texels, curU, curV, u, v, w, uStride, vStride, wStride, shadeA, shadeB) => {\n        if (xA >= xB) {\n            return;\n        }\n        let shadeStrides;\n        let strides;\n        if (this.clipX) {\n            shadeStrides = ((shadeB - shadeA) / (xB - xA)) | 0;\n            if (xB > this.boundX) {\n                xB = this.boundX;\n            }\n            if (xA < 0) {\n                shadeA -= xA * shadeStrides;\n                xA = 0;\n            }\n            if (xA >= xB) {\n                return;\n            }\n            strides = (xB - xA) >> 3;\n            shadeStrides <<= 0xc;\n        }\n        else {\n            if (xB - xA > 7) {\n                strides = (xB - xA) >> 3;\n                shadeStrides = ((shadeB - shadeA) * this.reciprocal15[strides]) >> 6;\n            }\n            else {\n                strides = 0;\n                shadeStrides = 0;\n            }\n        }\n        shadeA <<= 0x9;\n        offset += xA;\n        let nextU;\n        let nextV;\n        let curW;\n        let dx;\n        let stepU;\n        let stepV;\n        let shadeShift;\n        if (this.lowMemory && texels) {\n            nextU = 0;\n            nextV = 0;\n            dx = xA - this.centerX;\n            u = u + (uStride >> 3) * dx;\n            v = v + (vStride >> 3) * dx;\n            w = w + (wStride >> 3) * dx;\n            u |= 0;\n            v |= 0;\n            w |= 0;\n            curW = w >> 12;\n            if (curW !== 0) {\n                curU = (u / curW) | 0;\n                curV = (v / curW) | 0;\n                if (curU < 0) {\n                    curU = 0;\n                }\n                else if (curU > 4032) {\n                    curU = 4032;\n                }\n            }\n            u = u + uStride;\n            v = v + vStride;\n            w = w + wStride;\n            u |= 0;\n            v |= 0;\n            w |= 0;\n            curW = w >> 12;\n            if (curW !== 0) {\n                nextU = (u / curW) | 0;\n                nextV = (v / curW) | 0;\n                if (nextU < 7) {\n                    nextU = 7;\n                }\n                else if (nextU > 4032) {\n                    nextU = 4032;\n                }\n            }\n            stepU = (nextU - curU) >> 3;\n            stepV = (nextV - curV) >> 3;\n            curU += (shadeA >> 3) & 0xc0000;\n            shadeShift = shadeA >> 23;\n            if (this.opaque) {\n                while (strides-- > 0) {\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU = nextU;\n                    curV = nextV;\n                    u += uStride;\n                    v += vStride;\n                    w += wStride;\n                    curW = w >> 12;\n                    if (curW !== 0) {\n                        nextU = (u / curW) | 0;\n                        nextV = (v / curW) | 0;\n                        if (nextU < 7) {\n                            nextU = 7;\n                        }\n                        else if (nextU > 4032) {\n                            nextU = 4032;\n                        }\n                    }\n                    stepU = (nextU - curU) >> 3;\n                    stepV = (nextV - curV) >> 3;\n                    shadeA += shadeStrides;\n                    curU += (shadeA >> 3) & 0xc0000;\n                    shadeShift = shadeA >> 23;\n                }\n                strides = (xB - xA) & 0x7;\n                while (strides-- > 0) {\n                    dst[offset++] = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift;\n                    curU += stepU;\n                    curV += stepV;\n                }\n            }\n            else {\n                while (strides-- > 0) {\n                    let rgb;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset = offset + 1;\n                    curU += stepU;\n                    curV += stepV;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset++;\n                    curU += stepU;\n                    curV += stepV;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset++;\n                    curU += stepU;\n                    curV += stepV;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset++;\n                    curU += stepU;\n                    curV += stepV;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset++;\n                    curU += stepU;\n                    curV += stepV;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset++;\n                    curU += stepU;\n                    curV += stepV;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset++;\n                    curU += stepU;\n                    curV += stepV;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset = offset + 1;\n                    curU = nextU;\n                    curV = nextV;\n                    u += uStride;\n                    v += vStride;\n                    w += wStride;\n                    u |= 0;\n                    v |= 0;\n                    w |= 0;\n                    curW = w >> 12;\n                    if (curW !== 0) {\n                        nextU = (u / curW) | 0;\n                        nextV = (v / curW) | 0;\n                        if (nextU < 7) {\n                            nextU = 7;\n                        }\n                        else if (nextU > 4032) {\n                            nextU = 4032;\n                        }\n                    }\n                    stepU = (nextU - curU) >> 3;\n                    stepV = (nextV - curV) >> 3;\n                    shadeA += shadeStrides;\n                    curU += (shadeA >> 3) & 0xc0000;\n                    shadeShift = shadeA >> 23;\n                }\n                strides = (xB - xA) & 0x7;\n                while (strides-- > 0) {\n                    let rgb;\n                    if ((rgb = texels[(curV & 0xfc0) + (curU >> 6)] >>> shadeShift) !== 0) {\n                        dst[offset] = rgb;\n                    }\n                    offset++;\n                    curU += stepU;\n                    curV += stepV;\n                }\n            }\n            return;\n        }\n        nextU = 0;\n        nextV = 0;\n        dx = xA - this.centerX;\n        u = u + (uStride >> 3) * dx;\n        v = v + (vStride >> 3) * dx;\n        w = w + (wStride >> 3) * dx;\n        u |= 0;\n        v |= 0;\n        w |= 0;\n        curW = w >> 14;\n        if (curW !== 0) {\n            curU = (u / curW) | 0;\n            curV = (v / curW) | 0;\n            if (curU < 0) {\n                curU = 0;\n            }\n            else if (curU > 16256) {\n                curU = 16256;\n            }\n        }\n        u = u + uStride;\n        v = v + vStride;\n        w = w + wStride;\n        u |= 0;\n        v |= 0;\n        w |= 0;\n        curW = w >> 14;\n        if (curW !== 0) {\n            nextU = (u / curW) | 0;\n            nextV = (v / curW) | 0;\n            if (nextU < 7) {\n                nextU = 7;\n            }\n            else if (nextU > 16256) {\n                nextU = 16256;\n            }\n        }\n        stepU = (nextU - curU) >> 3;\n        stepV = (nextV - curV) >> 3;\n        curU += shadeA & 0x600000;\n        shadeShift = shadeA >> 23;\n        if (this.opaque && texels) {\n            while (strides-- > 0) {\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU = nextU;\n                curV = nextV;\n                u += uStride;\n                v += vStride;\n                w += wStride;\n                u |= 0;\n                v |= 0;\n                w |= 0;\n                curW = w >> 14;\n                if (curW !== 0) {\n                    nextU = (u / curW) | 0;\n                    nextV = (v / curW) | 0;\n                    if (nextU < 7) {\n                        nextU = 7;\n                    }\n                    else if (nextU > 16256) {\n                        nextU = 16256;\n                    }\n                }\n                stepU = (nextU - curU) >> 3;\n                stepV = (nextV - curV) >> 3;\n                shadeA += shadeStrides;\n                curU += shadeA & 0x600000;\n                shadeShift = shadeA >> 23;\n            }\n            strides = (xB - xA) & 0x7;\n            while (strides-- > 0) {\n                dst[offset++] = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift;\n                curU += stepU;\n                curV += stepV;\n            }\n            return;\n        }\n        while (strides-- > 0 && texels) {\n            let rgb;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset = offset + 1;\n            curU += stepU;\n            curV += stepV;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU += stepU;\n            curV += stepV;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU += stepU;\n            curV += stepV;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU += stepU;\n            curV += stepV;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU += stepU;\n            curV += stepV;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU += stepU;\n            curV += stepV;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU += stepU;\n            curV += stepV;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU = nextU;\n            curV = nextV;\n            u += uStride;\n            v += vStride;\n            w += wStride;\n            u |= 0;\n            v |= 0;\n            w |= 0;\n            curW = w >> 14;\n            if (curW !== 0) {\n                nextU = (u / curW) | 0;\n                nextV = (v / curW) | 0;\n                if (nextU < 7) {\n                    nextU = 7;\n                }\n                else if (nextU > 16256) {\n                    nextU = 16256;\n                }\n            }\n            stepU = (nextU - curU) >> 3;\n            stepV = (nextV - curV) >> 3;\n            shadeA += shadeStrides;\n            curU += shadeA & 0x600000;\n            shadeShift = shadeA >> 23;\n        }\n        strides = (xB - xA) & 0x7;\n        while (strides-- > 0 && texels) {\n            let rgb;\n            if ((rgb = texels[(curV & 0x3f80) + (curU >> 7)] >>> shadeShift) !== 0) {\n                dst[offset] = rgb;\n            }\n            offset++;\n            curU += stepU;\n            curV += stepV;\n        }\n    };\n    static drawScanline = (x0, x1, dst, offset, rgb) => {\n        if (this.clipX) {\n            if (x1 > this.boundX) {\n                x1 = this.boundX;\n            }\n            if (x0 < 0) {\n                x0 = 0;\n            }\n        }\n        if (x0 >= x1) {\n            return;\n        }\n        offset += x0;\n        let length = (x1 - x0) >> 2;\n        if (this.alpha === 0) {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                length--;\n                if (length < 0) {\n                    length = (x1 - x0) & 0x3;\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        length--;\n                        if (length < 0) {\n                            return;\n                        }\n                        dst[offset++] = rgb;\n                    }\n                }\n                dst[offset++] = rgb;\n                dst[offset++] = rgb;\n                dst[offset++] = rgb;\n                dst[offset++] = rgb;\n            }\n        }\n        const alpha = this.alpha;\n        const invAlpha = 256 - this.alpha;\n        rgb = ((((rgb & 0xff00ff) * invAlpha) >> 8) & 0xff00ff) + ((((rgb & 0xff00) * invAlpha) >> 8) & 0xff00);\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            length--;\n            if (length < 0) {\n                length = (x1 - x0) & 0x3;\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    length--;\n                    if (length < 0) {\n                        return;\n                    }\n                    dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n                }\n            }\n            dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n            dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n            dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n            dst[offset++] = rgb + ((((dst[offset] & 0xff00ff) * alpha) >> 8) & 0xff00ff) + ((((dst[offset] & 0xff00) * alpha) >> 8) & 0xff00);\n        }\n    };\n    static pushTexture = (id) => {\n        if (this.activeTexels[id] && this.texelPool) {\n            this.texelPool[this.poolSize++] = this.activeTexels[id];\n            this.activeTexels[id] = null;\n        }\n    };\n    static getTexels = (id) => {\n        this.textureCycle[id] = this.cycle++;\n        if (this.activeTexels[id]) {\n            return this.activeTexels[id];\n        }\n        let texels;\n        if (this.poolSize > 0 && this.texelPool) {\n            texels = this.texelPool[--this.poolSize];\n            this.texelPool[this.poolSize] = null;\n        }\n        else {\n            let cycle = 0;\n            let selected = -1;\n            for (let t = 0; t < this.textureCount; t++) {\n                if (this.activeTexels[t] && (this.textureCycle[t] < cycle || selected === -1)) {\n                    cycle = this.textureCycle[t];\n                    selected = t;\n                }\n            }\n            texels = this.activeTexels[selected];\n            this.activeTexels[selected] = null;\n        }\n        this.activeTexels[id] = texels;\n        const texture = this.textures[id];\n        const palette = this.texturePalette[id];\n        if (!texels || !texture || !palette) {\n            return null;\n        }\n        if (this.lowMemory) {\n            this.textureTranslucent[id] = false;\n            for (let i = 0; i < 4096; i++) {\n                const rgb = (texels[i] = palette[texture.pixels[i]] & 0xf8f8ff);\n                if (rgb === 0) {\n                    this.textureTranslucent[id] = true;\n                }\n                texels[i + 4096] = (rgb - (rgb >>> 3)) & 0xf8f8ff;\n                texels[i + 8192] = (rgb - (rgb >>> 2)) & 0xf8f8ff;\n                texels[i + 12288] = (rgb - (rgb >>> 2) - (rgb >>> 3)) & 0xf8f8ff;\n            }\n        }\n        else {\n            if (texture.width === 64) {\n                for (let y = 0; y < 128; y++) {\n                    for (let x = 0; x < 128; x++) {\n                        texels[x + ((y << 7) | 0)] = palette[texture.pixels[(x >> 1) + (((y >> 1) << 6) | 0)]];\n                    }\n                }\n            }\n            else {\n                for (let i = 0; i < 16384; i++) {\n                    texels[i] = palette[texture.pixels[i]];\n                }\n            }\n            this.textureTranslucent[id] = false;\n            for (let i = 0; i < 16384; i++) {\n                texels[i] &= 0xf8f8ff;\n                const rgb = texels[i];\n                if (rgb === 0) {\n                    this.textureTranslucent[id] = true;\n                }\n                texels[i + 16384] = (rgb - (rgb >>> 3)) & 0xf8f8ff;\n                texels[i + 32768] = (rgb - (rgb >>> 2)) & 0xf8f8ff;\n                texels[i + 49152] = (rgb - (rgb >>> 2) - (rgb >>> 3)) & 0xf8f8ff;\n            }\n        }\n        return texels;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Draw3D.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Jpeg.ts":
/*!****************************************!*\
  !*** ./src/js/jagex2/graphics/Jpeg.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeJpeg: () => (/* binding */ decodeJpeg)\n/* harmony export */ });\n/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Canvas */ \"./src/js/jagex2/graphics/Canvas.ts\");\n\nconst decodeJpeg = async (data) => {\n    if (data[0] !== 0xff) {\n        // fix invalid JPEG header\n        data[0] = 0xff;\n    }\n    URL.revokeObjectURL(_Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegImg.src); // Remove previous decoded jpeg.\n    _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegImg.src = URL.createObjectURL(new Blob([data], { type: 'image/jpeg' }));\n    // wait for img to load\n    await new Promise((resolve) => (_Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegImg.onload = () => resolve()));\n    // Clear the canvas before drawing\n    _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpeg2d.clearRect(0, 0, _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegCanvas.width, _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegCanvas.height);\n    const width = _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegImg.naturalWidth;\n    const height = _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegImg.naturalHeight;\n    _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegCanvas.width = width;\n    _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegCanvas.height = height;\n    // Draw the image\n    _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpeg2d.drawImage(_Canvas__WEBPACK_IMPORTED_MODULE_0__.jpegImg, 0, 0);\n    return _Canvas__WEBPACK_IMPORTED_MODULE_0__.jpeg2d.getImageData(0, 0, width, height);\n};\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Jpeg.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Model.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/graphics/Model.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VertexNormal: () => (/* binding */ VertexNormal),\n/* harmony export */   \"default\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _Draw2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _Draw3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Draw3D */ \"./src/js/jagex2/graphics/Draw3D.ts\");\n/* harmony import */ var _AnimFrame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AnimFrame */ \"./src/js/jagex2/graphics/AnimFrame.ts\");\n/* harmony import */ var _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../datastruct/Hashable */ \"./src/js/jagex2/datastruct/Hashable.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\n\n\n\nclass Metadata {\n    vertexCount = 0;\n    faceCount = 0;\n    texturedFaceCount = 0;\n    vertexFlagsOffset = -1;\n    vertexXOffset = -1;\n    vertexYOffset = -1;\n    vertexZOffset = -1;\n    vertexLabelsOffset = -1;\n    faceVerticesOffset = -1;\n    faceOrientationsOffset = -1;\n    faceColorsOffset = -1;\n    faceInfosOffset = -1;\n    facePrioritiesOffset = 0;\n    faceAlphasOffset = -1;\n    faceLabelsOffset = -1;\n    faceTextureAxisOffset = -1;\n    data = null;\n}\nclass VertexNormal {\n    x = 0;\n    y = 0;\n    z = 0;\n    w = 0;\n}\nclass Model extends _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    static metadata = null;\n    static head = null;\n    static face1 = null;\n    static face2 = null;\n    static face3 = null;\n    static face4 = null;\n    static face5 = null;\n    static point1 = null;\n    static point2 = null;\n    static point3 = null;\n    static point4 = null;\n    static point5 = null;\n    static vertex1 = null;\n    static vertex2 = null;\n    static axis = null;\n    static faceClippedX = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(4096, false);\n    static faceNearClipped = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(4096, false);\n    static vertexScreenX = new Int32Array(4096);\n    static vertexScreenY = new Int32Array(4096);\n    static vertexScreenZ = new Int32Array(4096);\n    static vertexViewSpaceX = new Int32Array(4096);\n    static vertexViewSpaceY = new Int32Array(4096);\n    static vertexViewSpaceZ = new Int32Array(4096);\n    static tmpDepthFaceCount = new Int32Array(1500);\n    static tmpDepthFaces = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.Int32Array2d(1500, 512);\n    static tmpPriorityFaceCount = new Int32Array(12);\n    static tmpPriorityFaces = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.Int32Array2d(12, 2000);\n    static tmpPriority10FaceDepth = new Int32Array(2000);\n    static tmpPriority11FaceDepth = new Int32Array(2000);\n    static tmpPriorityDepthSum = new Int32Array(12);\n    static clippedX = new Int32Array(10);\n    static clippedY = new Int32Array(10);\n    static clippedColor = new Int32Array(10);\n    static baseX = 0;\n    static baseY = 0;\n    static baseZ = 0;\n    static checkHover = false;\n    static mouseX = 0;\n    static mouseY = 0;\n    static pickedCount = 0;\n    static pickedBitsets = new Int32Array(1000);\n    static checkHoverFace = false;\n    static unpack(models) {\n        try {\n            Model.head = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_head.dat'));\n            Model.face1 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_face1.dat'));\n            Model.face2 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_face2.dat'));\n            Model.face3 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_face3.dat'));\n            Model.face4 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_face4.dat'));\n            Model.face5 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_face5.dat'));\n            Model.point1 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_point1.dat'));\n            Model.point2 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_point2.dat'));\n            Model.point3 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_point3.dat'));\n            Model.point4 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_point4.dat'));\n            Model.point5 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_point5.dat'));\n            Model.vertex1 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_vertex1.dat'));\n            Model.vertex2 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_vertex2.dat'));\n            Model.axis = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](models.read('ob_axis.dat'));\n            Model.head.pos = 0;\n            Model.point1.pos = 0;\n            Model.point2.pos = 0;\n            Model.point3.pos = 0;\n            Model.point4.pos = 0;\n            Model.vertex1.pos = 0;\n            Model.vertex2.pos = 0;\n            const count = Model.head.g2;\n            Model.metadata = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(count + 100, null);\n            let vertexTextureDataOffset = 0;\n            let labelDataOffset = 0;\n            let triangleColorDataOffset = 0;\n            let triangleInfoDataOffset = 0;\n            let trianglePriorityDataOffset = 0;\n            let triangleAlphaDataOffset = 0;\n            let triangleSkinDataOffset = 0;\n            for (let i = 0; i < count; i++) {\n                const id = Model.head.g2;\n                const meta = new Metadata();\n                meta.vertexCount = Model.head.g2;\n                meta.faceCount = Model.head.g2;\n                meta.texturedFaceCount = Model.head.g1;\n                meta.vertexFlagsOffset = Model.point1.pos;\n                meta.vertexXOffset = Model.point2.pos;\n                meta.vertexYOffset = Model.point3.pos;\n                meta.vertexZOffset = Model.point4.pos;\n                meta.faceVerticesOffset = Model.vertex1.pos;\n                meta.faceOrientationsOffset = Model.vertex2.pos;\n                const hasInfo = Model.head.g1;\n                const priority = Model.head.g1;\n                const hasAlpha = Model.head.g1;\n                const hasSkins = Model.head.g1;\n                const hasLabels = Model.head.g1;\n                for (let v = 0; v < meta.vertexCount; v++) {\n                    const flags = Model.point1.g1;\n                    if ((flags & 0x1) !== 0) {\n                        Model.point2.gsmart;\n                    }\n                    if ((flags & 0x2) !== 0) {\n                        Model.point3.gsmart;\n                    }\n                    if ((flags & 0x4) !== 0) {\n                        Model.point4.gsmart;\n                    }\n                }\n                for (let v = 0; v < meta.faceCount; v++) {\n                    const type = Model.vertex2.g1;\n                    if (type === 1) {\n                        Model.vertex1.gsmart;\n                        Model.vertex1.gsmart;\n                    }\n                    Model.vertex1.gsmart;\n                }\n                meta.faceColorsOffset = triangleColorDataOffset;\n                triangleColorDataOffset += meta.faceCount * 2;\n                if (hasInfo === 1) {\n                    meta.faceInfosOffset = triangleInfoDataOffset;\n                    triangleInfoDataOffset += meta.faceCount;\n                }\n                if (priority === 255) {\n                    meta.facePrioritiesOffset = trianglePriorityDataOffset;\n                    trianglePriorityDataOffset += meta.faceCount;\n                }\n                else {\n                    meta.facePrioritiesOffset = -priority - 1;\n                }\n                if (hasAlpha === 1) {\n                    meta.faceAlphasOffset = triangleAlphaDataOffset;\n                    triangleAlphaDataOffset += meta.faceCount;\n                }\n                if (hasSkins === 1) {\n                    meta.faceLabelsOffset = triangleSkinDataOffset;\n                    triangleSkinDataOffset += meta.faceCount;\n                }\n                if (hasLabels === 1) {\n                    meta.vertexLabelsOffset = labelDataOffset;\n                    labelDataOffset += meta.vertexCount;\n                }\n                meta.faceTextureAxisOffset = vertexTextureDataOffset;\n                vertexTextureDataOffset += meta.texturedFaceCount;\n                Model.metadata[id] = meta;\n            }\n        }\n        catch (err) {\n            console.log('Error loading model index');\n            console.error(err);\n        }\n    }\n    static unpack317(src, id) {\n        if (Model.metadata === null) {\n            Model.metadata = [];\n        }\n        if (src === null) {\n            const meta = new Metadata();\n            meta.vertexCount = 0;\n            meta.faceCount = 0;\n            meta.texturedFaceCount = 0;\n            Model.metadata[id] = meta;\n            return;\n        }\n        const buf = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](src);\n        buf.pos = buf.length - 18;\n        const meta = new Metadata();\n        meta.data = src;\n        meta.vertexCount = buf.g2;\n        meta.faceCount = buf.g2;\n        meta.texturedFaceCount = buf.g1;\n        Model.metadata[id] = meta;\n        const hasInfo = buf.g1;\n        const priority = buf.g1;\n        const hasAlpha = buf.g1;\n        const hasSkins = buf.g1;\n        const hasLabels = buf.g1;\n        const dataLengthX = buf.g2;\n        const dataLengthY = buf.g2;\n        const dataLengthZ = buf.g2;\n        const dataLengthFaceOrientations = buf.g2;\n        let offset = 0;\n        meta.vertexFlagsOffset = offset;\n        offset += meta.vertexCount;\n        meta.faceOrientationsOffset = offset;\n        offset += meta.faceCount;\n        meta.facePrioritiesOffset = offset;\n        if (priority === 255) {\n            offset += meta.faceCount;\n        }\n        else {\n            meta.facePrioritiesOffset = -priority - 1;\n        }\n        meta.faceLabelsOffset = offset;\n        if (hasSkins === 1) {\n            offset += meta.faceCount;\n        }\n        else {\n            meta.faceLabelsOffset = -1;\n        }\n        meta.faceInfosOffset = offset;\n        if (hasInfo === 1) {\n            offset += meta.faceCount;\n        }\n        else {\n            meta.faceInfosOffset = -1;\n        }\n        meta.vertexLabelsOffset = offset;\n        if (hasLabels === 1) {\n            offset += meta.vertexCount;\n        }\n        else {\n            meta.vertexLabelsOffset = -1;\n        }\n        meta.faceAlphasOffset = offset;\n        if (hasAlpha === 1) {\n            offset += meta.faceCount;\n        }\n        else {\n            meta.faceAlphasOffset = -1;\n        }\n        meta.faceVerticesOffset = offset;\n        offset += dataLengthFaceOrientations;\n        meta.faceColorsOffset = offset;\n        offset += meta.faceCount * 2;\n        meta.faceTextureAxisOffset = offset;\n        offset += meta.texturedFaceCount * 6;\n        meta.vertexXOffset = offset;\n        offset += dataLengthX;\n        meta.vertexYOffset = offset;\n        offset += dataLengthY;\n        meta.vertexZOffset = offset;\n        offset += dataLengthZ;\n    }\n    static unload() {\n        Model.metadata = null;\n        Model.head = null;\n        Model.face1 = null;\n        Model.face2 = null;\n        Model.face3 = null;\n        Model.face4 = null;\n        Model.face5 = null;\n        Model.point1 = null;\n        Model.point2 = null;\n        Model.point3 = null;\n        Model.point4 = null;\n        Model.point5 = null;\n        Model.vertex1 = null;\n        Model.vertex2 = null;\n        Model.axis = null;\n        Model.faceClippedX = null;\n        Model.faceNearClipped = null;\n        Model.vertexScreenX = null;\n        Model.vertexScreenY = null;\n        Model.vertexScreenZ = null;\n        Model.vertexViewSpaceX = null;\n        Model.vertexViewSpaceY = null;\n        Model.vertexViewSpaceZ = null;\n        Model.tmpDepthFaceCount = null;\n        Model.tmpDepthFaces = null;\n        Model.tmpPriorityFaceCount = null;\n        Model.tmpPriorityFaces = null;\n        Model.tmpPriority10FaceDepth = null;\n        Model.tmpPriority11FaceDepth = null;\n        Model.tmpPriorityDepthSum = null;\n    }\n    static mulColorLightness(hsl, scalar, faceInfo) {\n        if ((faceInfo & 0x2) === 2) {\n            if (scalar < 0) {\n                scalar = 0;\n            }\n            else if (scalar > 127) {\n                scalar = 127;\n            }\n            return 127 - scalar;\n        }\n        scalar = (scalar * (hsl & 0x7f)) >> 7;\n        if (scalar < 2) {\n            scalar = 2;\n        }\n        else if (scalar > 126) {\n            scalar = 126;\n        }\n        return (hsl & 0xff80) + scalar;\n    }\n    static modelCopyFaces = (src, copyVertexY, copyFaces) => {\n        const vertexCount = src.vertexCount;\n        const faceCount = src.faceCount;\n        const texturedFaceCount = src.texturedFaceCount;\n        let vertexY;\n        if (copyVertexY) {\n            vertexY = new Int32Array(vertexCount);\n            for (let v = 0; v < vertexCount; v++) {\n                vertexY[v] = src.vertexY[v];\n            }\n        }\n        else {\n            vertexY = src.vertexY;\n        }\n        let faceColorA;\n        let faceColorB;\n        let faceColorC;\n        let faceInfo;\n        let vertexNormal = null;\n        let vertexNormalOriginal = null;\n        if (copyFaces) {\n            faceColorA = new Int32Array(faceCount);\n            faceColorB = new Int32Array(faceCount);\n            faceColorC = new Int32Array(faceCount);\n            for (let f = 0; f < faceCount; f++) {\n                if (src.faceColorA) {\n                    faceColorA[f] = src.faceColorA[f];\n                }\n                if (src.faceColorB) {\n                    faceColorB[f] = src.faceColorB[f];\n                }\n                if (src.faceColorC) {\n                    faceColorC[f] = src.faceColorC[f];\n                }\n            }\n            faceInfo = new Int32Array(faceCount);\n            if (!src.faceInfo) {\n                for (let f = 0; f < faceCount; f++) {\n                    faceInfo[f] = 0;\n                }\n            }\n            else {\n                for (let f = 0; f < faceCount; f++) {\n                    faceInfo[f] = src.faceInfo[f];\n                }\n            }\n            vertexNormal = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(vertexCount, null);\n            for (let v = 0; v < vertexCount; v++) {\n                const copy = (vertexNormal[v] = new VertexNormal());\n                if (src.vertexNormal) {\n                    const original = src.vertexNormal[v];\n                    if (original) {\n                        copy.x = original.x;\n                        copy.y = original.y;\n                        copy.z = original.z;\n                        copy.w = original.w;\n                    }\n                }\n            }\n            vertexNormalOriginal = src.vertexNormalOriginal;\n        }\n        else {\n            faceColorA = src.faceColorA;\n            faceColorB = src.faceColorB;\n            faceColorC = src.faceColorC;\n            faceInfo = src.faceInfo;\n        }\n        return new Model({\n            vertexCount: vertexCount,\n            vertexX: src.vertexX,\n            vertexY: vertexY,\n            vertexZ: src.vertexZ,\n            faceCount: faceCount,\n            faceVertexA: src.faceVertexA,\n            faceVertexB: src.faceVertexB,\n            faceVertexC: src.faceVertexC,\n            faceColorA: faceColorA,\n            faceColorB: faceColorB,\n            faceColorC: faceColorC,\n            faceInfo: faceInfo,\n            facePriority: src.facePriority,\n            faceAlpha: src.faceAlpha,\n            faceColor: src.faceColor,\n            priority: src.priority,\n            texturedFaceCount: texturedFaceCount,\n            texturedVertexA: src.texturedVertexA,\n            texturedVertexB: src.texturedVertexB,\n            texturedVertexC: src.texturedVertexC,\n            minX: src.minX,\n            maxX: src.maxX,\n            minZ: src.minZ,\n            maxZ: src.maxZ,\n            radius: src.radius,\n            minY: src.minY,\n            maxY: src.maxY,\n            maxDepth: src.maxDepth,\n            minDepth: src.minDepth,\n            vertexNormal: vertexNormal,\n            vertexNormalOriginal: vertexNormalOriginal\n        });\n    };\n    static modelShareColored = (src, shareColors, shareAlpha, shareVertices) => {\n        const vertexCount = src.vertexCount;\n        const faceCount = src.faceCount;\n        const texturedFaceCount = src.texturedFaceCount;\n        let vertexX;\n        let vertexY;\n        let vertexZ;\n        if (shareVertices) {\n            vertexX = src.vertexX;\n            vertexY = src.vertexY;\n            vertexZ = src.vertexZ;\n        }\n        else {\n            vertexX = new Int32Array(vertexCount);\n            vertexY = new Int32Array(vertexCount);\n            vertexZ = new Int32Array(vertexCount);\n            for (let v = 0; v < vertexCount; v++) {\n                vertexX[v] = src.vertexX[v];\n                vertexY[v] = src.vertexY[v];\n                vertexZ[v] = src.vertexZ[v];\n            }\n        }\n        let faceColor;\n        if (shareColors) {\n            faceColor = src.faceColor;\n        }\n        else {\n            faceColor = new Int32Array(faceCount);\n            for (let f = 0; f < faceCount; f++) {\n                if (src.faceColor) {\n                    faceColor[f] = src.faceColor[f];\n                }\n            }\n        }\n        let faceAlpha;\n        if (shareAlpha) {\n            faceAlpha = src.faceAlpha;\n        }\n        else {\n            faceAlpha = new Int32Array(faceCount);\n            if (!src.faceAlpha) {\n                for (let f = 0; f < faceCount; f++) {\n                    faceAlpha[f] = 0;\n                }\n            }\n            else {\n                for (let f = 0; f < faceCount; f++) {\n                    faceAlpha[f] = src.faceAlpha[f];\n                }\n            }\n        }\n        return new Model({\n            vertexCount: vertexCount,\n            vertexX: vertexX,\n            vertexY: vertexY,\n            vertexZ: vertexZ,\n            faceCount: faceCount,\n            faceVertexA: src.faceVertexA,\n            faceVertexB: src.faceVertexB,\n            faceVertexC: src.faceVertexC,\n            faceColorA: null,\n            faceColorB: null,\n            faceColorC: null,\n            faceInfo: src.faceInfo,\n            facePriority: src.facePriority,\n            faceAlpha: faceAlpha,\n            faceColor: faceColor,\n            priority: src.priority,\n            texturedFaceCount: texturedFaceCount,\n            texturedVertexA: src.texturedVertexA,\n            texturedVertexB: src.texturedVertexB,\n            texturedVertexC: src.texturedVertexC,\n            vertexLabel: src.vertexLabel,\n            faceLabel: src.faceLabel\n        });\n    };\n    static modelShareAlpha = (src, shareAlpha) => {\n        const vertexCount = src.vertexCount;\n        const faceCount = src.faceCount;\n        const texturedFaceCount = src.texturedFaceCount;\n        const vertexX = new Int32Array(vertexCount);\n        const vertexY = new Int32Array(vertexCount);\n        const vertexZ = new Int32Array(vertexCount);\n        for (let v = 0; v < vertexCount; v++) {\n            vertexX[v] = src.vertexX[v];\n            vertexY[v] = src.vertexY[v];\n            vertexZ[v] = src.vertexZ[v];\n        }\n        let faceAlpha;\n        if (shareAlpha) {\n            faceAlpha = src.faceAlpha;\n        }\n        else {\n            faceAlpha = new Int32Array(faceCount);\n            if (!src.faceAlpha) {\n                for (let f = 0; f < faceCount; f++) {\n                    faceAlpha[f] = 0;\n                }\n            }\n            else {\n                for (let f = 0; f < faceCount; f++) {\n                    faceAlpha[f] = src.faceAlpha[f];\n                }\n            }\n        }\n        return new Model({\n            vertexCount: vertexCount,\n            vertexX: vertexX,\n            vertexY: vertexY,\n            vertexZ: vertexZ,\n            faceCount: faceCount,\n            faceVertexA: src.faceVertexA,\n            faceVertexB: src.faceVertexB,\n            faceVertexC: src.faceVertexC,\n            faceColorA: src.faceColorA,\n            faceColorB: src.faceColorB,\n            faceColorC: src.faceColorC,\n            faceInfo: src.faceInfo,\n            facePriority: src.facePriority,\n            faceAlpha: faceAlpha,\n            faceColor: src.faceColor,\n            priority: src.priority,\n            texturedFaceCount: texturedFaceCount,\n            texturedVertexA: src.texturedVertexA,\n            texturedVertexB: src.texturedVertexB,\n            texturedVertexC: src.texturedVertexC,\n            labelVertices: src.labelVertices,\n            labelFaces: src.labelFaces\n        });\n    };\n    static modelFromModelsBounds = (models, count) => {\n        let copyInfo = false;\n        let copyPriority = false;\n        let copyAlpha = false;\n        let copyColor = false;\n        let vertexCount = 0;\n        let faceCount = 0;\n        let texturedFaceCount = 0;\n        let priority = -1;\n        for (let i = 0; i < count; i++) {\n            const model = models[i];\n            if (model) {\n                vertexCount += model.vertexCount;\n                faceCount += model.faceCount;\n                texturedFaceCount += model.texturedFaceCount;\n                copyInfo ||= model.faceInfo !== null;\n                if (!model.facePriority) {\n                    if (priority === -1) {\n                        priority = model.priority;\n                    }\n                    if (priority !== model.priority) {\n                        copyPriority = true;\n                    }\n                }\n                else {\n                    copyPriority = true;\n                }\n                copyAlpha ||= model.faceAlpha !== null;\n                copyColor ||= model.faceColor !== null;\n            }\n        }\n        const vertexX = new Int32Array(vertexCount);\n        const vertexY = new Int32Array(vertexCount);\n        const vertexZ = new Int32Array(vertexCount);\n        const faceVertexA = new Int32Array(faceCount);\n        const faceVertexB = new Int32Array(faceCount);\n        const faceVertexC = new Int32Array(faceCount);\n        const faceColorA = new Int32Array(faceCount);\n        const faceColorB = new Int32Array(faceCount);\n        const faceColorC = new Int32Array(faceCount);\n        const texturedVertexA = new Int32Array(texturedFaceCount);\n        const texturedVertexB = new Int32Array(texturedFaceCount);\n        const texturedVertexC = new Int32Array(texturedFaceCount);\n        let faceInfo = null;\n        if (copyInfo) {\n            faceInfo = new Int32Array(faceCount);\n        }\n        let facePriority = null;\n        if (copyPriority) {\n            facePriority = new Int32Array(faceCount);\n        }\n        let faceAlpha = null;\n        if (copyAlpha) {\n            faceAlpha = new Int32Array(faceCount);\n        }\n        let faceColor = null;\n        if (copyColor) {\n            faceColor = new Int32Array(faceCount);\n        }\n        vertexCount = 0;\n        faceCount = 0;\n        texturedFaceCount = 0;\n        for (let i = 0; i < count; i++) {\n            const model = models[i];\n            if (model) {\n                const vertexCount2 = vertexCount;\n                for (let v = 0; v < model.vertexCount; v++) {\n                    vertexX[vertexCount] = model.vertexX[v];\n                    vertexY[vertexCount] = model.vertexY[v];\n                    vertexZ[vertexCount] = model.vertexZ[v];\n                    vertexCount++;\n                }\n                for (let f = 0; f < model.faceCount; f++) {\n                    faceVertexA[faceCount] = model.faceVertexA[f] + vertexCount2;\n                    faceVertexB[faceCount] = model.faceVertexB[f] + vertexCount2;\n                    faceVertexC[faceCount] = model.faceVertexC[f] + vertexCount2;\n                    if (model.faceColorA) {\n                        faceColorA[faceCount] = model.faceColorA[f];\n                    }\n                    if (model.faceColorB) {\n                        faceColorB[faceCount] = model.faceColorB[f];\n                    }\n                    if (model.faceColorC) {\n                        faceColorC[faceCount] = model.faceColorC[f];\n                    }\n                    if (copyInfo) {\n                        if (!model.faceInfo) {\n                            if (faceInfo) {\n                                faceInfo[faceCount] = 0;\n                            }\n                        }\n                        else {\n                            if (faceInfo) {\n                                faceInfo[faceCount] = model.faceInfo[f];\n                            }\n                        }\n                    }\n                    if (copyPriority) {\n                        if (!model.facePriority) {\n                            if (facePriority) {\n                                facePriority[faceCount] = model.priority;\n                            }\n                        }\n                        else {\n                            if (facePriority) {\n                                facePriority[faceCount] = model.facePriority[f];\n                            }\n                        }\n                    }\n                    if (copyAlpha) {\n                        if (!model.faceAlpha) {\n                            if (faceAlpha) {\n                                faceAlpha[faceCount] = 0;\n                            }\n                        }\n                        else {\n                            if (faceAlpha) {\n                                faceAlpha[faceCount] = model.faceAlpha[f];\n                            }\n                        }\n                    }\n                    if (copyColor && model.faceColor) {\n                        if (faceColor) {\n                            faceColor[faceCount] = model.faceColor[f];\n                        }\n                    }\n                    faceCount++;\n                }\n                for (let f = 0; f < model.texturedFaceCount; f++) {\n                    texturedVertexA[texturedFaceCount] = model.texturedVertexA[f] + vertexCount2;\n                    texturedVertexB[texturedFaceCount] = model.texturedVertexB[f] + vertexCount2;\n                    texturedVertexC[texturedFaceCount] = model.texturedVertexC[f] + vertexCount2;\n                    texturedFaceCount++;\n                }\n            }\n        }\n        const model = new Model({\n            vertexCount: vertexCount,\n            vertexX: vertexX,\n            vertexY: vertexY,\n            vertexZ: vertexZ,\n            faceCount: faceCount,\n            faceVertexA: faceVertexA,\n            faceVertexB: faceVertexB,\n            faceVertexC: faceVertexC,\n            faceColorA: faceColorA,\n            faceColorB: faceColorB,\n            faceColorC: faceColorC,\n            faceInfo: faceInfo,\n            facePriority: facePriority,\n            faceAlpha: faceAlpha,\n            faceColor: faceColor,\n            priority: priority,\n            texturedFaceCount: texturedFaceCount,\n            texturedVertexA: texturedVertexA,\n            texturedVertexB: texturedVertexB,\n            texturedVertexC: texturedVertexC\n        });\n        model.calculateBoundsCylinder();\n        return model;\n    };\n    static modelFromModels = (models, count) => {\n        let copyInfo = false;\n        let copyPriorities = false;\n        let copyAlpha = false;\n        let copyLabels = false;\n        let vertexCount = 0;\n        let faceCount = 0;\n        let texturedFaceCount = 0;\n        let priority = -1;\n        for (let i = 0; i < count; i++) {\n            const model = models[i];\n            if (model) {\n                vertexCount += model.vertexCount;\n                faceCount += model.faceCount;\n                texturedFaceCount += model.texturedFaceCount;\n                copyInfo ||= model.faceInfo !== null;\n                if (!model.facePriority) {\n                    if (priority === -1) {\n                        priority = model.priority;\n                    }\n                    if (priority !== model.priority) {\n                        copyPriorities = true;\n                    }\n                }\n                else {\n                    copyPriorities = true;\n                }\n                copyAlpha ||= model.faceAlpha !== null;\n                copyLabels ||= model.faceLabel !== null;\n            }\n        }\n        const vertexX = new Int32Array(vertexCount);\n        const vertexY = new Int32Array(vertexCount);\n        const vertexZ = new Int32Array(vertexCount);\n        const vertexLabel = new Int32Array(vertexCount);\n        const faceVertexA = new Int32Array(faceCount);\n        const faceVertexB = new Int32Array(faceCount);\n        const faceVertexC = new Int32Array(faceCount);\n        const texturedVertexA = new Int32Array(texturedFaceCount);\n        const texturedVertexB = new Int32Array(texturedFaceCount);\n        const texturedVertexC = new Int32Array(texturedFaceCount);\n        let faceInfo = null;\n        if (copyInfo) {\n            faceInfo = new Int32Array(faceCount);\n        }\n        let facePriority = null;\n        if (copyPriorities) {\n            facePriority = new Int32Array(faceCount);\n        }\n        let faceAlpha = null;\n        if (copyAlpha) {\n            faceAlpha = new Int32Array(faceCount);\n        }\n        let faceLabel = null;\n        if (copyLabels) {\n            faceLabel = new Int32Array(faceCount);\n        }\n        const faceColor = new Int32Array(faceCount);\n        vertexCount = 0;\n        faceCount = 0;\n        texturedFaceCount = 0;\n        const addVertex = (src, vertexId, vertexX, vertexY, vertexZ, vertexLabel, vertexCount) => {\n            let identical = -1;\n            const x = src.vertexX[vertexId];\n            const y = src.vertexY[vertexId];\n            const z = src.vertexZ[vertexId];\n            for (let v = 0; v < vertexCount; v++) {\n                if (x === vertexX[v] && y === vertexY[v] && z === vertexZ[v]) {\n                    identical = v;\n                    break;\n                }\n            }\n            if (identical === -1) {\n                vertexX[vertexCount] = x;\n                vertexY[vertexCount] = y;\n                vertexZ[vertexCount] = z;\n                if (vertexLabel && src.vertexLabel) {\n                    vertexLabel[vertexCount] = src.vertexLabel[vertexId];\n                }\n                identical = vertexCount++;\n            }\n            return { vertex: identical, vertexCount };\n        };\n        for (let i = 0; i < count; i++) {\n            const model = models[i];\n            if (model) {\n                for (let face = 0; face < model.faceCount; face++) {\n                    if (copyInfo) {\n                        if (!model.faceInfo) {\n                            if (faceInfo) {\n                                faceInfo[faceCount] = 0;\n                            }\n                        }\n                        else {\n                            if (faceInfo) {\n                                faceInfo[faceCount] = model.faceInfo[face];\n                            }\n                        }\n                    }\n                    if (copyPriorities) {\n                        if (!model.facePriority) {\n                            if (facePriority) {\n                                facePriority[faceCount] = model.priority;\n                            }\n                        }\n                        else {\n                            if (facePriority) {\n                                facePriority[faceCount] = model.facePriority[face];\n                            }\n                        }\n                    }\n                    if (copyAlpha) {\n                        if (!model.faceAlpha) {\n                            if (faceAlpha) {\n                                faceAlpha[faceCount] = 0;\n                            }\n                        }\n                        else {\n                            if (faceAlpha) {\n                                faceAlpha[faceCount] = model.faceAlpha[face];\n                            }\n                        }\n                    }\n                    if (copyLabels && model.faceLabel) {\n                        if (faceLabel) {\n                            faceLabel[faceCount] = model.faceLabel[face];\n                        }\n                    }\n                    if (model.faceColor) {\n                        faceColor[faceCount] = model.faceColor[face];\n                    }\n                    const a = addVertex(model, model.faceVertexA[face], vertexX, vertexY, vertexZ, vertexLabel, vertexCount);\n                    vertexCount = a.vertexCount;\n                    const b = addVertex(model, model.faceVertexB[face], vertexX, vertexY, vertexZ, vertexLabel, vertexCount);\n                    vertexCount = b.vertexCount;\n                    const c = addVertex(model, model.faceVertexC[face], vertexX, vertexY, vertexZ, vertexLabel, vertexCount);\n                    vertexCount = c.vertexCount;\n                    faceVertexA[faceCount] = a.vertex;\n                    faceVertexB[faceCount] = b.vertex;\n                    faceVertexC[faceCount] = c.vertex;\n                    faceCount++;\n                }\n                for (let f = 0; f < model.texturedFaceCount; f++) {\n                    const a = addVertex(model, model.texturedVertexA[f], vertexX, vertexY, vertexZ, vertexLabel, vertexCount);\n                    vertexCount = a.vertexCount;\n                    const b = addVertex(model, model.texturedVertexB[f], vertexX, vertexY, vertexZ, vertexLabel, vertexCount);\n                    vertexCount = b.vertexCount;\n                    const c = addVertex(model, model.texturedVertexC[f], vertexX, vertexY, vertexZ, vertexLabel, vertexCount);\n                    vertexCount = c.vertexCount;\n                    texturedVertexA[texturedFaceCount] = a.vertex;\n                    texturedVertexB[texturedFaceCount] = b.vertex;\n                    texturedVertexC[texturedFaceCount] = c.vertex;\n                    texturedFaceCount++;\n                }\n            }\n        }\n        return new Model({\n            vertexCount: vertexCount,\n            vertexX: vertexX,\n            vertexY: vertexY,\n            vertexZ: vertexZ,\n            faceCount: faceCount,\n            faceVertexA: faceVertexA,\n            faceVertexB: faceVertexB,\n            faceVertexC: faceVertexC,\n            faceColorA: null,\n            faceColorB: null,\n            faceColorC: null,\n            faceInfo: faceInfo,\n            facePriority: facePriority,\n            faceAlpha: faceAlpha,\n            faceColor: faceColor,\n            priority: priority,\n            texturedFaceCount: texturedFaceCount,\n            texturedVertexA: texturedVertexA,\n            texturedVertexB: texturedVertexB,\n            texturedVertexC: texturedVertexC,\n            vertexLabel: vertexLabel,\n            faceLabel: faceLabel\n        });\n    };\n    static model = (id) => {\n        if (!Model.metadata) {\n            throw new Error('cant loading model metadata!!!!!');\n        }\n        const meta = Model.metadata[id];\n        if (!meta) {\n            console.log(`Error model:${id} not found!`);\n            throw new Error('cant loading model metadata!!!!!');\n        }\n        if (!Model.head || !Model.face1 || !Model.face2 || !Model.face3 || !Model.face4 || !Model.face5 || !Model.point1 || !Model.point2 || !Model.point3 || !Model.point4 || !Model.point5 || !Model.vertex1 || !Model.vertex2 || !Model.axis) {\n            throw new Error('cant loading model!!!!!');\n        }\n        const vertexCount = meta.vertexCount;\n        const faceCount = meta.faceCount;\n        const texturedFaceCount = meta.texturedFaceCount;\n        const vertexX = new Int32Array(vertexCount);\n        const vertexY = new Int32Array(vertexCount);\n        const vertexZ = new Int32Array(vertexCount);\n        const faceVertexA = new Int32Array(faceCount);\n        const faceVertexB = new Int32Array(faceCount);\n        const faceVertexC = new Int32Array(faceCount);\n        const texturedVertexA = new Int32Array(texturedFaceCount);\n        const texturedVertexB = new Int32Array(texturedFaceCount);\n        const texturedVertexC = new Int32Array(texturedFaceCount);\n        let vertexLabel = null;\n        if (meta.vertexLabelsOffset >= 0) {\n            vertexLabel = new Int32Array(vertexCount);\n        }\n        let faceInfo = null;\n        if (meta.faceInfosOffset >= 0) {\n            faceInfo = new Int32Array(faceCount);\n        }\n        let facePriority = null;\n        let priority = 0;\n        if (meta.facePrioritiesOffset >= 0) {\n            facePriority = new Int32Array(faceCount);\n        }\n        else {\n            priority = -meta.facePrioritiesOffset - 1;\n        }\n        let faceAlpha = null;\n        if (meta.faceAlphasOffset >= 0) {\n            faceAlpha = new Int32Array(faceCount);\n        }\n        let faceLabel = null;\n        if (meta.faceLabelsOffset >= 0) {\n            faceLabel = new Int32Array(faceCount);\n        }\n        const faceColor = new Int32Array(faceCount);\n        Model.point1.pos = meta.vertexFlagsOffset;\n        Model.point2.pos = meta.vertexXOffset;\n        Model.point3.pos = meta.vertexYOffset;\n        Model.point4.pos = meta.vertexZOffset;\n        Model.point5.pos = meta.vertexLabelsOffset;\n        let dx = 0;\n        let dy = 0;\n        let dz = 0;\n        let a;\n        let b;\n        let c;\n        for (let v = 0; v < vertexCount; v++) {\n            const flags = Model.point1.g1;\n            a = 0;\n            if ((flags & 0x1) !== 0) {\n                a = Model.point2.gsmart;\n            }\n            b = 0;\n            if ((flags & 0x2) !== 0) {\n                b = Model.point3.gsmart;\n            }\n            c = 0;\n            if ((flags & 0x4) !== 0) {\n                c = Model.point4.gsmart;\n            }\n            vertexX[v] = dx + a;\n            vertexY[v] = dy + b;\n            vertexZ[v] = dz + c;\n            dx = vertexX[v];\n            dy = vertexY[v];\n            dz = vertexZ[v];\n            if (vertexLabel) {\n                vertexLabel[v] = Model.point5.g1;\n            }\n        }\n        Model.face1.pos = meta.faceColorsOffset;\n        Model.face2.pos = meta.faceInfosOffset;\n        Model.face3.pos = meta.facePrioritiesOffset;\n        Model.face4.pos = meta.faceAlphasOffset;\n        Model.face5.pos = meta.faceLabelsOffset;\n        for (let f = 0; f < faceCount; f++) {\n            faceColor[f] = Model.face1.g2;\n            if (faceInfo) {\n                faceInfo[f] = Model.face2.g1;\n            }\n            if (facePriority) {\n                facePriority[f] = Model.face3.g1;\n            }\n            if (faceAlpha) {\n                faceAlpha[f] = Model.face4.g1;\n            }\n            if (faceLabel) {\n                faceLabel[f] = Model.face5.g1;\n            }\n        }\n        Model.vertex1.pos = meta.faceVerticesOffset;\n        Model.vertex2.pos = meta.faceOrientationsOffset;\n        a = 0;\n        b = 0;\n        c = 0;\n        let last = 0;\n        for (let f = 0; f < faceCount; f++) {\n            const orientation = Model.vertex2.g1;\n            if (orientation === 1) {\n                a = Model.vertex1.gsmart + last;\n                last = a;\n                b = Model.vertex1.gsmart + last;\n                last = b;\n                c = Model.vertex1.gsmart + last;\n                last = c;\n            }\n            else if (orientation === 2) {\n                b = c;\n                c = Model.vertex1.gsmart + last;\n                last = c;\n            }\n            else if (orientation === 3) {\n                a = c;\n                c = Model.vertex1.gsmart + last;\n                last = c;\n            }\n            else if (orientation === 4) {\n                const tmp = a;\n                a = b;\n                b = tmp;\n                c = Model.vertex1.gsmart + last;\n                last = c;\n            }\n            faceVertexA[f] = a;\n            faceVertexB[f] = b;\n            faceVertexC[f] = c;\n        }\n        Model.axis.pos = meta.faceTextureAxisOffset * 6;\n        for (let f = 0; f < texturedFaceCount; f++) {\n            texturedVertexA[f] = Model.axis.g2;\n            texturedVertexB[f] = Model.axis.g2;\n            texturedVertexC[f] = Model.axis.g2;\n        }\n        return new Model({\n            vertexCount: vertexCount,\n            vertexX: vertexX,\n            vertexY: vertexY,\n            vertexZ: vertexZ,\n            faceCount: faceCount,\n            faceVertexA: faceVertexA,\n            faceVertexB: faceVertexB,\n            faceVertexC: faceVertexC,\n            faceColorA: null,\n            faceColorB: null,\n            faceColorC: null,\n            faceInfo: faceInfo,\n            facePriority: facePriority,\n            faceAlpha: faceAlpha,\n            faceColor: faceColor,\n            priority: priority,\n            texturedFaceCount: texturedFaceCount,\n            texturedVertexA: texturedVertexA,\n            texturedVertexB: texturedVertexB,\n            texturedVertexC: texturedVertexC,\n            vertexLabel: vertexLabel,\n            faceLabel: faceLabel\n        });\n    };\n    // todo: 99% identical to above function...\n    // todo: have to pass src for now because arraybuffer is getting garbage collected\n    static model317 = (src, id) => {\n        if (!Model.metadata || !Model.metadata[id]) {\n            throw new Error('No model metadata');\n        }\n        const meta = Model.metadata[id];\n        meta.data = src; // todo: see above comment\n        if (!meta.data.length) {\n            throw new Error('No model data');\n        }\n        const vertexCount = meta.vertexCount;\n        const faceCount = meta.faceCount;\n        const texturedFaceCount = meta.texturedFaceCount;\n        const vertexX = new Int32Array(vertexCount);\n        const vertexY = new Int32Array(vertexCount);\n        const vertexZ = new Int32Array(vertexCount);\n        const faceVertexA = new Int32Array(faceCount);\n        const faceVertexB = new Int32Array(faceCount);\n        const faceVertexC = new Int32Array(faceCount);\n        const texturedVertexA = new Int32Array(texturedFaceCount);\n        const texturedVertexB = new Int32Array(texturedFaceCount);\n        const texturedVertexC = new Int32Array(texturedFaceCount);\n        let vertexLabel = null;\n        if (meta.vertexLabelsOffset >= 0) {\n            vertexLabel = new Int32Array(vertexCount);\n        }\n        let faceInfo = null;\n        if (meta.faceInfosOffset >= 0) {\n            faceInfo = new Int32Array(faceCount);\n        }\n        let facePriority = null;\n        let priority = 0;\n        if (meta.facePrioritiesOffset >= 0) {\n            facePriority = new Int32Array(faceCount);\n        }\n        else {\n            priority = -meta.facePrioritiesOffset - 1;\n        }\n        let faceAlpha = null;\n        if (meta.faceAlphasOffset >= 0) {\n            faceAlpha = new Int32Array(faceCount);\n        }\n        let faceLabel = null;\n        if (meta.faceLabelsOffset >= 0) {\n            faceLabel = new Int32Array(faceCount);\n        }\n        const faceColor = new Int32Array(faceCount);\n        const point1 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        point1.pos = meta.vertexFlagsOffset;\n        const point2 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        point2.pos = meta.vertexXOffset;\n        const point3 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        point3.pos = meta.vertexYOffset;\n        const point4 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        point4.pos = meta.vertexZOffset;\n        const point5 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        point5.pos = meta.vertexLabelsOffset;\n        let dx = 0;\n        let dy = 0;\n        let dz = 0;\n        let a;\n        let b;\n        let c;\n        for (let v = 0; v < vertexCount; v++) {\n            const flags = point1.g1;\n            a = 0;\n            if ((flags & 0x1) !== 0) {\n                a = point2.gsmart;\n            }\n            b = 0;\n            if ((flags & 0x2) !== 0) {\n                b = point3.gsmart;\n            }\n            c = 0;\n            if ((flags & 0x4) !== 0) {\n                c = point4.gsmart;\n            }\n            vertexX[v] = dx + a;\n            vertexY[v] = dy + b;\n            vertexZ[v] = dz + c;\n            dx = vertexX[v];\n            dy = vertexY[v];\n            dz = vertexZ[v];\n            if (vertexLabel) {\n                vertexLabel[v] = point5.g1;\n            }\n        }\n        const face1 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        face1.pos = meta.faceColorsOffset;\n        const face2 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        face2.pos = meta.faceInfosOffset;\n        const face3 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        face3.pos = meta.facePrioritiesOffset;\n        const face4 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        face4.pos = meta.faceAlphasOffset;\n        const face5 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        face5.pos = meta.faceLabelsOffset;\n        for (let f = 0; f < faceCount; f++) {\n            faceColor[f] = face1.g2;\n            if (faceInfo) {\n                faceInfo[f] = face2.g1;\n            }\n            if (facePriority) {\n                facePriority[f] = face3.g1;\n            }\n            if (faceAlpha) {\n                faceAlpha[f] = face4.g1;\n            }\n            if (faceLabel) {\n                faceLabel[f] = face5.g1;\n            }\n        }\n        const vertex1 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        vertex1.pos = meta.faceVerticesOffset;\n        const vertex2 = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        vertex2.pos = meta.faceOrientationsOffset;\n        a = 0;\n        b = 0;\n        c = 0;\n        let last = 0;\n        for (let f = 0; f < faceCount; f++) {\n            const orientation = vertex2.g1;\n            if (orientation === 1) {\n                a = vertex1.gsmart + last;\n                last = a;\n                b = vertex1.gsmart + last;\n                last = b;\n                c = vertex1.gsmart + last;\n                last = c;\n            }\n            else if (orientation === 2) {\n                b = c;\n                c = vertex1.gsmart + last;\n                last = c;\n            }\n            else if (orientation === 3) {\n                a = c;\n                c = vertex1.gsmart + last;\n                last = c;\n            }\n            else if (orientation === 4) {\n                const tmp = a;\n                a = b;\n                b = tmp;\n                c = vertex1.gsmart + last;\n                last = c;\n            }\n            faceVertexA[f] = a;\n            faceVertexB[f] = b;\n            faceVertexC[f] = c;\n        }\n        const axis = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](meta.data);\n        axis.pos = meta.faceTextureAxisOffset * 6;\n        for (let f = 0; f < texturedFaceCount; f++) {\n            texturedVertexA[f] = axis.g2;\n            texturedVertexB[f] = axis.g2;\n            texturedVertexC[f] = axis.g2;\n        }\n        return new Model({\n            vertexCount: vertexCount,\n            vertexX: vertexX,\n            vertexY: vertexY,\n            vertexZ: vertexZ,\n            faceCount: faceCount,\n            faceVertexA: faceVertexA,\n            faceVertexB: faceVertexB,\n            faceVertexC: faceVertexC,\n            faceColorA: null,\n            faceColorB: null,\n            faceColorC: null,\n            faceInfo: faceInfo,\n            facePriority: facePriority,\n            faceAlpha: faceAlpha,\n            faceColor: faceColor,\n            priority: priority,\n            texturedFaceCount: texturedFaceCount,\n            texturedVertexA: texturedVertexA,\n            texturedVertexB: texturedVertexB,\n            texturedVertexC: texturedVertexC,\n            vertexLabel: vertexLabel,\n            faceLabel: faceLabel\n        });\n    };\n    // ----\n    // constructor\n    vertexCount;\n    vertexX;\n    vertexY;\n    vertexZ;\n    faceCount;\n    faceVertexA;\n    faceVertexB;\n    faceVertexC;\n    faceColorA;\n    faceColorB;\n    faceColorC;\n    faceInfo;\n    facePriority;\n    faceAlpha;\n    faceColor;\n    priority;\n    texturedFaceCount;\n    texturedVertexA;\n    texturedVertexB;\n    texturedVertexC;\n    minX;\n    maxX;\n    minZ;\n    maxZ;\n    radius;\n    minY;\n    maxY;\n    maxDepth;\n    minDepth;\n    vertexLabel;\n    faceLabel;\n    labelVertices;\n    labelFaces;\n    vertexNormal;\n    vertexNormalOriginal;\n    // runtime\n    objRaise = 0;\n    pickable = false;\n    pickedFace = -1;\n    pickedFaceDepth = -1;\n    constructor(type) {\n        super();\n        this.vertexCount = type.vertexCount;\n        this.vertexX = type.vertexX;\n        this.vertexY = type.vertexY;\n        this.vertexZ = type.vertexZ;\n        this.faceCount = type.faceCount;\n        this.faceVertexA = type.faceVertexA;\n        this.faceVertexB = type.faceVertexB;\n        this.faceVertexC = type.faceVertexC;\n        this.faceColorA = type.faceColorA;\n        this.faceColorB = type.faceColorB;\n        this.faceColorC = type.faceColorC;\n        this.faceInfo = type.faceInfo;\n        this.facePriority = type.facePriority;\n        this.faceAlpha = type.faceAlpha;\n        this.faceColor = type.faceColor;\n        this.priority = type.priority;\n        this.texturedFaceCount = type.texturedFaceCount;\n        this.texturedVertexA = type.texturedVertexA;\n        this.texturedVertexB = type.texturedVertexB;\n        this.texturedVertexC = type.texturedVertexC;\n        this.minX = type.minX ?? 0;\n        this.maxX = type.maxX ?? 0;\n        this.minZ = type.minZ ?? 0;\n        this.maxZ = type.maxZ ?? 0;\n        this.radius = type.radius ?? 0;\n        this.minY = type.minY ?? 0;\n        this.maxY = type.maxY ?? 0;\n        this.maxDepth = type.maxDepth ?? 0;\n        this.minDepth = type.minDepth ?? 0;\n        this.vertexLabel = type.vertexLabel ?? null;\n        this.faceLabel = type.faceLabel ?? null;\n        this.labelVertices = type.labelVertices ?? null;\n        this.labelFaces = type.labelFaces ?? null;\n        this.vertexNormal = type.vertexNormal ?? null;\n        this.vertexNormalOriginal = type.vertexNormalOriginal ?? null;\n    }\n    calculateBoundsCylinder() {\n        this.maxY = 0;\n        this.radius = 0;\n        this.minY = 0;\n        for (let i = 0; i < this.vertexCount; i++) {\n            const x = this.vertexX[i];\n            const y = this.vertexY[i];\n            const z = this.vertexZ[i];\n            if (-y > this.maxY) {\n                this.maxY = -y;\n            }\n            if (y > this.minY) {\n                this.minY = y;\n            }\n            const radiusSqr = x * x + z * z;\n            if (radiusSqr > this.radius) {\n                this.radius = radiusSqr;\n            }\n        }\n        this.radius = (Math.sqrt(this.radius) + 0.99) | 0;\n        this.minDepth = (Math.sqrt(this.radius * this.radius + this.maxY * this.maxY) + 0.99) | 0;\n        this.maxDepth = this.minDepth + ((Math.sqrt(this.radius * this.radius + this.minY * this.minY) + 0.99) | 0);\n    }\n    calculateBoundsY() {\n        this.maxY = 0;\n        this.minY = 0;\n        for (let v = 0; v < this.vertexCount; v++) {\n            const y = this.vertexY[v];\n            if (-y > this.maxY) {\n                this.maxY = -y;\n            }\n            if (y > this.minY) {\n                this.minY = y;\n            }\n        }\n        this.minDepth = (Math.sqrt(this.radius * this.radius + this.maxY * this.maxY) + 0.99) | 0;\n        this.maxDepth = this.minDepth + ((Math.sqrt(this.radius * this.radius + this.minY * this.minY) + 0.99) | 0);\n    }\n    createLabelReferences() {\n        if (this.vertexLabel) {\n            const labelVertexCount = new Int32Array(256);\n            let count = 0;\n            for (let v = 0; v < this.vertexCount; v++) {\n                const label = this.vertexLabel[v];\n                // const countDebug: number = labelVertexCount[label]++; // dead var\n                labelVertexCount[label]++;\n                if (label > count) {\n                    count = label;\n                }\n            }\n            this.labelVertices = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(count + 1, null);\n            for (let label = 0; label <= count; label++) {\n                this.labelVertices[label] = new Int32Array(labelVertexCount[label]);\n                labelVertexCount[label] = 0;\n            }\n            let v = 0;\n            while (v < this.vertexCount) {\n                const label = this.vertexLabel[v];\n                const verts = this.labelVertices[label];\n                if (!verts) {\n                    continue;\n                }\n                verts[labelVertexCount[label]++] = v++;\n            }\n            this.vertexLabel = null;\n        }\n        if (this.faceLabel) {\n            const labelFaceCount = new Int32Array(256);\n            let count = 0;\n            for (let f = 0; f < this.faceCount; f++) {\n                const label = this.faceLabel[f];\n                // const countDebug: number = labelFaceCount[label]++; // dead var\n                labelFaceCount[label]++;\n                if (label > count) {\n                    count = label;\n                }\n            }\n            this.labelFaces = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(count + 1, null);\n            for (let label = 0; label <= count; label++) {\n                this.labelFaces[label] = new Int32Array(labelFaceCount[label]);\n                labelFaceCount[label] = 0;\n            }\n            let face = 0;\n            while (face < this.faceCount) {\n                const label = this.faceLabel[face];\n                const faces = this.labelFaces[label];\n                if (!faces) {\n                    continue;\n                }\n                faces[labelFaceCount[label]++] = face++;\n            }\n            this.faceLabel = null;\n        }\n    }\n    applyTransforms(primaryId, secondaryId, mask) {\n        if (primaryId === -1) {\n            return;\n        }\n        if (!mask || secondaryId === -1) {\n            this.applyTransform(primaryId);\n        }\n        else {\n            const primary = _AnimFrame__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[primaryId];\n            const secondary = _AnimFrame__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[secondaryId];\n            const skeleton = primary.base;\n            Model.baseX = 0;\n            Model.baseY = 0;\n            Model.baseZ = 0;\n            let counter = 0;\n            let maskBase = mask[counter++];\n            for (let i = 0; i < primary.length; i++) {\n                if (!primary.bases) {\n                    continue;\n                }\n                const base = primary.bases[i];\n                while (base > maskBase) {\n                    maskBase = mask[counter++];\n                }\n                if (skeleton && skeleton.types && primary.x && primary.y && primary.z && skeleton.labels && (base !== maskBase || skeleton.types[base] === 0)) {\n                    this.applyTransform2(primary.x[i], primary.y[i], primary.z[i], skeleton.labels[base], skeleton.types[base]);\n                }\n            }\n            Model.baseX = 0;\n            Model.baseY = 0;\n            Model.baseZ = 0;\n            counter = 0;\n            maskBase = mask[counter++];\n            for (let i = 0; i < secondary.length; i++) {\n                if (!secondary.bases) {\n                    continue;\n                }\n                const base = secondary.bases[i];\n                while (base > maskBase) {\n                    maskBase = mask[counter++];\n                }\n                if (skeleton && skeleton.types && secondary.x && secondary.y && secondary.z && skeleton.labels && (base === maskBase || skeleton.types[base] === 0)) {\n                    this.applyTransform2(secondary.x[i], secondary.y[i], secondary.z[i], skeleton.labels[base], skeleton.types[base]);\n                }\n            }\n        }\n    }\n    applyTransform(id) {\n        if (!this.labelVertices || id === -1 || !_AnimFrame__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[id]) {\n            return;\n        }\n        const transform = _AnimFrame__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instances[id];\n        const skeleton = transform.base;\n        Model.baseX = 0;\n        Model.baseY = 0;\n        Model.baseZ = 0;\n        for (let i = 0; i < transform.length; i++) {\n            if (!transform.bases || !transform.x || !transform.y || !transform.z || !skeleton || !skeleton.labels || !skeleton.types) {\n                continue;\n            }\n            const base = transform.bases[i];\n            this.applyTransform2(transform.x[i], transform.y[i], transform.z[i], skeleton.labels[base], skeleton.types[base]);\n        }\n    }\n    rotateY90() {\n        for (let v = 0; v < this.vertexCount; v++) {\n            const tmp = this.vertexX[v];\n            this.vertexX[v] = this.vertexZ[v];\n            this.vertexZ[v] = -tmp;\n        }\n    }\n    rotateX(angle) {\n        const sin = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[angle];\n        const cos = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[angle];\n        for (let v = 0; v < this.vertexCount; v++) {\n            const tmp = (this.vertexY[v] * cos - this.vertexZ[v] * sin) >> 16;\n            this.vertexZ[v] = (this.vertexY[v] * sin + this.vertexZ[v] * cos) >> 16;\n            this.vertexY[v] = tmp;\n        }\n    }\n    translate(y, x, z) {\n        for (let v = 0; v < this.vertexCount; v++) {\n            this.vertexX[v] += x;\n            this.vertexY[v] += y;\n            this.vertexZ[v] += z;\n        }\n    }\n    recolor(src, dst) {\n        if (!this.faceColor) {\n            return;\n        }\n        for (let f = 0; f < this.faceCount; f++) {\n            if (this.faceColor[f] === src) {\n                this.faceColor[f] = dst;\n            }\n        }\n    }\n    rotateY180() {\n        for (let v = 0; v < this.vertexCount; v++) {\n            this.vertexZ[v] = -this.vertexZ[v];\n        }\n        for (let f = 0; f < this.faceCount; f++) {\n            const temp = this.faceVertexA[f];\n            this.faceVertexA[f] = this.faceVertexC[f];\n            this.faceVertexC[f] = temp;\n        }\n    }\n    scale(x, y, z) {\n        for (let v = 0; v < this.vertexCount; v++) {\n            this.vertexX[v] = ((this.vertexX[v] * x) / 128) | 0;\n            this.vertexY[v] = ((this.vertexY[v] * y) / 128) | 0;\n            this.vertexZ[v] = ((this.vertexZ[v] * z) / 128) | 0;\n        }\n    }\n    calculateNormals(lightAmbient, lightAttenuation, lightSrcX, lightSrcY, lightSrcZ, applyLighting) {\n        const lightMagnitude = Math.sqrt(lightSrcX * lightSrcX + lightSrcY * lightSrcY + lightSrcZ * lightSrcZ) | 0;\n        const attenuation = (lightAttenuation * lightMagnitude) >> 8;\n        if (!this.faceColorA || !this.faceColorB || !this.faceColorC) {\n            this.faceColorA = new Int32Array(this.faceCount);\n            this.faceColorB = new Int32Array(this.faceCount);\n            this.faceColorC = new Int32Array(this.faceCount);\n        }\n        if (!this.vertexNormal) {\n            this.vertexNormal = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(this.vertexCount, null);\n            for (let v = 0; v < this.vertexCount; v++) {\n                this.vertexNormal[v] = new VertexNormal();\n            }\n        }\n        for (let f = 0; f < this.faceCount; f++) {\n            const a = this.faceVertexA[f];\n            const b = this.faceVertexB[f];\n            const c = this.faceVertexC[f];\n            const dxAB = this.vertexX[b] - this.vertexX[a];\n            const dyAB = this.vertexY[b] - this.vertexY[a];\n            const dzAB = this.vertexZ[b] - this.vertexZ[a];\n            const dxAC = this.vertexX[c] - this.vertexX[a];\n            const dyAC = this.vertexY[c] - this.vertexY[a];\n            const dzAC = this.vertexZ[c] - this.vertexZ[a];\n            let nx = dyAB * dzAC - dyAC * dzAB;\n            let ny = dzAB * dxAC - dzAC * dxAB;\n            let nz = dxAB * dyAC - dxAC * dyAB;\n            while (nx > 8192 || ny > 8192 || nz > 8192 || nx < -8192 || ny < -8192 || nz < -8192) {\n                nx >>= 1;\n                ny >>= 1;\n                nz >>= 1;\n            }\n            let length = Math.sqrt(nx * nx + ny * ny + nz * nz) | 0;\n            if (length <= 0) {\n                length = 1;\n            }\n            nx = ((nx * 256) / length) | 0;\n            ny = ((ny * 256) / length) | 0;\n            nz = ((nz * 256) / length) | 0;\n            if (!this.faceInfo || (this.faceInfo[f] & 0x1) === 0) {\n                let n = this.vertexNormal[a];\n                if (n) {\n                    n.x += nx;\n                    n.y += ny;\n                    n.z += nz;\n                    n.w++;\n                }\n                n = this.vertexNormal[b];\n                if (n) {\n                    n.x += nx;\n                    n.y += ny;\n                    n.z += nz;\n                    n.w++;\n                }\n                n = this.vertexNormal[c];\n                if (n) {\n                    n.x += nx;\n                    n.y += ny;\n                    n.z += nz;\n                    n.w++;\n                }\n            }\n            else {\n                const lightness = lightAmbient + (((lightSrcX * nx + lightSrcY * ny + lightSrcZ * nz) / (attenuation + ((attenuation / 2) | 0))) | 0);\n                if (this.faceColor) {\n                    this.faceColorA[f] = Model.mulColorLightness(this.faceColor[f], lightness, this.faceInfo[f]);\n                }\n            }\n        }\n        if (applyLighting) {\n            this.applyLighting(lightAmbient, attenuation, lightSrcX, lightSrcY, lightSrcZ);\n        }\n        else {\n            this.vertexNormalOriginal = new _util_Arrays__WEBPACK_IMPORTED_MODULE_5__.TypedArray1d(this.vertexCount, null);\n            for (let v = 0; v < this.vertexCount; v++) {\n                const normal = this.vertexNormal[v];\n                const copy = new VertexNormal();\n                if (normal) {\n                    copy.x = normal.x;\n                    copy.y = normal.y;\n                    copy.z = normal.z;\n                    copy.w = normal.w;\n                }\n                this.vertexNormalOriginal[v] = copy;\n            }\n        }\n        if (applyLighting) {\n            this.calculateBoundsCylinder();\n        }\n        else {\n            this.calculateBoundsAABB();\n        }\n    }\n    applyLighting(lightAmbient, lightAttenuation, lightSrcX, lightSrcY, lightSrcZ) {\n        for (let f = 0; f < this.faceCount; f++) {\n            const a = this.faceVertexA[f];\n            const b = this.faceVertexB[f];\n            const c = this.faceVertexC[f];\n            if (!this.faceInfo && this.faceColor && this.vertexNormal && this.faceColorA && this.faceColorB && this.faceColorC) {\n                const color = this.faceColor[f];\n                const va = this.vertexNormal[a];\n                if (va) {\n                    this.faceColorA[f] = Model.mulColorLightness(color, lightAmbient + (((lightSrcX * va.x + lightSrcY * va.y + lightSrcZ * va.z) / (lightAttenuation * va.w)) | 0), 0);\n                }\n                const vb = this.vertexNormal[b];\n                if (vb) {\n                    this.faceColorB[f] = Model.mulColorLightness(color, lightAmbient + (((lightSrcX * vb.x + lightSrcY * vb.y + lightSrcZ * vb.z) / (lightAttenuation * vb.w)) | 0), 0);\n                }\n                const vc = this.vertexNormal[c];\n                if (vc) {\n                    this.faceColorC[f] = Model.mulColorLightness(color, lightAmbient + (((lightSrcX * vc.x + lightSrcY * vc.y + lightSrcZ * vc.z) / (lightAttenuation * vc.w)) | 0), 0);\n                }\n            }\n            else if (this.faceInfo && (this.faceInfo[f] & 0x1) === 0 && this.faceColor && this.vertexNormal && this.faceColorA && this.faceColorB && this.faceColorC) {\n                const color = this.faceColor[f];\n                const info = this.faceInfo[f];\n                const va = this.vertexNormal[a];\n                if (va) {\n                    this.faceColorA[f] = Model.mulColorLightness(color, lightAmbient + (((lightSrcX * va.x + lightSrcY * va.y + lightSrcZ * va.z) / (lightAttenuation * va.w)) | 0), info);\n                }\n                const vb = this.vertexNormal[b];\n                if (vb) {\n                    this.faceColorB[f] = Model.mulColorLightness(color, lightAmbient + (((lightSrcX * vb.x + lightSrcY * vb.y + lightSrcZ * vb.z) / (lightAttenuation * vb.w)) | 0), info);\n                }\n                const vc = this.vertexNormal[c];\n                if (vc) {\n                    this.faceColorC[f] = Model.mulColorLightness(color, lightAmbient + (((lightSrcX * vc.x + lightSrcY * vc.y + lightSrcZ * vc.z) / (lightAttenuation * vc.w)) | 0), info);\n                }\n            }\n        }\n        this.vertexNormal = null;\n        this.vertexNormalOriginal = null;\n        this.vertexLabel = null;\n        this.faceLabel = null;\n        if (this.faceInfo) {\n            for (let f = 0; f < this.faceCount; f++) {\n                if ((this.faceInfo[f] & 0x2) === 2) {\n                    return;\n                }\n            }\n        }\n        this.faceColor = null;\n    }\n    // todo: better name, Java relies on overloads\n    // this function is NOT near-clipped (helps with performance) so be careful how you use it!\n    drawSimple(pitch, yaw, roll, eyePitch, eyeX, eyeY, eyeZ) {\n        const sinPitch = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[pitch];\n        const cosPitch = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[pitch];\n        const sinYaw = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[yaw];\n        const cosYaw = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[yaw];\n        const sinRoll = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[roll];\n        const cosRoll = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[roll];\n        const sinEyePitch = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[eyePitch];\n        const cosEyePitch = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[eyePitch];\n        const midZ = (eyeY * sinEyePitch + eyeZ * cosEyePitch) >> 16;\n        for (let v = 0; v < this.vertexCount; v++) {\n            let x = this.vertexX[v];\n            let y = this.vertexY[v];\n            let z = this.vertexZ[v];\n            let tmp;\n            if (roll !== 0) {\n                tmp = (y * sinRoll + x * cosRoll) >> 16;\n                y = (y * cosRoll - x * sinRoll) >> 16;\n                x = tmp;\n            }\n            if (pitch !== 0) {\n                tmp = (y * cosPitch - z * sinPitch) >> 16;\n                z = (y * sinPitch + z * cosPitch) >> 16;\n                y = tmp;\n            }\n            if (yaw !== 0) {\n                tmp = (z * sinYaw + x * cosYaw) >> 16;\n                z = (z * cosYaw - x * sinYaw) >> 16;\n                x = tmp;\n            }\n            x += eyeX;\n            y += eyeY;\n            z += eyeZ;\n            tmp = (y * cosEyePitch - z * sinEyePitch) >> 16;\n            z = (y * sinEyePitch + z * cosEyePitch) >> 16;\n            y = tmp;\n            if (Model.vertexScreenX && Model.vertexScreenY && Model.vertexScreenZ) {\n                Model.vertexScreenZ[v] = z - midZ;\n                Model.vertexScreenX[v] = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerX + (((x << 9) / z) | 0);\n                Model.vertexScreenY[v] = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerY + (((y << 9) / z) | 0);\n            }\n            if (this.texturedFaceCount > 0 && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n                Model.vertexViewSpaceX[v] = x;\n                Model.vertexViewSpaceY[v] = y;\n                Model.vertexViewSpaceZ[v] = z;\n            }\n        }\n        try {\n            // try catch for example a model being drawn from 3d can crash like at baxtorian falls\n            this.draw2(false, false, 0);\n        }\n        catch (err) {\n            /* empty */\n        }\n    }\n    // todo: better name, Java relies on overloads\n    draw(yaw, sinEyePitch, cosEyePitch, sinEyeYaw, cosEyeYaw, relativeX, relativeY, relativeZ, bitset) {\n        const zPrime = (relativeZ * cosEyeYaw - relativeX * sinEyeYaw) >> 16;\n        const midZ = (relativeY * sinEyePitch + zPrime * cosEyePitch) >> 16;\n        const radiusCosEyePitch = (this.radius * cosEyePitch) >> 16;\n        const maxZ = midZ + radiusCosEyePitch;\n        if (maxZ <= 50 || midZ >= 3500) {\n            return;\n        }\n        const midX = (relativeZ * sinEyeYaw + relativeX * cosEyeYaw) >> 16;\n        let leftX = (midX - this.radius) << 9;\n        if (((leftX / maxZ) | 0) >= _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerX2d) {\n            return;\n        }\n        let rightX = (midX + this.radius) << 9;\n        if (((rightX / maxZ) | 0) <= -_Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerX2d) {\n            return;\n        }\n        const midY = (relativeY * cosEyePitch - zPrime * sinEyePitch) >> 16;\n        const radiusSinEyePitch = (this.radius * sinEyePitch) >> 16;\n        let bottomY = (midY + radiusSinEyePitch) << 9;\n        if (((bottomY / maxZ) | 0) <= -_Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerY2d) {\n            return;\n        }\n        const yPrime = radiusSinEyePitch + ((this.maxY * cosEyePitch) >> 16);\n        let topY = (midY - yPrime) << 9;\n        if (((topY / maxZ) | 0) >= _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].centerY2d) {\n            return;\n        }\n        const radiusZ = radiusCosEyePitch + ((this.maxY * sinEyePitch) >> 16);\n        let clipped = midZ - radiusZ <= 50;\n        let picking = false;\n        if (bitset > 0 && Model.checkHover) {\n            let z = midZ - radiusCosEyePitch;\n            if (z <= 50) {\n                z = 50;\n            }\n            if (midX > 0) {\n                leftX = (leftX / maxZ) | 0;\n                rightX = (rightX / z) | 0;\n            }\n            else {\n                rightX = (rightX / maxZ) | 0;\n                leftX = (leftX / z) | 0;\n            }\n            if (midY > 0) {\n                topY = (topY / maxZ) | 0;\n                bottomY = (bottomY / z) | 0;\n            }\n            else {\n                bottomY = (bottomY / maxZ) | 0;\n                topY = (topY / z) | 0;\n            }\n            const mouseX = Model.mouseX - _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerX;\n            const mouseY = Model.mouseY - _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerY;\n            if (mouseX > leftX && mouseX < rightX && mouseY > topY && mouseY < bottomY) {\n                if (this.pickable) {\n                    Model.pickedBitsets[Model.pickedCount++] = bitset;\n                }\n                else {\n                    picking = true;\n                }\n            }\n        }\n        const centerX = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerX;\n        const centerY = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerY;\n        let sinYaw = 0;\n        let cosYaw = 0;\n        if (yaw !== 0) {\n            sinYaw = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[yaw];\n            cosYaw = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[yaw];\n        }\n        for (let v = 0; v < this.vertexCount; v++) {\n            let x = this.vertexX[v];\n            let y = this.vertexY[v];\n            let z = this.vertexZ[v];\n            let temp;\n            if (yaw !== 0) {\n                temp = (z * sinYaw + x * cosYaw) >> 16;\n                z = (z * cosYaw - x * sinYaw) >> 16;\n                x = temp;\n            }\n            x += relativeX;\n            y += relativeY;\n            z += relativeZ;\n            temp = (z * sinEyeYaw + x * cosEyeYaw) >> 16;\n            z = (z * cosEyeYaw - x * sinEyeYaw) >> 16;\n            x = temp;\n            temp = (y * cosEyePitch - z * sinEyePitch) >> 16;\n            z = (y * sinEyePitch + z * cosEyePitch) >> 16;\n            y = temp;\n            if (Model.vertexScreenZ) {\n                Model.vertexScreenZ[v] = z - midZ;\n            }\n            if (z >= 50 && Model.vertexScreenX && Model.vertexScreenY) {\n                Model.vertexScreenX[v] = centerX + (((x << 9) / z) | 0);\n                Model.vertexScreenY[v] = centerY + (((y << 9) / z) | 0);\n            }\n            else if (Model.vertexScreenX) {\n                Model.vertexScreenX[v] = -5000;\n                clipped = true;\n            }\n            if ((clipped || this.texturedFaceCount > 0) && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n                Model.vertexViewSpaceX[v] = x;\n                Model.vertexViewSpaceY[v] = y;\n                Model.vertexViewSpaceZ[v] = z;\n            }\n        }\n        try {\n            // try catch for example a model being drawn from 3d can crash like at baxtorian falls\n            this.draw2(clipped, picking, bitset);\n        }\n        catch (err) {\n            /* empty */\n        }\n    }\n    // todo: better name, Java relies on overloads\n    draw2(clipped, picking, bitset, wireframe = false) {\n        if (Model.checkHoverFace) {\n            this.pickedFace = -1;\n            this.pickedFaceDepth = -1;\n        }\n        for (let depth = 0; depth < this.maxDepth; depth++) {\n            if (Model.tmpDepthFaceCount) {\n                Model.tmpDepthFaceCount[depth] = 0;\n            }\n        }\n        for (let f = 0; f < this.faceCount; f++) {\n            if (this.faceInfo && this.faceInfo[f] === -1) {\n                continue;\n            }\n            if (Model.vertexScreenX && Model.vertexScreenY && Model.vertexScreenZ && Model.tmpDepthFaces && Model.tmpDepthFaceCount) {\n                const a = this.faceVertexA[f];\n                const b = this.faceVertexB[f];\n                const c = this.faceVertexC[f];\n                const xA = Model.vertexScreenX[a];\n                const xB = Model.vertexScreenX[b];\n                const xC = Model.vertexScreenX[c];\n                const yA = Model.vertexScreenY[a];\n                const yB = Model.vertexScreenY[b];\n                const yC = Model.vertexScreenY[c];\n                const zA = Model.vertexScreenZ[a];\n                const zB = Model.vertexScreenZ[b];\n                const zC = Model.vertexScreenZ[c];\n                if (clipped && (xA === -5000 || xB === -5000 || xC === -5000)) {\n                    if (Model.faceNearClipped) {\n                        Model.faceNearClipped[f] = true;\n                    }\n                    if (Model.tmpDepthFaces && Model.tmpDepthFaceCount) {\n                        const depthAverage = (((zA + zB + zC) / 3) | 0) + this.minDepth;\n                        Model.tmpDepthFaces[depthAverage][Model.tmpDepthFaceCount[depthAverage]++] = f;\n                    }\n                }\n                else {\n                    if (picking && this.pointWithinTriangle(Model.mouseX, Model.mouseY, yA, yB, yC, xA, xB, xC)) {\n                        Model.pickedBitsets[Model.pickedCount++] = bitset;\n                        picking = false;\n                    }\n                    const dxAB = xA - xB;\n                    const dyAB = yA - yB;\n                    const dxCB = xC - xB;\n                    const dyCB = yC - yB;\n                    if (dxAB * dyCB - dyAB * dxCB <= 0) {\n                        continue;\n                    }\n                    if (Model.faceNearClipped) {\n                        Model.faceNearClipped[f] = false;\n                    }\n                    if (Model.faceClippedX) {\n                        Model.faceClippedX[f] = xA < 0 || xB < 0 || xC < 0 || xA > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX || xB > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX || xC > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX;\n                    }\n                    if (Model.tmpDepthFaces && Model.tmpDepthFaceCount) {\n                        const depthAverage = (((zA + zB + zC) / 3) | 0) + this.minDepth;\n                        Model.tmpDepthFaces[depthAverage][Model.tmpDepthFaceCount[depthAverage]++] = f;\n                        // todo: better check (depth avg isn't always accurate)\n                        if (Model.checkHoverFace && this.pointWithinTriangle(Model.mouseX, Model.mouseY, yA, yB, yC, xA, xB, xC) && this.pickedFaceDepth < depthAverage) {\n                            this.pickedFace = f;\n                            this.pickedFaceDepth = depthAverage;\n                        }\n                    }\n                }\n            }\n        }\n        if (!this.facePriority && Model.tmpDepthFaceCount) {\n            for (let depth = this.maxDepth - 1; depth >= 0; depth--) {\n                const count = Model.tmpDepthFaceCount[depth];\n                if (count <= 0) {\n                    continue;\n                }\n                if (Model.tmpDepthFaces) {\n                    const faces = Model.tmpDepthFaces[depth];\n                    for (let f = 0; f < count; f++) {\n                        this.drawFace(faces[f], wireframe);\n                    }\n                }\n            }\n            return;\n        }\n        for (let priority = 0; priority < 12; priority++) {\n            if (Model.tmpPriorityFaceCount && Model.tmpPriorityDepthSum) {\n                Model.tmpPriorityFaceCount[priority] = 0;\n                Model.tmpPriorityDepthSum[priority] = 0;\n            }\n        }\n        if (Model.tmpDepthFaceCount) {\n            for (let depth = this.maxDepth - 1; depth >= 0; depth--) {\n                const faceCount = Model.tmpDepthFaceCount[depth];\n                if (faceCount > 0 && Model.tmpDepthFaces) {\n                    const faces = Model.tmpDepthFaces[depth];\n                    for (let i = 0; i < faceCount; i++) {\n                        if (this.facePriority && Model.tmpPriorityFaceCount && Model.tmpPriorityFaces) {\n                            const priorityDepth = faces[i];\n                            const priorityFace = this.facePriority[priorityDepth];\n                            const priorityFaceCount = Model.tmpPriorityFaceCount[priorityFace]++;\n                            Model.tmpPriorityFaces[priorityFace][priorityFaceCount] = priorityDepth;\n                            if (priorityFace < 10 && Model.tmpPriorityDepthSum) {\n                                Model.tmpPriorityDepthSum[priorityFace] += depth;\n                            }\n                            else if (priorityFace === 10 && Model.tmpPriority10FaceDepth) {\n                                Model.tmpPriority10FaceDepth[priorityFaceCount] = depth;\n                            }\n                            else if (Model.tmpPriority11FaceDepth) {\n                                Model.tmpPriority11FaceDepth[priorityFaceCount] = depth;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        let averagePriorityDepthSum1_2 = 0;\n        if (Model.tmpPriorityFaceCount && Model.tmpPriorityDepthSum && (Model.tmpPriorityFaceCount[1] > 0 || Model.tmpPriorityFaceCount[2] > 0)) {\n            averagePriorityDepthSum1_2 = ((Model.tmpPriorityDepthSum[1] + Model.tmpPriorityDepthSum[2]) / (Model.tmpPriorityFaceCount[1] + Model.tmpPriorityFaceCount[2])) | 0;\n        }\n        let averagePriorityDepthSum3_4 = 0;\n        if (Model.tmpPriorityFaceCount && Model.tmpPriorityDepthSum && (Model.tmpPriorityFaceCount[3] > 0 || Model.tmpPriorityFaceCount[4] > 0)) {\n            averagePriorityDepthSum3_4 = ((Model.tmpPriorityDepthSum[3] + Model.tmpPriorityDepthSum[4]) / (Model.tmpPriorityFaceCount[3] + Model.tmpPriorityFaceCount[4])) | 0;\n        }\n        let averagePriorityDepthSum6_8 = 0;\n        if (Model.tmpPriorityFaceCount && Model.tmpPriorityDepthSum && (Model.tmpPriorityFaceCount[6] > 0 || Model.tmpPriorityFaceCount[8] > 0)) {\n            averagePriorityDepthSum6_8 = ((Model.tmpPriorityDepthSum[6] + Model.tmpPriorityDepthSum[8]) / (Model.tmpPriorityFaceCount[6] + Model.tmpPriorityFaceCount[8])) | 0;\n        }\n        if (Model.tmpPriorityFaceCount && Model.tmpPriorityFaces) {\n            let priorityFace = 0;\n            let priorityFaceCount = Model.tmpPriorityFaceCount[10];\n            let priorityFaces = Model.tmpPriorityFaces[10];\n            let priorityFaceDepths = Model.tmpPriority10FaceDepth;\n            if (priorityFace === priorityFaceCount) {\n                priorityFace = 0;\n                priorityFaceCount = Model.tmpPriorityFaceCount[11];\n                priorityFaces = Model.tmpPriorityFaces[11];\n                priorityFaceDepths = Model.tmpPriority11FaceDepth;\n            }\n            let priorityDepth;\n            if (priorityFace < priorityFaceCount && priorityFaceDepths) {\n                priorityDepth = priorityFaceDepths[priorityFace];\n            }\n            else {\n                priorityDepth = -1000;\n            }\n            for (let priority = 0; priority < 10; priority++) {\n                while (priority === 0 && priorityDepth > averagePriorityDepthSum1_2) {\n                    this.drawFace(priorityFaces[priorityFace++], wireframe);\n                    if (priorityFace === priorityFaceCount && priorityFaces !== Model.tmpPriorityFaces[11]) {\n                        priorityFace = 0;\n                        priorityFaceCount = Model.tmpPriorityFaceCount[11];\n                        priorityFaces = Model.tmpPriorityFaces[11];\n                        priorityFaceDepths = Model.tmpPriority11FaceDepth;\n                    }\n                    if (priorityFace < priorityFaceCount && priorityFaceDepths) {\n                        priorityDepth = priorityFaceDepths[priorityFace];\n                    }\n                    else {\n                        priorityDepth = -1000;\n                    }\n                }\n                while (priority === 3 && priorityDepth > averagePriorityDepthSum3_4) {\n                    this.drawFace(priorityFaces[priorityFace++], wireframe);\n                    if (priorityFace === priorityFaceCount && priorityFaces !== Model.tmpPriorityFaces[11]) {\n                        priorityFace = 0;\n                        priorityFaceCount = Model.tmpPriorityFaceCount[11];\n                        priorityFaces = Model.tmpPriorityFaces[11];\n                        priorityFaceDepths = Model.tmpPriority11FaceDepth;\n                    }\n                    if (priorityFace < priorityFaceCount && priorityFaceDepths) {\n                        priorityDepth = priorityFaceDepths[priorityFace];\n                    }\n                    else {\n                        priorityDepth = -1000;\n                    }\n                }\n                while (priority === 5 && priorityDepth > averagePriorityDepthSum6_8) {\n                    this.drawFace(priorityFaces[priorityFace++], wireframe);\n                    if (priorityFace === priorityFaceCount && priorityFaces !== Model.tmpPriorityFaces[11]) {\n                        priorityFace = 0;\n                        priorityFaceCount = Model.tmpPriorityFaceCount[11];\n                        priorityFaces = Model.tmpPriorityFaces[11];\n                        priorityFaceDepths = Model.tmpPriority11FaceDepth;\n                    }\n                    if (priorityFace < priorityFaceCount && priorityFaceDepths) {\n                        priorityDepth = priorityFaceDepths[priorityFace];\n                    }\n                    else {\n                        priorityDepth = -1000;\n                    }\n                }\n                const count = Model.tmpPriorityFaceCount[priority];\n                const faces = Model.tmpPriorityFaces[priority];\n                for (let i = 0; i < count; i++) {\n                    this.drawFace(faces[i], wireframe);\n                }\n            }\n            while (priorityDepth !== -1000) {\n                this.drawFace(priorityFaces[priorityFace++], wireframe);\n                if (priorityFace === priorityFaceCount && priorityFaces !== Model.tmpPriorityFaces[11]) {\n                    priorityFace = 0;\n                    priorityFaces = Model.tmpPriorityFaces[11];\n                    priorityFaceCount = Model.tmpPriorityFaceCount[11];\n                    priorityFaceDepths = Model.tmpPriority11FaceDepth;\n                }\n                if (priorityFace < priorityFaceCount && priorityFaceDepths) {\n                    priorityDepth = priorityFaceDepths[priorityFace];\n                }\n                else {\n                    priorityDepth = -1000;\n                }\n            }\n        }\n    }\n    drawFace(face, wireframe = false) {\n        if (Model.faceNearClipped && Model.faceNearClipped[face]) {\n            this.drawNearClippedFace(face, wireframe);\n            return;\n        }\n        const a = this.faceVertexA[face];\n        const b = this.faceVertexB[face];\n        const c = this.faceVertexC[face];\n        if (Model.faceClippedX) {\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clipX = Model.faceClippedX[face];\n        }\n        if (!this.faceAlpha) {\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].alpha = 0;\n        }\n        else {\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].alpha = this.faceAlpha[face];\n        }\n        let type;\n        if (!this.faceInfo) {\n            type = 0;\n        }\n        else {\n            type = this.faceInfo[face] & 0x3;\n        }\n        if (wireframe && Model.vertexScreenX && Model.vertexScreenY && this.faceColorA && this.faceColorB && this.faceColorC) {\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(Model.vertexScreenX[a], Model.vertexScreenY[a], Model.vertexScreenX[b], Model.vertexScreenY[b], _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[this.faceColorA[face]]);\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(Model.vertexScreenX[b], Model.vertexScreenY[b], Model.vertexScreenX[c], Model.vertexScreenY[c], _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[this.faceColorB[face]]);\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(Model.vertexScreenX[c], Model.vertexScreenY[c], Model.vertexScreenX[a], Model.vertexScreenY[a], _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[this.faceColorC[face]]);\n        }\n        else if (type === 0 && this.faceColorA && this.faceColorB && this.faceColorC && Model.vertexScreenX && Model.vertexScreenY) {\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillGouraudTriangle(Model.vertexScreenX[a], Model.vertexScreenX[b], Model.vertexScreenX[c], Model.vertexScreenY[a], Model.vertexScreenY[b], Model.vertexScreenY[c], this.faceColorA[face], this.faceColorB[face], this.faceColorC[face]);\n        }\n        else if (type === 1 && this.faceColorA && Model.vertexScreenX && Model.vertexScreenY) {\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTriangle(Model.vertexScreenX[a], Model.vertexScreenX[b], Model.vertexScreenX[c], Model.vertexScreenY[a], Model.vertexScreenY[b], Model.vertexScreenY[c], _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[this.faceColorA[face]]);\n        }\n        else if (type === 2 && this.faceInfo && this.faceColor && this.faceColorA && this.faceColorB && this.faceColorC && Model.vertexScreenX && Model.vertexScreenY && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n            const texturedFace = this.faceInfo[face] >> 2;\n            const tA = this.texturedVertexA[texturedFace];\n            const tB = this.texturedVertexB[texturedFace];\n            const tC = this.texturedVertexC[texturedFace];\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(Model.vertexScreenX[a], Model.vertexScreenX[b], Model.vertexScreenX[c], Model.vertexScreenY[a], Model.vertexScreenY[b], Model.vertexScreenY[c], this.faceColorA[face], this.faceColorB[face], this.faceColorC[face], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n        }\n        else if (type === 3 && this.faceInfo && this.faceColor && this.faceColorA && Model.vertexScreenX && Model.vertexScreenY && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n            const texturedFace = this.faceInfo[face] >> 2;\n            const tA = this.texturedVertexA[texturedFace];\n            const tB = this.texturedVertexB[texturedFace];\n            const tC = this.texturedVertexC[texturedFace];\n            _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(Model.vertexScreenX[a], Model.vertexScreenX[b], Model.vertexScreenX[c], Model.vertexScreenY[a], Model.vertexScreenY[b], Model.vertexScreenY[c], this.faceColorA[face], this.faceColorA[face], this.faceColorA[face], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n        }\n    }\n    drawNearClippedFace(face, wireframe = false) {\n        let elements = 0;\n        if (Model.vertexViewSpaceZ) {\n            const centerX = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerX;\n            const centerY = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].centerY;\n            const a = this.faceVertexA[face];\n            const b = this.faceVertexB[face];\n            const c = this.faceVertexC[face];\n            const zA = Model.vertexViewSpaceZ[a];\n            const zB = Model.vertexViewSpaceZ[b];\n            const zC = Model.vertexViewSpaceZ[c];\n            if (zA >= 50 && Model.vertexScreenX && Model.vertexScreenY && this.faceColorA) {\n                Model.clippedX[elements] = Model.vertexScreenX[a];\n                Model.clippedY[elements] = Model.vertexScreenY[a];\n                Model.clippedColor[elements++] = this.faceColorA[face];\n            }\n            else if (Model.vertexViewSpaceX && Model.vertexViewSpaceY && this.faceColorA) {\n                const xA = Model.vertexViewSpaceX[a];\n                const yA = Model.vertexViewSpaceY[a];\n                const colorA = this.faceColorA[face];\n                if (zC >= 50 && this.faceColorC) {\n                    const scalar = (50 - zA) * _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reciprocal16[zC - zA];\n                    Model.clippedX[elements] = centerX + ((((xA + (((Model.vertexViewSpaceX[c] - xA) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedY[elements] = centerY + ((((yA + (((Model.vertexViewSpaceY[c] - yA) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedColor[elements++] = colorA + (((this.faceColorC[face] - colorA) * scalar) >> 16);\n                }\n                if (zB >= 50 && this.faceColorB) {\n                    const scalar = (50 - zA) * _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reciprocal16[zB - zA];\n                    Model.clippedX[elements] = centerX + ((((xA + (((Model.vertexViewSpaceX[b] - xA) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedY[elements] = centerY + ((((yA + (((Model.vertexViewSpaceY[b] - yA) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedColor[elements++] = colorA + (((this.faceColorB[face] - colorA) * scalar) >> 16);\n                }\n            }\n            if (zB >= 50 && Model.vertexScreenX && Model.vertexScreenY && this.faceColorB) {\n                Model.clippedX[elements] = Model.vertexScreenX[b];\n                Model.clippedY[elements] = Model.vertexScreenY[b];\n                Model.clippedColor[elements++] = this.faceColorB[face];\n            }\n            else if (Model.vertexViewSpaceX && Model.vertexViewSpaceY && this.faceColorB) {\n                const xB = Model.vertexViewSpaceX[b];\n                const yB = Model.vertexViewSpaceY[b];\n                const colorB = this.faceColorB[face];\n                if (zA >= 50 && this.faceColorA) {\n                    const scalar = (50 - zB) * _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reciprocal16[zA - zB];\n                    Model.clippedX[elements] = centerX + ((((xB + (((Model.vertexViewSpaceX[a] - xB) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedY[elements] = centerY + ((((yB + (((Model.vertexViewSpaceY[a] - yB) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedColor[elements++] = colorB + (((this.faceColorA[face] - colorB) * scalar) >> 16);\n                }\n                if (zC >= 50 && this.faceColorC) {\n                    const scalar = (50 - zB) * _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reciprocal16[zC - zB];\n                    Model.clippedX[elements] = centerX + ((((xB + (((Model.vertexViewSpaceX[c] - xB) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedY[elements] = centerY + ((((yB + (((Model.vertexViewSpaceY[c] - yB) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedColor[elements++] = colorB + (((this.faceColorC[face] - colorB) * scalar) >> 16);\n                }\n            }\n            if (zC >= 50 && Model.vertexScreenX && Model.vertexScreenY && this.faceColorC) {\n                Model.clippedX[elements] = Model.vertexScreenX[c];\n                Model.clippedY[elements] = Model.vertexScreenY[c];\n                Model.clippedColor[elements++] = this.faceColorC[face];\n            }\n            else if (Model.vertexViewSpaceX && Model.vertexViewSpaceY && this.faceColorC) {\n                const xC = Model.vertexViewSpaceX[c];\n                const yC = Model.vertexViewSpaceY[c];\n                const colorC = this.faceColorC[face];\n                if (zB >= 50 && this.faceColorB) {\n                    const scalar = (50 - zC) * _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reciprocal16[zB - zC];\n                    Model.clippedX[elements] = centerX + ((((xC + (((Model.vertexViewSpaceX[b] - xC) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedY[elements] = centerY + ((((yC + (((Model.vertexViewSpaceY[b] - yC) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedColor[elements++] = colorC + (((this.faceColorB[face] - colorC) * scalar) >> 16);\n                }\n                if (zA >= 50 && this.faceColorA) {\n                    const scalar = (50 - zC) * _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reciprocal16[zA - zC];\n                    Model.clippedX[elements] = centerX + ((((xC + (((Model.vertexViewSpaceX[a] - xC) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedY[elements] = centerY + ((((yC + (((Model.vertexViewSpaceY[a] - yC) * scalar) >> 16)) << 9) / 50) | 0);\n                    Model.clippedColor[elements++] = colorC + (((this.faceColorA[face] - colorC) * scalar) >> 16);\n                }\n            }\n        }\n        const x0 = Model.clippedX[0];\n        const x1 = Model.clippedX[1];\n        const x2 = Model.clippedX[2];\n        const y0 = Model.clippedY[0];\n        const y1 = Model.clippedY[1];\n        const y2 = Model.clippedY[2];\n        if ((x0 - x1) * (y2 - y1) - (y0 - y1) * (x2 - x1) <= 0) {\n            return;\n        }\n        _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clipX = false;\n        if (elements === 3) {\n            if (x0 < 0 || x1 < 0 || x2 < 0 || x0 > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX || x1 > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX || x2 > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX) {\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clipX = true;\n            }\n            let type;\n            if (!this.faceInfo) {\n                type = 0;\n            }\n            else {\n                type = this.faceInfo[face] & 0x3;\n            }\n            if (wireframe) {\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(x0, x1, y0, y1, Model.clippedColor[0]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(x1, x2, y1, y2, Model.clippedColor[1]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(x2, x0, y2, y0, Model.clippedColor[2]);\n            }\n            else if (type === 0) {\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillGouraudTriangle(x0, x1, x2, y0, y1, y2, Model.clippedColor[0], Model.clippedColor[1], Model.clippedColor[2]);\n            }\n            else if (type === 1 && this.faceColorA) {\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTriangle(x0, x1, x2, y0, y1, y2, _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[this.faceColorA[face]]);\n            }\n            else if (type === 2 && this.faceInfo && this.faceColor && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n                const texturedFace = this.faceInfo[face] >> 2;\n                const tA = this.texturedVertexA[texturedFace];\n                const tB = this.texturedVertexB[texturedFace];\n                const tC = this.texturedVertexC[texturedFace];\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(x0, x1, x2, y0, y1, y2, Model.clippedColor[0], Model.clippedColor[1], Model.clippedColor[2], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n            }\n            else if (type === 3 && this.faceInfo && this.faceColor && this.faceColorA && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n                const texturedFace = this.faceInfo[face] >> 2;\n                const tA = this.texturedVertexA[texturedFace];\n                const tB = this.texturedVertexB[texturedFace];\n                const tC = this.texturedVertexC[texturedFace];\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(x0, x1, x2, y0, y1, y2, this.faceColorA[face], this.faceColorA[face], this.faceColorA[face], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n            }\n        }\n        else if (elements === 4) {\n            if (x0 < 0 || x1 < 0 || x2 < 0 || x0 > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX || x1 > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX || x2 > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX || Model.clippedX[3] < 0 || Model.clippedX[3] > _Draw2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].boundX) {\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clipX = true;\n            }\n            let type;\n            if (!this.faceInfo) {\n                type = 0;\n            }\n            else {\n                type = this.faceInfo[face] & 0x3;\n            }\n            if (wireframe) {\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(x0, x1, y0, y1, Model.clippedColor[0]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(x1, x2, y1, y2, Model.clippedColor[1]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(x2, Model.clippedX[3], y2, Model.clippedY[3], Model.clippedColor[2]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(Model.clippedX[3], x0, Model.clippedY[3], y0, Model.clippedColor[3]);\n            }\n            else if (type === 0) {\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillGouraudTriangle(x0, x1, x2, y0, y1, y2, Model.clippedColor[0], Model.clippedColor[1], Model.clippedColor[2]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillGouraudTriangle(x0, x2, Model.clippedX[3], y0, y2, Model.clippedY[3], Model.clippedColor[0], Model.clippedColor[2], Model.clippedColor[3]);\n            }\n            else if (type === 1) {\n                if (this.faceColorA) {\n                    const colorA = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[this.faceColorA[face]];\n                    _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTriangle(x0, x1, x2, y0, y1, y2, colorA);\n                    _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTriangle(x0, x2, Model.clippedX[3], y0, y2, Model.clippedY[3], colorA);\n                }\n            }\n            else if (type === 2 && this.faceInfo && this.faceColor && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n                const texturedFace = this.faceInfo[face] >> 2;\n                const tA = this.texturedVertexA[texturedFace];\n                const tB = this.texturedVertexB[texturedFace];\n                const tC = this.texturedVertexC[texturedFace];\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(x0, x1, x2, y0, y1, y2, Model.clippedColor[0], Model.clippedColor[1], Model.clippedColor[2], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(x0, x2, Model.clippedX[3], y0, y2, Model.clippedY[3], Model.clippedColor[0], Model.clippedColor[2], Model.clippedColor[3], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n            }\n            else if (type === 3 && this.faceInfo && this.faceColor && this.faceColorA && Model.vertexViewSpaceX && Model.vertexViewSpaceY && Model.vertexViewSpaceZ) {\n                const texturedFace = this.faceInfo[face] >> 2;\n                const tA = this.texturedVertexA[texturedFace];\n                const tB = this.texturedVertexB[texturedFace];\n                const tC = this.texturedVertexC[texturedFace];\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(x0, x1, x2, y0, y1, y2, this.faceColorA[face], this.faceColorA[face], this.faceColorA[face], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n                _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fillTexturedTriangle(x0, x2, Model.clippedX[3], y0, y2, Model.clippedY[3], this.faceColorA[face], this.faceColorA[face], this.faceColorA[face], Model.vertexViewSpaceX[tA], Model.vertexViewSpaceY[tA], Model.vertexViewSpaceZ[tA], Model.vertexViewSpaceX[tB], Model.vertexViewSpaceX[tC], Model.vertexViewSpaceY[tB], Model.vertexViewSpaceY[tC], Model.vertexViewSpaceZ[tB], Model.vertexViewSpaceZ[tC], this.faceColor[face]);\n            }\n        }\n    }\n    applyTransform2(x, y, z, labels, type) {\n        if (!labels) {\n            return;\n        }\n        const labelCount = labels.length;\n        if (type === 0) {\n            let count = 0;\n            Model.baseX = 0;\n            Model.baseY = 0;\n            Model.baseZ = 0;\n            for (let g = 0; g < labelCount; g++) {\n                if (!this.labelVertices) {\n                    continue;\n                }\n                const label = labels[g];\n                if (label < this.labelVertices.length) {\n                    const vertices = this.labelVertices[label];\n                    if (vertices) {\n                        for (let i = 0; i < vertices.length; i++) {\n                            const v = vertices[i];\n                            Model.baseX += this.vertexX[v];\n                            Model.baseY += this.vertexY[v];\n                            Model.baseZ += this.vertexZ[v];\n                            count++;\n                        }\n                    }\n                }\n            }\n            if (count > 0) {\n                Model.baseX = ((Model.baseX / count) | 0) + x;\n                Model.baseY = ((Model.baseY / count) | 0) + y;\n                Model.baseZ = ((Model.baseZ / count) | 0) + z;\n            }\n            else {\n                Model.baseX = x;\n                Model.baseY = y;\n                Model.baseZ = z;\n            }\n        }\n        else if (type === 1) {\n            for (let g = 0; g < labelCount; g++) {\n                const group = labels[g];\n                if (!this.labelVertices || group >= this.labelVertices.length) {\n                    continue;\n                }\n                const vertices = this.labelVertices[group];\n                if (vertices) {\n                    for (let i = 0; i < vertices.length; i++) {\n                        const v = vertices[i];\n                        this.vertexX[v] += x;\n                        this.vertexY[v] += y;\n                        this.vertexZ[v] += z;\n                    }\n                }\n            }\n        }\n        else if (type === 2) {\n            for (let g = 0; g < labelCount; g++) {\n                const label = labels[g];\n                if (!this.labelVertices || label >= this.labelVertices.length) {\n                    continue;\n                }\n                const vertices = this.labelVertices[label];\n                if (vertices) {\n                    for (let i = 0; i < vertices.length; i++) {\n                        const v = vertices[i];\n                        this.vertexX[v] -= Model.baseX;\n                        this.vertexY[v] -= Model.baseY;\n                        this.vertexZ[v] -= Model.baseZ;\n                        const pitch = (x & 0xff) * 8;\n                        const yaw = (y & 0xff) * 8;\n                        const roll = (z & 0xff) * 8;\n                        let sin;\n                        let cos;\n                        if (roll !== 0) {\n                            sin = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[roll];\n                            cos = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[roll];\n                            const x_ = (this.vertexY[v] * sin + this.vertexX[v] * cos) >> 16;\n                            this.vertexY[v] = (this.vertexY[v] * cos - this.vertexX[v] * sin) >> 16;\n                            this.vertexX[v] = x_;\n                        }\n                        if (pitch !== 0) {\n                            sin = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[pitch];\n                            cos = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[pitch];\n                            const y_ = (this.vertexY[v] * cos - this.vertexZ[v] * sin) >> 16;\n                            this.vertexZ[v] = (this.vertexY[v] * sin + this.vertexZ[v] * cos) >> 16;\n                            this.vertexY[v] = y_;\n                        }\n                        if (yaw !== 0) {\n                            sin = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sin[yaw];\n                            cos = _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cos[yaw];\n                            const x_ = (this.vertexZ[v] * sin + this.vertexX[v] * cos) >> 16;\n                            this.vertexZ[v] = (this.vertexZ[v] * cos - this.vertexX[v] * sin) >> 16;\n                            this.vertexX[v] = x_;\n                        }\n                        this.vertexX[v] += Model.baseX;\n                        this.vertexY[v] += Model.baseY;\n                        this.vertexZ[v] += Model.baseZ;\n                    }\n                }\n            }\n        }\n        else if (type === 3) {\n            for (let g = 0; g < labelCount; g++) {\n                const label = labels[g];\n                if (!this.labelVertices || label >= this.labelVertices.length) {\n                    continue;\n                }\n                const vertices = this.labelVertices[label];\n                if (vertices) {\n                    for (let i = 0; i < vertices.length; i++) {\n                        const v = vertices[i];\n                        this.vertexX[v] -= Model.baseX;\n                        this.vertexY[v] -= Model.baseY;\n                        this.vertexZ[v] -= Model.baseZ;\n                        this.vertexX[v] = ((this.vertexX[v] * x) / 128) | 0;\n                        this.vertexY[v] = ((this.vertexY[v] * y) / 128) | 0;\n                        this.vertexZ[v] = ((this.vertexZ[v] * z) / 128) | 0;\n                        this.vertexX[v] += Model.baseX;\n                        this.vertexY[v] += Model.baseY;\n                        this.vertexZ[v] += Model.baseZ;\n                    }\n                }\n            }\n        }\n        else if (type === 5 && this.labelFaces && this.faceAlpha) {\n            for (let g = 0; g < labelCount; g++) {\n                const label = labels[g];\n                if (label >= this.labelFaces.length) {\n                    continue;\n                }\n                const triangles = this.labelFaces[label];\n                if (triangles) {\n                    for (let i = 0; i < triangles.length; i++) {\n                        const t = triangles[i];\n                        this.faceAlpha[t] += x * 8;\n                        if (this.faceAlpha[t] < 0) {\n                            this.faceAlpha[t] = 0;\n                        }\n                        if (this.faceAlpha[t] > 255) {\n                            this.faceAlpha[t] = 255;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    calculateBoundsAABB() {\n        this.maxY = 0;\n        this.radius = 0;\n        this.minY = 0;\n        this.minX = 999999;\n        this.maxX = -999999;\n        this.maxZ = -99999;\n        this.minZ = 99999;\n        for (let v = 0; v < this.vertexCount; v++) {\n            const x = this.vertexX[v];\n            const y = this.vertexY[v];\n            const z = this.vertexZ[v];\n            if (x < this.minX) {\n                this.minX = x;\n            }\n            if (x > this.maxX) {\n                this.maxX = x;\n            }\n            if (z < this.minZ) {\n                this.minZ = z;\n            }\n            if (z > this.maxZ) {\n                this.maxZ = z;\n            }\n            if (-y > this.maxY) {\n                this.maxY = -y;\n            }\n            if (y > this.minY) {\n                this.minY = y;\n            }\n            const radiusSqr = x * x + z * z;\n            if (radiusSqr > this.radius) {\n                this.radius = radiusSqr;\n            }\n        }\n        this.radius = Math.sqrt(this.radius) | 0;\n        this.minDepth = Math.sqrt(this.radius * this.radius + this.maxY * this.maxY) | 0;\n        this.maxDepth = this.minDepth + (Math.sqrt(this.radius * this.radius + this.minY * this.minY) | 0);\n    }\n    pointWithinTriangle(x, y, yA, yB, yC, xA, xB, xC) {\n        if (y < yA && y < yB && y < yC) {\n            return false;\n        }\n        else if (y > yA && y > yB && y > yC) {\n            return false;\n        }\n        else if (x < xA && x < xB && x < xC) {\n            return false;\n        }\n        else {\n            return x <= xA || x <= xB || x <= xC;\n        }\n    }\n    drawFaceOutline(face) {\n        if (!Model.vertexScreenX || !Model.vertexScreenY || !this.faceColorA || !this.faceColorB || !this.faceColorC) {\n            return;\n        }\n        const a = this.faceVertexA[face];\n        const b = this.faceVertexB[face];\n        const c = this.faceVertexC[face];\n        _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(Model.vertexScreenX[a], Model.vertexScreenY[a], Model.vertexScreenX[b], Model.vertexScreenY[b], _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[1000]);\n        _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(Model.vertexScreenX[b], Model.vertexScreenY[b], Model.vertexScreenX[c], Model.vertexScreenY[c], _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[1000]);\n        _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawLine(Model.vertexScreenX[c], Model.vertexScreenY[c], Model.vertexScreenX[a], Model.vertexScreenY[a], _Draw3D__WEBPACK_IMPORTED_MODULE_2__[\"default\"].palette[1000]);\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Model.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Pix24.ts":
/*!*****************************************!*\
  !*** ./src/js/jagex2/graphics/Pix24.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pix24)\n/* harmony export */ });\n/* harmony import */ var _Draw2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../datastruct/Hashable */ \"./src/js/jagex2/datastruct/Hashable.ts\");\n/* harmony import */ var _Jpeg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Jpeg */ \"./src/js/jagex2/graphics/Jpeg.ts\");\n\n\n\n\nclass Pix24 extends _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    // constructor\n    pixels;\n    width;\n    height;\n    cropX;\n    cropY;\n    cropW;\n    cropH;\n    constructor(width, height) {\n        super();\n        this.pixels = new Int32Array(width * height);\n        this.width = this.cropW = width;\n        this.height = this.cropH = height;\n        this.cropX = this.cropY = 0;\n    }\n    static fromJpeg = async (archive, name) => {\n        const dat = archive.read(name + '.dat');\n        if (!dat) {\n            throw new Error(`${name} jpeg not found!`);\n        }\n        const jpeg = await (0,_Jpeg__WEBPACK_IMPORTED_MODULE_3__.decodeJpeg)(dat);\n        const image = new Pix24(jpeg.width, jpeg.height);\n        const data = new Uint32Array(jpeg.data.buffer);\n        const pixels = image.pixels;\n        for (let i = 0; i < pixels.length; i++) {\n            const pixel = data[i];\n            pixels[i] = (((pixel >> 24) & 0xff) << 24) | ((pixel & 0xff) << 16) | (((pixel >> 8) & 0xff) << 8) | ((pixel >> 16) & 0xff);\n        }\n        return image;\n    };\n    static fromArchive = (archive, name, sprite = 0) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](archive.read(name + '.dat'));\n        const index = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](archive.read('index.dat'));\n        // cropW/cropH are shared across all sprites in a single image\n        index.pos = dat.g2;\n        const cropW = index.g2;\n        const cropH = index.g2;\n        // palette is shared across all images in a single archive\n        const paletteCount = index.g1;\n        const palette = [];\n        const length = paletteCount - 1;\n        for (let i = 0; i < length; i++) {\n            // the first color (0) is reserved for transparency\n            palette[i + 1] = index.g3;\n            // black (0) will become transparent, make it black (1) so it's visible\n            if (palette[i + 1] === 0) {\n                palette[i + 1] = 1;\n            }\n        }\n        // advance to sprite\n        for (let i = 0; i < sprite; i++) {\n            index.pos += 2;\n            dat.pos += index.g2 * index.g2;\n            index.pos += 1;\n        }\n        if (dat.pos > dat.length || index.pos > index.length) {\n            throw new Error();\n        }\n        // read sprite\n        const cropX = index.g1;\n        const cropY = index.g1;\n        const width = index.g2;\n        const height = index.g2;\n        const image = new Pix24(width, height);\n        image.cropX = cropX;\n        image.cropY = cropY;\n        image.cropW = cropW;\n        image.cropH = cropH;\n        const pixelOrder = index.g1;\n        if (pixelOrder === 0) {\n            const length = image.width * image.height;\n            for (let i = 0; i < length; i++) {\n                image.pixels[i] = palette[dat.g1];\n            }\n        }\n        else if (pixelOrder === 1) {\n            const width = image.width;\n            for (let x = 0; x < width; x++) {\n                const height = image.height;\n                for (let y = 0; y < height; y++) {\n                    image.pixels[x + y * width] = palette[dat.g1];\n                }\n            }\n        }\n        return image;\n    };\n    bind() {\n        _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bind(this.pixels, this.width, this.height);\n    }\n    draw(x, y) {\n        x |= 0;\n        y |= 0;\n        x += this.cropX;\n        y += this.cropY;\n        let dstOff = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        let srcOff = 0;\n        let h = this.height;\n        let w = this.width;\n        let dstStep = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n        let srcStep = 0;\n        if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n            h -= cutoff;\n            y = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top;\n            srcOff += cutoff * w;\n            dstOff += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        }\n        if (y + h > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n            h -= y + h - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n        }\n        if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n            w -= cutoff;\n            x = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left;\n            srcOff += cutoff;\n            dstOff += cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (x + w > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n            const cutoff = x + w - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n            w -= cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (w > 0 && h > 0) {\n            this.copyImageDraw(w, h, this.pixels, srcOff, srcStep, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstOff, dstStep);\n        }\n    }\n    drawAlpha(alpha, x, y) {\n        x |= 0;\n        y |= 0;\n        x += this.cropX;\n        y += this.cropY;\n        let dstStep = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        let srcStep = 0;\n        let h = this.height;\n        let w = this.width;\n        let dstOff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n        let srcOff = 0;\n        if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n            h -= cutoff;\n            y = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top;\n            srcStep += cutoff * w;\n            dstStep += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        }\n        if (y + h > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n            h -= y + h - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n        }\n        if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n            w -= cutoff;\n            x = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left;\n            srcStep += cutoff;\n            dstStep += cutoff;\n            srcOff += cutoff;\n            dstOff += cutoff;\n        }\n        if (x + w > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n            const cutoff = x + w - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n            w -= cutoff;\n            srcOff += cutoff;\n            dstOff += cutoff;\n        }\n        if (w > 0 && h > 0) {\n            this.copyPixelsAlpha(w, h, this.pixels, srcStep, srcOff, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstStep, dstOff, alpha);\n        }\n    }\n    blitOpaque(x, y) {\n        x |= 0;\n        y |= 0;\n        x += this.cropX;\n        y += this.cropY;\n        let dstOff = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        let srcOff = 0;\n        let h = this.height;\n        let w = this.width;\n        let dstStep = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n        let srcStep = 0;\n        if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n            h -= cutoff;\n            y = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top;\n            srcOff += cutoff * w;\n            dstOff += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        }\n        if (y + h > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n            h -= y + h - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n        }\n        if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n            w -= cutoff;\n            x = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left;\n            srcOff += cutoff;\n            dstOff += cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (x + w > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n            const cutoff = x + w - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n            w -= cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (w > 0 && h > 0) {\n            this.copyImageBlitOpaque(w, h, this.pixels, srcOff, srcStep, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstOff, dstStep);\n        }\n    }\n    flipHorizontally() {\n        const pixels = this.pixels;\n        const width = this.width;\n        const height = this.height;\n        for (let y = 0; y < height; y++) {\n            const div = (width / 2) | 0;\n            for (let x = 0; x < div; x++) {\n                const off1 = x + y * width;\n                const off2 = width - x - 1 + y * width;\n                const tmp = pixels[off1];\n                pixels[off1] = pixels[off2];\n                pixels[off2] = tmp;\n            }\n        }\n    }\n    flipVertically() {\n        const pixels = this.pixels;\n        const width = this.width;\n        const height = this.height;\n        for (let y = 0; y < ((height / 2) | 0); y++) {\n            for (let x = 0; x < width; x++) {\n                const off1 = x + y * width;\n                const off2 = x + (height - y - 1) * width;\n                const tmp = pixels[off1];\n                pixels[off1] = pixels[off2];\n                pixels[off2] = tmp;\n            }\n        }\n    }\n    translate(r, g, b) {\n        for (let i = 0; i < this.pixels.length; i++) {\n            const rgb = this.pixels[i];\n            if (rgb !== 0) {\n                let red = (rgb >> 16) & 0xff;\n                red += r;\n                if (red < 1) {\n                    red = 1;\n                }\n                else if (red > 255) {\n                    red = 255;\n                }\n                let green = (rgb >> 8) & 0xff;\n                green += g;\n                if (green < 1) {\n                    green = 1;\n                }\n                else if (green > 255) {\n                    green = 255;\n                }\n                let blue = rgb & 0xff;\n                blue += b;\n                if (blue < 1) {\n                    blue = 1;\n                }\n                else if (blue > 255) {\n                    blue = 255;\n                }\n                this.pixels[i] = (red << 16) + (green << 8) + blue;\n            }\n        }\n    }\n    crop(x, y, w, h) {\n        x |= 0;\n        y |= 0;\n        w |= 0;\n        h |= 0;\n        try {\n            const currentW = this.width;\n            // const currentH: number = this.height; // dead code\n            let offW = 0;\n            let offH = 0;\n            // let scaleWidth: number = (currentW << 16) / w; // dead code\n            // let scaleHeight: number = (currentH << 16) / h; // dead code\n            const cw = this.cropW;\n            const ch = this.cropH;\n            const scaleCropWidth = ((cw << 16) / w) | 0;\n            const scaleCropHeight = ((ch << 16) / h) | 0;\n            x += ((this.cropX * w + cw - 1) / cw) | 0;\n            y += ((this.cropY * h + ch - 1) / ch) | 0;\n            if ((this.cropX * w) % cw !== 0) {\n                offW = (((cw - ((this.cropX * w) % cw)) << 16) / w) | 0;\n            }\n            if ((this.cropY * h) % ch !== 0) {\n                offH = (((ch - ((this.cropY * h) % ch)) << 16) / h) | 0;\n            }\n            w = ((w * (this.width - (offW >> 16))) / cw) | 0;\n            h = ((h * (this.height - (offH >> 16))) / ch) | 0;\n            let dstStep = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n            let dstOff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n            if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n                const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n                h -= cutoff;\n                y = 0;\n                dstStep += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n                offH += scaleCropHeight * cutoff;\n            }\n            if (y + h > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n                h -= y + h - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n            }\n            if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n                const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n                w -= cutoff;\n                x = 0;\n                dstStep += cutoff;\n                offW += scaleCropWidth * cutoff;\n                dstOff += cutoff;\n            }\n            if (x + w > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n                const cutoff = x + w - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n                w -= cutoff;\n                dstOff += cutoff;\n            }\n            this.scale(w, h, this.pixels, offW, offH, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstOff, dstStep, currentW, scaleCropWidth, scaleCropHeight);\n        }\n        catch (e) {\n            console.error('error in sprite clipping routine');\n        }\n    }\n    drawRotatedMasked(x, y, w, h, lineStart, lineWidth, anchorX, anchorY, theta, zoom) {\n        x |= 0;\n        y |= 0;\n        w |= 0;\n        h |= 0;\n        try {\n            const centerX = (-w / 2) | 0;\n            const centerY = (-h / 2) | 0;\n            const sin = (Math.sin(theta / 326.11) * 65536.0) | 0;\n            const cos = (Math.cos(theta / 326.11) * 65536.0) | 0;\n            const sinZoom = (sin * zoom) >> 8;\n            const cosZoom = (cos * zoom) >> 8;\n            let leftX = (anchorX << 16) + centerY * sinZoom + centerX * cosZoom;\n            let leftY = (anchorY << 16) + (centerY * cosZoom - centerX * sinZoom);\n            let leftOff = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n            for (let i = 0; i < h; i++) {\n                const dstOff = lineStart[i];\n                let dstX = leftOff + dstOff;\n                let srcX = leftX + cosZoom * dstOff;\n                let srcY = leftY - sinZoom * dstOff;\n                for (let j = -lineWidth[i]; j < 0; j++) {\n                    _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels[dstX++] = this.pixels[(srcX >> 16) + (srcY >> 16) * this.width];\n                    srcX += cosZoom;\n                    srcY -= sinZoom;\n                }\n                leftX += sinZoom;\n                leftY += cosZoom;\n                leftOff += _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n            }\n        }\n        catch (e) {\n            /* empty */\n        }\n    }\n    drawMasked(x, y, mask) {\n        x |= 0;\n        y |= 0;\n        x += this.cropX;\n        y += this.cropY;\n        let dstStep = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        let srcStep = 0;\n        let h = this.height;\n        let w = this.width;\n        let dstOff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n        let srcOff = 0;\n        if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n            h -= cutoff;\n            y = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top;\n            srcStep += cutoff * w;\n            dstStep += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        }\n        if (y + h > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n            h -= y + h - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n        }\n        if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n            w -= cutoff;\n            x = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left;\n            srcStep += cutoff;\n            dstStep += cutoff;\n            srcOff += cutoff;\n            dstOff += cutoff;\n        }\n        if (x + w > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n            const cutoff = x + w - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n            w -= cutoff;\n            srcOff += cutoff;\n            dstOff += cutoff;\n        }\n        if (w > 0 && h > 0) {\n            this.copyPixelsMasked(w, h, this.pixels, srcOff, srcStep, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstStep, dstOff, mask.pixels);\n        }\n    }\n    scale(w, h, src, offW, offH, dst, dstStep, dstOff, currentW, scaleCropWidth, scaleCropHeight) {\n        try {\n            const lastOffW = offW;\n            for (let y = -h; y < 0; y++) {\n                const offY = (offH >> 16) * currentW;\n                for (let x = -w; x < 0; x++) {\n                    const rgb = src[(offW >> 16) + offY];\n                    if (rgb === 0) {\n                        dstOff++;\n                    }\n                    else {\n                        dst[dstOff++] = rgb;\n                    }\n                    offW += scaleCropWidth;\n                }\n                offH += scaleCropHeight;\n                offW = lastOffW;\n                dstOff += dstStep;\n            }\n        }\n        catch (e) {\n            console.error('error in plot_scale');\n        }\n    }\n    copyImageBlitOpaque(w, h, src, srcOff, srcStep, dst, dstOff, dstStep) {\n        const qw = -(w >> 2);\n        w = -(w & 0x3);\n        for (let y = -h; y < 0; y++) {\n            for (let x = qw; x < 0; x++) {\n                dst[dstOff++] = src[srcOff++];\n                dst[dstOff++] = src[srcOff++];\n                dst[dstOff++] = src[srcOff++];\n                dst[dstOff++] = src[srcOff++];\n            }\n            for (let x = w; x < 0; x++) {\n                dst[dstOff++] = src[srcOff++];\n            }\n            dstOff += dstStep;\n            srcOff += srcStep;\n        }\n    }\n    copyPixelsAlpha(w, h, src, srcOff, srcStep, dst, dstOff, dstStep, alpha) {\n        const invAlpha = 256 - alpha;\n        for (let y = -h; y < 0; y++) {\n            for (let x = -w; x < 0; x++) {\n                const rgb = src[srcOff++];\n                if (rgb === 0) {\n                    dstOff++;\n                }\n                else {\n                    const dstRgb = dst[dstOff];\n                    dst[dstOff++] = ((((rgb & 0xff00ff) * alpha + (dstRgb & 0xff00ff) * invAlpha) & 0xff00ff00) + (((rgb & 0xff00) * alpha + (dstRgb & 0xff00) * invAlpha) & 0xff0000)) >> 8;\n                }\n            }\n            dstOff += dstStep;\n            srcOff += srcStep;\n        }\n    }\n    copyImageDraw(w, h, src, srcOff, srcStep, dst, dstOff, dstStep) {\n        const qw = -(w >> 2);\n        w = -(w & 0x3);\n        for (let y = -h; y < 0; y++) {\n            for (let x = qw; x < 0; x++) {\n                let rgb = src[srcOff++];\n                if (rgb === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n                rgb = src[srcOff++];\n                if (rgb === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n                rgb = src[srcOff++];\n                if (rgb === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n                rgb = src[srcOff++];\n                if (rgb === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n            }\n            for (let x = w; x < 0; x++) {\n                const rgb = src[srcOff++];\n                if (rgb === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n            }\n            dstOff += dstStep;\n            srcOff += srcStep;\n        }\n    }\n    copyPixelsMasked(w, h, src, srcStep, srcOff, dst, dstOff, dstStep, mask) {\n        const qw = -(w >> 2);\n        w = -(w & 0x3);\n        for (let y = -h; y < 0; y++) {\n            for (let x = qw; x < 0; x++) {\n                let rgb = src[srcOff++];\n                if (rgb !== 0 && mask[dstOff] === 0) {\n                    dst[dstOff++] = rgb;\n                }\n                else {\n                    dstOff++;\n                }\n                rgb = src[srcOff++];\n                if (rgb !== 0 && mask[dstOff] === 0) {\n                    dst[dstOff++] = rgb;\n                }\n                else {\n                    dstOff++;\n                }\n                rgb = src[srcOff++];\n                if (rgb !== 0 && mask[dstOff] === 0) {\n                    dst[dstOff++] = rgb;\n                }\n                else {\n                    dstOff++;\n                }\n                rgb = src[srcOff++];\n                if (rgb !== 0 && mask[dstOff] === 0) {\n                    dst[dstOff++] = rgb;\n                }\n                else {\n                    dstOff++;\n                }\n            }\n            for (let x = w; x < 0; x++) {\n                const rgb = src[srcOff++];\n                if (rgb !== 0 && mask[dstOff] === 0) {\n                    dst[dstOff++] = rgb;\n                }\n                else {\n                    dstOff++;\n                }\n            }\n            dstOff += dstStep;\n            srcOff += srcStep;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Pix24.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/Pix8.ts":
/*!****************************************!*\
  !*** ./src/js/jagex2/graphics/Pix8.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pix8)\n/* harmony export */ });\n/* harmony import */ var _Draw2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../datastruct/Hashable */ \"./src/js/jagex2/datastruct/Hashable.ts\");\n\n\n\n// identical to Pix24 except the image is indexed by a palette\nclass Pix8 extends _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    // constructor\n    pixels;\n    width;\n    height;\n    cropX;\n    cropY;\n    cropW;\n    cropH;\n    palette;\n    constructor(width, height, palette) {\n        super();\n        this.pixels = new Int8Array(width * height);\n        this.width = this.cropW = width;\n        this.height = this.cropH = height;\n        this.cropX = this.cropY = 0;\n        this.palette = palette;\n    }\n    static fromArchive = (archive, name, sprite = 0) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](archive.read(name + '.dat'));\n        const index = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](archive.read('index.dat'));\n        // cropW/cropH are shared across all sprites in a single image\n        index.pos = dat.g2;\n        const cropW = index.g2;\n        const cropH = index.g2;\n        // palette is shared across all images in a single archive\n        const paletteCount = index.g1;\n        const palette = new Int32Array(paletteCount);\n        // the first color (0) is reserved for transparency\n        for (let i = 1; i < paletteCount; i++) {\n            palette[i] = index.g3;\n            // black (0) will become transparent, make it black (1) so it's visible\n            if (palette[i] === 0) {\n                palette[i] = 1;\n            }\n        }\n        // advance to sprite\n        for (let i = 0; i < sprite; i++) {\n            index.pos += 2;\n            dat.pos += index.g2 * index.g2;\n            index.pos += 1;\n        }\n        if (dat.pos > dat.length || index.pos > index.length) {\n            throw new Error();\n        }\n        // read sprite\n        const cropX = index.g1;\n        const cropY = index.g1;\n        const width = index.g2;\n        const height = index.g2;\n        const image = new Pix8(width, height, palette);\n        image.cropX = cropX;\n        image.cropY = cropY;\n        image.cropW = cropW;\n        image.cropH = cropH;\n        const pixels = image.pixels;\n        const pixelOrder = index.g1;\n        if (pixelOrder === 0) {\n            const length = image.width * image.height;\n            for (let i = 0; i < length; i++) {\n                pixels[i] = dat.g1b;\n            }\n        }\n        else if (pixelOrder === 1) {\n            const width = image.width;\n            const height = image.height;\n            for (let x = 0; x < width; x++) {\n                for (let y = 0; y < height; y++) {\n                    pixels[x + y * width] = dat.g1b;\n                }\n            }\n        }\n        return image;\n    };\n    draw(x, y) {\n        x |= 0;\n        y |= 0;\n        x += this.cropX;\n        y += this.cropY;\n        let dstOff = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        let srcOff = 0;\n        let h = this.height;\n        let w = this.width;\n        let dstStep = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n        let srcStep = 0;\n        if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n            h -= cutoff;\n            y = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top;\n            srcOff += cutoff * w;\n            dstOff += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        }\n        if (y + h > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n            h -= y + h - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n        }\n        if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n            w -= cutoff;\n            x = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left;\n            srcOff += cutoff;\n            dstOff += cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (x + w > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n            const cutoff = x + w - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n            w -= cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (w > 0 && h > 0) {\n            this.copyImage(w, h, this.pixels, srcOff, srcStep, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstOff, dstStep);\n        }\n    }\n    flipHorizontally() {\n        const pixels = this.pixels;\n        const width = this.width;\n        const height = this.height;\n        for (let y = 0; y < height; y++) {\n            const div = (width / 2) | 0;\n            for (let x = 0; x < div; x++) {\n                const off1 = x + y * width;\n                const off2 = width - x - 1 + y * width;\n                const tmp = pixels[off1];\n                pixels[off1] = pixels[off2];\n                pixels[off2] = tmp;\n            }\n        }\n    }\n    flipVertically() {\n        const pixels = this.pixels;\n        const width = this.width;\n        const height = this.height;\n        for (let y = 0; y < ((height / 2) | 0); y++) {\n            for (let x = 0; x < width; x++) {\n                const off1 = x + y * width;\n                const off2 = x + (height - y - 1) * width;\n                const tmp = pixels[off1];\n                pixels[off1] = pixels[off2];\n                pixels[off2] = tmp;\n            }\n        }\n    }\n    translate(r, g, b) {\n        for (let i = 0; i < this.palette.length; i++) {\n            let red = (this.palette[i] >> 16) & 0xff;\n            red += r;\n            if (red < 0) {\n                red = 0;\n            }\n            else if (red > 255) {\n                red = 255;\n            }\n            let green = (this.palette[i] >> 8) & 0xff;\n            green += g;\n            if (green < 0) {\n                green = 0;\n            }\n            else if (green > 255) {\n                green = 255;\n            }\n            let blue = this.palette[i] & 0xff;\n            blue += b;\n            if (blue < 0) {\n                blue = 0;\n            }\n            else if (blue > 255) {\n                blue = 255;\n            }\n            this.palette[i] = (red << 16) + (green << 8) + blue;\n        }\n    }\n    shrink() {\n        this.cropW |= 0;\n        this.cropH |= 0;\n        this.cropW /= 2;\n        this.cropH /= 2;\n        this.cropW |= 0;\n        this.cropH |= 0;\n        const pixels = new Int8Array(this.cropW * this.cropH);\n        let off = 0;\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                pixels[((x + this.cropX) >> 1) + ((y + this.cropY) >> 1) * this.cropW] = this.pixels[off++];\n            }\n        }\n        this.pixels = pixels;\n        this.width = this.cropW;\n        this.height = this.cropH;\n        this.cropX = 0;\n        this.cropY = 0;\n    }\n    crop() {\n        if (this.width === this.cropW && this.height === this.cropH) {\n            return;\n        }\n        const pixels = new Int8Array(this.cropW * this.cropH);\n        let off = 0;\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                pixels[x + this.cropX + (y + this.cropY) * this.cropW] = this.pixels[off++];\n            }\n        }\n        this.pixels = pixels;\n        this.width = this.cropW;\n        this.height = this.cropH;\n        this.cropX = 0;\n        this.cropY = 0;\n    }\n    copyImage(w, h, src, srcOff, srcStep, dst, dstOff, dstStep) {\n        const qw = -(w >> 2);\n        w = -(w & 0x3);\n        for (let y = -h; y < 0; y++) {\n            for (let x = qw; x < 0; x++) {\n                let palIndex = src[srcOff++];\n                if (palIndex === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = this.palette[palIndex & 0xff];\n                }\n                palIndex = src[srcOff++];\n                if (palIndex === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = this.palette[palIndex & 0xff];\n                }\n                palIndex = src[srcOff++];\n                if (palIndex === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = this.palette[palIndex & 0xff];\n                }\n                palIndex = src[srcOff++];\n                if (palIndex === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = this.palette[palIndex & 0xff];\n                }\n            }\n            for (let x = w; x < 0; x++) {\n                const palIndex = src[srcOff++];\n                if (palIndex === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = this.palette[palIndex & 0xff];\n                }\n            }\n            dstOff += dstStep;\n            srcOff += srcStep;\n        }\n    }\n    clip(arg0, arg1, arg2, arg3) {\n        try {\n            const local2 = this.width;\n            const local5 = this.height;\n            let local7 = 0;\n            let local9 = 0;\n            const local15 = ((local2 << 16) / arg2) | 0;\n            const local21 = ((local5 << 16) / arg3) | 0;\n            const local24 = this.cropW;\n            const local27 = this.cropH;\n            const local33 = ((local24 << 16) / arg2) | 0;\n            const local39 = ((local27 << 16) / arg3) | 0;\n            arg0 = (arg0 + (this.cropX * arg2 + local24 - 1) / local24) | 0;\n            arg1 = (arg1 + (this.cropY * arg3 + local27 - 1) / local27) | 0;\n            if ((this.cropX * arg2) % local24 != 0) {\n                local7 = (((local24 - ((this.cropX * arg2) % local24)) << 16) / arg2) | 0;\n            }\n            if ((this.cropY * arg3) % local27 != 0) {\n                local9 = (((local27 - ((this.cropY * arg3) % local27)) << 16) / arg3) | 0;\n            }\n            arg2 = ((arg2 * (this.width - (local7 >> 16))) / local24) | 0;\n            arg3 = ((arg3 * (this.height - (local9 >> 16))) / local27) | 0;\n            let local133 = arg0 + arg1 * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n            let local137 = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - arg2;\n            let local144;\n            if (arg1 < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n                local144 = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - arg1;\n                arg3 -= local144;\n                arg1 = 0;\n                local133 += local144 * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n                local9 += local39 * local144;\n            }\n            if (arg1 + arg3 > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n                arg3 -= arg1 + arg3 - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n            }\n            if (arg0 < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n                local144 = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - arg0;\n                arg2 -= local144;\n                arg0 = 0;\n                local133 += local144;\n                local7 += local33 * local144;\n                local137 += local144;\n            }\n            if (arg0 + arg2 > _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n                local144 = arg0 + arg2 - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n                arg2 -= local144;\n                local137 += local144;\n            }\n            this.plot_scale(_Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, this.pixels, this.palette, local7, local9, local133, local137, arg2, arg3, local33, local39, local2);\n        }\n        catch (ignore) {\n            console.log('error in sprite clipping routine');\n        }\n    }\n    plot_scale(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) {\n        try {\n            const local3 = arg3;\n            for (let local6 = -arg8; local6 < 0; local6++) {\n                const local14 = (arg4 >> 16) * arg11;\n                for (let local17 = -arg7; local17 < 0; local17++) {\n                    const local27 = arg1[(arg3 >> 16) + local14];\n                    if (local27 == 0) {\n                        arg5++;\n                    }\n                    else {\n                        arg0[arg5++] = arg2[local27 & 0xff];\n                    }\n                    arg3 += arg9;\n                }\n                arg4 += arg10;\n                arg3 = local3;\n                arg5 += arg6;\n            }\n        }\n        catch (ignore) {\n            console.log('error in plot_scale');\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/Pix8.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/PixFont.ts":
/*!*******************************************!*\
  !*** ./src/js/jagex2/graphics/PixFont.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PixFont)\n/* harmony export */ });\n/* harmony import */ var _Draw2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../datastruct/Hashable */ \"./src/js/jagex2/datastruct/Hashable.ts\");\n/* harmony import */ var _util_JavaRandom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/JavaRandom */ \"./src/js/jagex2/util/JavaRandom.ts\");\n/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Colors */ \"./src/js/jagex2/graphics/Colors.ts\");\n\n\n\n\n\nclass PixFont extends _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    static CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!\"£$%^&*()-_=+[{]};:\\'@#~,<.>/?\\\\| ';\n    static CHARCODESET = [];\n    static {\n        const isCapacitor = navigator.userAgent.includes('Capacitor');\n        for (let i = 0; i < 256; i++) {\n            let c = PixFont.CHARSET.indexOf(String.fromCharCode(i));\n            // This fixes text mangling in Capacitor native builds (Android/IOS)\n            if (isCapacitor)\n                if (c >= 63) {\n                    // \"\n                    c--;\n                }\n            if (c === -1) {\n                c = 74; // space\n            }\n            PixFont.CHARCODESET[i] = c;\n        }\n    }\n    charMask = [];\n    charMaskWidth = new Int32Array(94);\n    charMaskHeight = new Int32Array(94);\n    charOffsetX = new Int32Array(94);\n    charOffsetY = new Int32Array(94);\n    charAdvance = new Int32Array(95);\n    drawWidth = new Int32Array(256);\n    random = new _util_JavaRandom__WEBPACK_IMPORTED_MODULE_3__[\"default\"](BigInt(Date.now()));\n    height = 0;\n    static fromArchive = (archive, name) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](archive.read(name + '.dat'));\n        const idx = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](archive.read('index.dat'));\n        idx.pos = dat.g2 + 4; // skip cropW and cropH\n        const off = idx.g1;\n        if (off > 0) {\n            // skip palette\n            idx.pos += (off - 1) * 3;\n        }\n        const font = new PixFont();\n        for (let i = 0; i < 94; i++) {\n            font.charOffsetX[i] = idx.g1;\n            font.charOffsetY[i] = idx.g1;\n            const w = (font.charMaskWidth[i] = idx.g2);\n            const h = (font.charMaskHeight[i] = idx.g2);\n            const type = idx.g1;\n            const len = w * h;\n            font.charMask[i] = new Int8Array(len);\n            if (type === 0) {\n                for (let j = 0; j < w * h; j++) {\n                    font.charMask[i][j] = dat.g1b;\n                }\n            }\n            else if (type === 1) {\n                for (let x = 0; x < w; x++) {\n                    for (let y = 0; y < h; y++) {\n                        font.charMask[i][x + y * w] = dat.g1b;\n                    }\n                }\n            }\n            if (h > font.height) {\n                font.height = h;\n            }\n            font.charOffsetX[i] = 1;\n            font.charAdvance[i] = w + 2;\n            {\n                let space = 0;\n                for (let y = (h / 7) | 0; y < h; y++) {\n                    space += font.charMask[i][y * w];\n                }\n                if (space <= ((h / 7) | 0)) {\n                    font.charAdvance[i]--;\n                    font.charOffsetX[i] = 0;\n                }\n            }\n            {\n                let space = 0;\n                for (let y = (h / 7) | 0; y < h; y++) {\n                    space += font.charMask[i][w + y * w - 1];\n                }\n                if (space <= ((h / 7) | 0)) {\n                    font.charAdvance[i]--;\n                }\n            }\n        }\n        font.charAdvance[94] = font.charAdvance[8];\n        for (let i = 0; i < 256; i++) {\n            font.drawWidth[i] = font.charAdvance[PixFont.CHARCODESET[i]];\n        }\n        return font;\n    };\n    drawString(x, y, str, color) {\n        if (!str) {\n            return;\n        }\n        x |= 0;\n        y |= 0;\n        const length = str.length;\n        y -= this.height;\n        for (let i = 0; i < length; i++) {\n            const c = PixFont.CHARCODESET[str.charCodeAt(i)];\n            if (c !== 94) {\n                this.drawChar(this.charMask[c], x + this.charOffsetX[c], y + this.charOffsetY[c], this.charMaskWidth[c], this.charMaskHeight[c], color);\n            }\n            x += this.charAdvance[c];\n        }\n    }\n    drawStringTaggable(x, y, str, color, shadowed) {\n        x |= 0;\n        y |= 0;\n        const length = str.length;\n        y -= this.height;\n        for (let i = 0; i < length; i++) {\n            if (str.charAt(i) === '@' && i + 4 < length && str.charAt(i + 4) === '@') {\n                color = this.evaluateTag(str.substring(i + 1, i + 4));\n                i += 4;\n            }\n            else {\n                const c = PixFont.CHARCODESET[str.charCodeAt(i)];\n                if (c !== 94) {\n                    if (shadowed) {\n                        this.drawChar(this.charMask[c], x + this.charOffsetX[c] + 1, y + this.charOffsetY[c] + 1, this.charMaskWidth[c], this.charMaskHeight[c], _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].BLACK);\n                    }\n                    this.drawChar(this.charMask[c], x + this.charOffsetX[c], y + this.charOffsetY[c], this.charMaskWidth[c], this.charMaskHeight[c], color);\n                }\n                x += this.charAdvance[c];\n            }\n        }\n    }\n    stringWidth(str) {\n        if (!str) {\n            return 0;\n        }\n        const length = str.length;\n        let w = 0;\n        for (let i = 0; i < length; i++) {\n            if (str.charAt(i) === '@' && i + 4 < length && str.charAt(i + 4) === '@') {\n                i += 4;\n            }\n            else {\n                w += this.drawWidth[str.charCodeAt(i)];\n            }\n        }\n        return w;\n    }\n    drawStringTaggableCenter(x, y, str, color, shadowed) {\n        x |= 0;\n        y |= 0;\n        this.drawStringTaggable(x - this.stringWidth(str) / 2, y, str, color, shadowed);\n    }\n    drawStringCenter(x, y, str, color) {\n        if (!str) {\n            return;\n        }\n        x |= 0;\n        y |= 0;\n        this.drawString(x - this.stringWidth(str) / 2, y, str, color);\n    }\n    drawStringTooltip(x, y, str, color, shadowed, seed) {\n        x |= 0;\n        y |= 0;\n        this.random.setSeed(BigInt(seed));\n        const rand = (this.random.nextInt() & 0x1f) + 192;\n        const offY = y - this.height;\n        for (let i = 0; i < str.length; i++) {\n            if (str.charAt(i) === '@' && i + 4 < str.length && str.charAt(i + 4) === '@') {\n                color = this.evaluateTag(str.substring(i + 1, i + 4));\n                i += 4;\n            }\n            else {\n                const c = PixFont.CHARCODESET[str.charCodeAt(i)];\n                if (c !== 94) {\n                    if (shadowed) {\n                        this.drawCharAlpha(x + this.charOffsetX[c] + 1, offY + this.charOffsetY[c] + 1, this.charMaskWidth[c], this.charMaskHeight[c], _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].BLACK, 192, this.charMask[c]);\n                    }\n                    this.drawCharAlpha(x + this.charOffsetX[c], offY + this.charOffsetY[c], this.charMaskWidth[c], this.charMaskHeight[c], color, rand, this.charMask[c]);\n                }\n                x += this.charAdvance[c];\n                if ((this.random.nextInt() & 0x3) === 0) {\n                    x++;\n                }\n            }\n        }\n    }\n    drawStringRight(x, y, str, color, shadowed = true) {\n        x |= 0;\n        y |= 0;\n        if (shadowed) {\n            this.drawString(x - this.stringWidth(str) + 1, y + 1, str, _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].BLACK);\n        }\n        this.drawString(x - this.stringWidth(str), y, str, color);\n    }\n    drawCenteredWave(x, y, str, color, phase) {\n        if (!str) {\n            return;\n        }\n        x |= 0;\n        y |= 0;\n        x -= (this.stringWidth(str) / 2) | 0;\n        const offY = y - this.height;\n        for (let i = 0; i < str.length; i++) {\n            const c = PixFont.CHARCODESET[str.charCodeAt(i)];\n            if (c != 94) {\n                this.drawChar(this.charMask[c], x + this.charOffsetX[c], offY + this.charOffsetY[c] + ((Math.sin(i / 2.0 + phase / 5.0) * 5.0) | 0), this.charMaskWidth[c], this.charMaskHeight[c], color);\n            }\n            x += this.charAdvance[c];\n        }\n    }\n    drawChar(data, x, y, w, h, color) {\n        x |= 0;\n        y |= 0;\n        w |= 0;\n        h |= 0;\n        let dstOff = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        let dstStep = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n        let srcStep = 0;\n        let srcOff = 0;\n        if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n            h -= cutoff;\n            y = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top;\n            srcOff += cutoff * w;\n            dstOff += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        }\n        if (y + h >= _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n            h -= y + h + 1 - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n        }\n        if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n            w -= cutoff;\n            x = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left;\n            srcOff += cutoff;\n            dstOff += cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (x + w >= _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n            const cutoff = x + w + 1 - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n            w -= cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (w > 0 && h > 0) {\n            this.drawMask(w, h, data, srcOff, srcStep, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstOff, dstStep, color);\n        }\n    }\n    drawCharAlpha(x, y, w, h, color, alpha, mask) {\n        x |= 0;\n        y |= 0;\n        w |= 0;\n        h |= 0;\n        let dstOff = x + y * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        let dstStep = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d - w;\n        let srcStep = 0;\n        let srcOff = 0;\n        if (y < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top - y;\n            h -= cutoff;\n            y = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].top;\n            srcOff += cutoff * w;\n            dstOff += cutoff * _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width2d;\n        }\n        if (y + h >= _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom) {\n            h -= y + h + 1 - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bottom;\n        }\n        if (x < _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left) {\n            const cutoff = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left - x;\n            w -= cutoff;\n            x = _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].left;\n            srcOff += cutoff;\n            dstOff += cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (x + w >= _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right) {\n            const cutoff = x + w + 1 - _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].right;\n            w -= cutoff;\n            srcStep += cutoff;\n            dstStep += cutoff;\n        }\n        if (w > 0 && h > 0) {\n            this.drawMaskAlpha(w, h, _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pixels, dstOff, dstStep, mask, srcOff, srcStep, color, alpha);\n        }\n    }\n    drawMask(w, h, src, srcOff, srcStep, dst, dstOff, dstStep, rgb) {\n        w |= 0;\n        h |= 0;\n        const hw = -(w >> 2);\n        w = -(w & 0x3);\n        for (let y = -h; y < 0; y++) {\n            for (let x = hw; x < 0; x++) {\n                if (src[srcOff++] === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n                if (src[srcOff++] === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n                if (src[srcOff++] === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n                if (src[srcOff++] === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n            }\n            for (let x = w; x < 0; x++) {\n                if (src[srcOff++] === 0) {\n                    dstOff++;\n                }\n                else {\n                    dst[dstOff++] = rgb;\n                }\n            }\n            dstOff += dstStep;\n            srcOff += srcStep;\n        }\n    }\n    drawMaskAlpha(w, h, dst, dstOff, dstStep, mask, maskOff, maskStep, color, alpha) {\n        w |= 0;\n        h |= 0;\n        const rgb = ((((color & 0xff00ff) * alpha) & 0xff00ff00) + (((color & 0xff00) * alpha) & 0xff0000)) >> 8;\n        const invAlpha = 256 - alpha;\n        for (let y = -h; y < 0; y++) {\n            for (let x = -w; x < 0; x++) {\n                if (mask[maskOff++] === 0) {\n                    dstOff++;\n                }\n                else {\n                    const dstRgb = dst[dstOff];\n                    dst[dstOff++] = (((((dstRgb & 0xff00ff) * invAlpha) & 0xff00ff00) + (((dstRgb & 0xff00) * invAlpha) & 0xff0000)) >> 8) + rgb;\n                }\n            }\n            dstOff += dstStep;\n            maskOff += maskStep;\n        }\n    }\n    evaluateTag(tag) {\n        if (tag === 'red') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].RED;\n        }\n        else if (tag === 'gre') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GREEN;\n        }\n        else if (tag === 'blu') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].BLUE;\n        }\n        else if (tag === 'yel') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].YELLOW;\n        }\n        else if (tag === 'cya') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].CYAN;\n        }\n        else if (tag === 'mag') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].MAGENTA;\n        }\n        else if (tag === 'whi') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].WHITE;\n        }\n        else if (tag === 'bla') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].BLACK;\n        }\n        else if (tag === 'lre') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].LIGHTRED;\n        }\n        else if (tag === 'dre') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].DARKRED;\n        }\n        else if (tag === 'dbl') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].DARKBLUE;\n        }\n        else if (tag === 'or1') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ORANGE1;\n        }\n        else if (tag === 'or2') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ORANGE2;\n        }\n        else if (tag === 'or3') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ORANGE3;\n        }\n        else if (tag === 'gr1') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GREEN1;\n        }\n        else if (tag === 'gr2') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GREEN2;\n        }\n        else if (tag === 'gr3') {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].GREEN3;\n        }\n        else {\n            return _Colors__WEBPACK_IMPORTED_MODULE_4__[\"default\"].BLACK;\n        }\n    }\n    //\n    split(str, maxWidth) {\n        if (str.length === 0) {\n            // special case for empty string\n            return [str];\n        }\n        const lines = [];\n        while (str.length > 0) {\n            // check if the string even needs to be broken up\n            const width = this.stringWidth(str);\n            if (width <= maxWidth && str.indexOf('|') === -1) {\n                lines.push(str);\n                break;\n            }\n            // we need to split on the next word boundary\n            let splitIndex = str.length;\n            // check the width at every space to see where we can cut the line\n            for (let i = 0; i < str.length; i++) {\n                if (str[i] === ' ') {\n                    const w = this.stringWidth(str.substring(0, i));\n                    if (w > maxWidth) {\n                        break;\n                    }\n                    splitIndex = i;\n                }\n                else if (str[i] === '|') {\n                    splitIndex = i;\n                    break;\n                }\n            }\n            lines.push(str.substring(0, splitIndex));\n            str = str.substring(splitIndex + 1);\n        }\n        return lines;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/PixFont.ts?");

/***/ }),

/***/ "./src/js/jagex2/graphics/PixMap.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/graphics/PixMap.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PixMap)\n/* harmony export */ });\n/* harmony import */ var _Draw2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw2D */ \"./src/js/jagex2/graphics/Draw2D.ts\");\n/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Canvas */ \"./src/js/jagex2/graphics/Canvas.ts\");\n\n\nclass PixMap {\n    // constructor\n    image;\n    width;\n    height;\n    ctx;\n    paint;\n    pixels;\n    constructor(width, height, ctx = _Canvas__WEBPACK_IMPORTED_MODULE_1__.canvas2d) {\n        this.ctx = ctx;\n        this.image = this.ctx.getImageData(0, 0, width, height);\n        this.paint = new Uint32Array(this.image.data.buffer);\n        this.pixels = new Int32Array(width * height);\n        this.width = width;\n        this.height = height;\n        this.bind();\n    }\n    clear() {\n        this.pixels.fill(0);\n    }\n    bind() {\n        _Draw2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bind(this.pixels, this.width, this.height);\n    }\n    draw(x, y) {\n        this.#setPixels();\n        this.ctx.putImageData(this.image, x, y);\n    }\n    #setPixels() {\n        const length = this.pixels.length;\n        const pixels = this.pixels;\n        const paint = this.paint;\n        for (let i = 0; i < length; i++) {\n            const pixel = pixels[i];\n            paint[i] = ((pixel >> 16) & 0xff) | (((pixel >> 8) & 0xff) << 8) | ((pixel & 0xff) << 16) | 0xff000000;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/graphics/PixMap.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/ClientProt.ts":
/*!****************************************!*\
  !*** ./src/js/jagex2/io/ClientProt.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ClientProt)\n/* harmony export */ });\nclass ClientProt {\n    static REBUILD_GETMAPS = 150; // index: 4\n    static IDLE_TIMER = 70; // index: 6\n    static NO_TIMEOUT = 108; // index: 30 - NXT naming\n    static EVENT_TRACKING = 81; // index: 34\n    static EVENT_CAMERA_POSITION = 189; // index: 35 - NXT naming\n    // autogenerated as part of obfuscation process\n    static ANTICHEAT_OPLOGIC1 = 7; // index: 60\n    static ANTICHEAT_OPLOGIC2 = 88; // index: 61\n    static ANTICHEAT_OPLOGIC3 = 30; // index: 62\n    static ANTICHEAT_OPLOGIC4 = 176; // index: 63\n    static ANTICHEAT_OPLOGIC5 = 220; // index: 64\n    static ANTICHEAT_OPLOGIC6 = 66; // index: 65\n    static ANTICHEAT_OPLOGIC7 = 17; // index: 66\n    static ANTICHEAT_OPLOGIC8 = 2; // index: 67\n    static ANTICHEAT_OPLOGIC9 = 238; // index: 68\n    // autogenerated as part of obfuscation process\n    static ANTICHEAT_CYCLELOGIC1 = 233; // index: 70\n    static ANTICHEAT_CYCLELOGIC2 = 146; // index: 71\n    static ANTICHEAT_CYCLELOGIC3 = 215; // index: 74\n    static ANTICHEAT_CYCLELOGIC4 = 236; // index: 72\n    static ANTICHEAT_CYCLELOGIC5 = 85; // index: 75\n    static ANTICHEAT_CYCLELOGIC6 = 219; // index: 73\n    static OPOBJ1 = 140; // index: 80 - NXT naming\n    static OPOBJ2 = 40; // index: 81 - NXT naming\n    static OPOBJ3 = 200; // index: 82 - NXT naming\n    static OPOBJ4 = 178; // index: 83 - NXT naming\n    static OPOBJ5 = 247; // index: 84 - NXT naming\n    static OPOBJT = 138; // index: 88 - NXT naming\n    static OPOBJU = 239; // index: 89 - NXT naming\n    static OPNPC1 = 194; // index: 100 - NXT naming\n    static OPNPC2 = 8; // index: 101 - NXT naming\n    static OPNPC3 = 27; // index: 102 - NXT naming\n    static OPNPC4 = 113; // index: 103 - NXT naming\n    static OPNPC5 = 100; // index: 104 - NXT naming\n    static OPNPCT = 134; // index: 108 - NXT naming\n    static OPNPCU = 202; // index: 109 - NXT naming\n    static OPLOC1 = 245; // index: 120 - NXT naming\n    static OPLOC2 = 172; // index: 121 - NXT naming\n    static OPLOC3 = 96; // index: 122 - NXT naming\n    static OPLOC4 = 97; // index: 123 - NXT naming\n    static OPLOC5 = 116; // index: 124 - NXT naming\n    static OPLOCT = 9; // index: 128 - NXT naming\n    static OPLOCU = 75; // index: 129 - NXT naming\n    static OPPLAYER1 = 164; // index: 140 - NXT naming\n    static OPPLAYER2 = 53; // index: 141 - NXT naming\n    static OPPLAYER3 = 185; // index: 142 - NXT naming\n    static OPPLAYER4 = 206; // index: 143 - NXT naming\n    static OPPLAYERT = 177; // index: 148 - NXT naming\n    static OPPLAYERU = 248; // index: 149 - NXT naming\n    static OPHELD1 = 195; // index: 160 - name based on runescript trigger\n    static OPHELD2 = 71; // index: 161 - name based on runescript trigger\n    static OPHELD3 = 133; // index: 162 - name based on runescript trigger\n    static OPHELD4 = 157; // index: 163 - name based on runescript trigger\n    static OPHELD5 = 211; // index: 164 - name based on runescript trigger\n    static OPHELDT = 48; // index: 168 - name based on runescript trigger\n    static OPHELDU = 130; // index: 169 - name based on runescript trigger\n    static INV_BUTTON1 = 31; // index: 190 - NXT has \"IF_BUTTON1\" but for our interface system; this makes more sense\n    static INV_BUTTON2 = 59; // index: 191 - NXT has \"IF_BUTTON2\" but for our interface system; this makes more sense\n    static INV_BUTTON3 = 212; // index: 192 - NXT has \"IF_BUTTON3\" but for our interface system; this makes more sense\n    static INV_BUTTON4 = 38; // index: 193 - NXT has \"IF_BUTTON4\" but for our interface system; this makes more sense\n    static INV_BUTTON5 = 6; // index: 194 - NXT has \"IF_BUTTON5\" but for our interface system; this makes more sense\n    static IF_BUTTON = 155; // index: 200 - NXT naming\n    static RESUME_PAUSEBUTTON = 235; // index: 201 - NXT naming\n    static CLOSE_MODAL = 231; // index: 202 - NXT naming\n    static RESUME_P_COUNTDIALOG = 237; // index: 203 - NXT naming\n    static TUTORIAL_CLICKSIDE = 175; // index: 204\n    static MOVE_OPCLICK = 93; // index: 242 - comes with OP packets; name based on other MOVE packets\n    static BUG_REPORT = 190; // index: 243 - NXT naming\n    static MOVE_MINIMAPCLICK = 165; // index: 244 - NXT naming\n    static INV_BUTTOND = 159; // index: 245 - NXT has \"IF_BUTTOND\" but for our interface system; this makes more sense\n    static IGNORELIST_DEL = 171; // index: 246 - NXT naming\n    static IGNORELIST_ADD = 79; // index: 247 - NXT naming\n    static IF_PLAYERDESIGN = 52; // index: 248\n    static CHAT_SETMODE = 244; // index: 249 - NXT naming\n    static MESSAGE_PRIVATE = 148; // index: 250 - NXT naming\n    static FRIENDLIST_DEL = 11; // index: 251 - NXT naming\n    static FRIENDLIST_ADD = 118; // index: 252 - NXT naming\n    static CLIENT_CHEAT = 4; // index: 253 - NXT naming\n    static MESSAGE_PUBLIC = 158; // index: 254 - NXT naming\n    static MOVE_GAMECLICK = 181; // index: 255 - NXT naming\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/ClientProt.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/ClientStream.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/io/ClientStream.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ClientStream)\n/* harmony export */ });\n/* harmony import */ var _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datastruct/LinkList */ \"./src/js/jagex2/datastruct/LinkList.ts\");\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n\n\nclass ClientStream {\n    // constructor\n    socket;\n    wsin;\n    wsout;\n    // runtime\n    closed = false;\n    ioerror = false;\n    static openSocket = async (socket) => {\n        return await new Promise((resolve, reject) => {\n            const secured = socket.host.startsWith('https');\n            const protocol = secured ? 'wss' : 'ws';\n            const host = socket.host.substring(socket.host.indexOf('//') + 2);\n            const port = secured ? socket.port + 2 : socket.port + 1;\n            const ws = new WebSocket(`${protocol}://${host}:${port}`, 'binary');\n            ws.addEventListener('open', () => {\n                console.log('connection open!');\n                resolve(ws);\n            });\n            ws.addEventListener('error', () => {\n                console.log('connection error!');\n                reject(ws);\n            });\n        });\n    };\n    constructor(socket) {\n        socket.onclose = this.onclose;\n        socket.onerror = this.onerror;\n        this.wsin = new WebSocketReader(socket, 5000);\n        this.wsout = new WebSocketWriter(socket, 5000);\n        this.socket = socket;\n    }\n    get host() {\n        return this.socket.url.split('/')[2];\n    }\n    get port() {\n        return parseInt(this.socket.url.split(':')[2], 10);\n    }\n    get available() {\n        return this.closed ? 0 : this.wsin.available;\n    }\n    write(src, len) {\n        this.wsout.write(src, len);\n    }\n    async read() {\n        return this.closed ? 0 : this.wsin.fastByte() ?? (await this.wsin.slowByte());\n    }\n    async readBytes(dst, off, len) {\n        if (this.closed) {\n            return;\n        }\n        while (len > 0) {\n            const read = this.wsin.fastBytes(dst, off, len) ?? (await this.wsin.slowBytes(dst, off, len));\n            if (read.length <= 0) {\n                throw new Error('EOF');\n            }\n            off += read.length;\n            len -= read.length;\n        }\n    }\n    close() {\n        this.closed = true;\n        this.socket.close();\n        this.wsin.close();\n        this.wsout.close();\n        console.log('connection close!');\n        if (this.ioerror) {\n            console.log('connection error!');\n        }\n    }\n    onclose = (event) => {\n        if (this.closed) {\n            return;\n        }\n        this.close();\n    };\n    onerror = (event) => {\n        if (this.closed) {\n            return;\n        }\n        this.ioerror = true;\n        this.close();\n    };\n}\nclass WebSocketWriter {\n    // constructor\n    socket;\n    limit;\n    closed = false;\n    ioerror = false;\n    constructor(socket, limit) {\n        this.socket = socket;\n        this.limit = limit;\n    }\n    write(src, len) {\n        if (this.closed) {\n            return;\n        }\n        if (this.ioerror) {\n            this.ioerror = false;\n            throw new Error('Error in writer thread');\n        }\n        if (len > this.limit || src.length > this.limit) {\n            throw new Error('buffer overflow');\n        }\n        try {\n            this.socket.send(src.subarray(0, len));\n        }\n        catch (e) {\n            this.ioerror = true;\n        }\n    }\n    close() {\n        this.closed = true;\n    }\n}\nclass WebSocketEvent extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    bytes;\n    position;\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n        this.position = 0;\n    }\n    get available() {\n        return this.bytes.length - this.position;\n    }\n    get read() {\n        return this.bytes[this.position++];\n    }\n    get len() {\n        return this.bytes.length;\n    }\n}\nclass WebSocketReader {\n    // constructor\n    limit;\n    // runtime\n    queue = new _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    event = null;\n    callback = null;\n    total = 0;\n    closed = false;\n    constructor(socket, limit) {\n        this.limit = limit;\n        socket.binaryType = 'arraybuffer';\n        socket.onmessage = this.onmessage;\n    }\n    get available() {\n        return this.total;\n    }\n    onmessage = (e) => {\n        if (this.closed) {\n            throw new Error('WebSocketReader is closed!');\n        }\n        const event = new WebSocketEvent(new Uint8Array(e.data));\n        if (this.event) {\n            this.queue.addTail(event);\n        }\n        else {\n            this.event = event;\n        }\n        this.total += event.len;\n        if (!this.callback) {\n            return;\n        }\n        this.callback(this.event);\n        this.callback = null;\n        // check for the overflow after the callback\n        if (this.total > this.limit) {\n            throw new Error('buffer overflow');\n        }\n    };\n    readFastByte() {\n        if (this.event && this.event.available > 0) {\n            return this.event.read;\n        }\n        return null;\n    }\n    async readSlowByte(len) {\n        this.event = this.queue.removeHead();\n        while (this.total < len) {\n            await new Promise((resolve) => (this.callback = resolve));\n        }\n        return this.event ? this.event.read : this.readSlowByte(len);\n    }\n    fastBytes(dst, off, len) {\n        if (this.closed) {\n            throw new Error('WebSocketReader is closed!');\n        }\n        if (!(this.event && this.event.available >= len)) {\n            return null;\n        }\n        while (len > 0) {\n            const fast = this.readFastByte();\n            if (fast === null) {\n                throw new Error('EOF - tried to read a fast byte when there was not enough immediate bytes.');\n            }\n            dst[off++] = fast;\n            this.total--;\n            len--;\n        }\n        return dst;\n    }\n    async slowBytes(dst, off, len) {\n        if (this.closed) {\n            throw new Error('WebSocketReader is closed!');\n        }\n        while (len > 0) {\n            dst[off++] = this.readFastByte() ?? (await this.readSlowByte(len));\n            this.total--;\n            len--;\n        }\n        return dst;\n    }\n    fastByte() {\n        if (this.closed) {\n            throw new Error('WebSocketReader is closed!');\n        }\n        const fast = this.readFastByte();\n        if (fast === null) {\n            return null;\n        }\n        this.total--;\n        return fast;\n    }\n    async slowByte() {\n        if (this.closed) {\n            throw new Error('WebSocketReader is closed!');\n        }\n        const slow = await this.readSlowByte(1);\n        this.total--;\n        return slow;\n    }\n    close() {\n        this.closed = true;\n        this.callback = null;\n        this.total = 0;\n        this.event = null;\n        this.queue.clear();\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/ClientStream.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/ClientWorkerStream.ts":
/*!************************************************!*\
  !*** ./src/js/jagex2/io/ClientWorkerStream.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ClientWorkerStream)\n/* harmony export */ });\n/* harmony import */ var _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../datastruct/LinkList */ \"./src/js/jagex2/datastruct/LinkList.ts\");\n/* harmony import */ var _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../datastruct/Linkable */ \"./src/js/jagex2/datastruct/Linkable.ts\");\n/* harmony import */ var _util_JsUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/JsUtil */ \"./src/js/jagex2/util/JsUtil.ts\");\n\n\n\nclass ClientWorkerStream {\n    // constructor\n    worker;\n    wwin;\n    wwout;\n    // runtime\n    closed = false;\n    ioerror = false;\n    constructor() {\n        this.worker = new Worker('app.js', { type: 'module' });\n        this.wwin = new WorkerReader(this.worker, 5000);\n        this.wwout = new WorkerWriter(this.worker, 5000);\n    }\n    get available() {\n        return this.closed ? 0 : this.wwin.available;\n    }\n    write(src, len) {\n        this.wwout.write(src, len);\n    }\n    async read() {\n        return this.closed ? 0 : this.wwin.fastByte() ?? (await this.wwin.slowByte());\n    }\n    async readBytes(dst, off, len) {\n        if (this.closed) {\n            return;\n        }\n        while (len > 0) {\n            const read = this.wwin.fastBytes(dst, off, len) ?? (await this.wwin.slowBytes(dst, off, len));\n            if (read.length <= 0) {\n                throw new Error('EOF');\n            }\n            off += read.length;\n            len -= read.length;\n        }\n    }\n    close() {\n        this.closed = true;\n        this.worker.terminate();\n        this.wwin.close();\n        this.wwout.close();\n        console.log('connection close!');\n        if (this.ioerror) {\n            console.log('connection error!');\n        }\n    }\n    // private onclose = (event: CloseEvent): void => {\n    //     if (this.closed) {\n    //         return;\n    //     }\n    //     this.close();\n    // };\n    // private onerror = (event: Event): void => {\n    //     if (this.closed) {\n    //         return;\n    //     }\n    //     this.ioerror = true;\n    //     this.close();\n    // };\n    onerror = (event) => {\n        console.error('Error:', event);\n    };\n    onmessage = (event) => {\n        console.log('Message:', event);\n    };\n    onmessageerror = (event) => {\n        console.log('Message error:', event);\n    };\n}\nclass WorkerWriter {\n    // constructor\n    worker;\n    limit;\n    closed = false;\n    ioerror = false;\n    constructor(socket, limit) {\n        this.worker = socket;\n        this.limit = limit;\n    }\n    write(src, len) {\n        if (this.closed) {\n            return;\n        }\n        if (this.ioerror) {\n            this.ioerror = false;\n            throw new Error('Error in writer thread');\n        }\n        if (len > this.limit || src.length > this.limit) {\n            throw new Error('buffer overflow');\n        }\n        try {\n            this.worker.postMessage(src.subarray(0, len));\n        }\n        catch (e) {\n            this.ioerror = true;\n        }\n    }\n    close() {\n        this.closed = true;\n    }\n}\nclass WorkerEvent extends _datastruct_Linkable__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    bytes;\n    position;\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n        this.position = 0;\n    }\n    get available() {\n        return this.bytes.length - this.position;\n    }\n    get read() {\n        return this.bytes[this.position++];\n    }\n    get len() {\n        return this.bytes.length;\n    }\n}\nclass WorkerReader {\n    // constructor\n    limit;\n    // runtime\n    queue = new _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    event = null;\n    callback = null;\n    total = 0;\n    closed = false;\n    constructor(worker, limit) {\n        this.limit = limit;\n        worker.onmessage = this.onmessage;\n    }\n    get available() {\n        return this.total;\n    }\n    onmessage = (e) => {\n        if (this.closed) {\n            throw new Error('WorkerReader is closed!');\n        }\n        const event = new WorkerEvent(new Uint8Array(e.data));\n        if (this.event) {\n            this.queue.addTail(event);\n        }\n        else {\n            this.event = event;\n        }\n        this.total += event.len;\n        if (!this.callback) {\n            return;\n        }\n        this.callback(this.event);\n        this.callback = null;\n        // check for the overflow after the callback\n        if (this.total > this.limit) {\n            throw new Error('buffer overflow');\n        }\n    };\n    readFastByte() {\n        if (this.event && this.event.available > 0) {\n            return this.event.read;\n        }\n        return null;\n    }\n    async readSlowByte(len) {\n        this.event = this.queue.removeHead();\n        while (this.total < len) {\n            await Promise.race([\n                new Promise((resolve) => (this.callback = resolve)),\n                (0,_util_JsUtil__WEBPACK_IMPORTED_MODULE_2__.sleep)(20000).then(() => {\n                    throw new Error('WorkerReader timed out or closed while reading.');\n                })\n            ]);\n        }\n        return this.event ? this.event.read : this.readSlowByte(len);\n    }\n    fastBytes(dst, off, len) {\n        if (this.closed) {\n            throw new Error('WorkerReader is closed!');\n        }\n        if (!(this.event && this.event.available >= len)) {\n            return null;\n        }\n        while (len > 0) {\n            const fast = this.readFastByte();\n            if (fast === null) {\n                throw new Error('EOF - tried to read a fast byte when there was not enough immediate bytes.');\n            }\n            dst[off++] = fast;\n            this.total--;\n            len--;\n        }\n        return dst;\n    }\n    async slowBytes(dst, off, len) {\n        if (this.closed) {\n            throw new Error('WorkerReader is closed!');\n        }\n        while (len > 0) {\n            dst[off++] = this.readFastByte() ?? (await this.readSlowByte(len));\n            this.total--;\n            len--;\n        }\n        return dst;\n    }\n    fastByte() {\n        if (this.closed) {\n            throw new Error('WorkerReader is closed!');\n        }\n        const fast = this.readFastByte();\n        if (fast === null) {\n            return null;\n        }\n        this.total--;\n        return fast;\n    }\n    async slowByte() {\n        if (this.closed) {\n            throw new Error('WorkerReader is closed!');\n        }\n        const slow = await this.readSlowByte(1);\n        this.total--;\n        return slow;\n    }\n    close() {\n        this.closed = true;\n        this.callback = null;\n        this.total = 0;\n        this.event = null;\n        this.queue.clear();\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/ClientWorkerStream.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/Database.ts":
/*!**************************************!*\
  !*** ./src/js/jagex2/io/Database.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Database)\n/* harmony export */ });\nclass Database {\n    db;\n    constructor(db) {\n        db.onerror = this.onerror;\n        db.onclose = this.onclose;\n        this.db = db;\n    }\n    static openDatabase = async () => {\n        return await new Promise((resolve, reject) => {\n            const request = indexedDB.open('lostcity', 1);\n            request.onsuccess = (event) => {\n                const target = event.target;\n                console.log('database success!');\n                resolve(target.result);\n            };\n            request.onupgradeneeded = (event) => {\n                const target = event.target;\n                target.result.createObjectStore('cache');\n            };\n            request.onerror = (event) => {\n                const target = event.target;\n                console.error('database error!: ', target.error);\n                reject(target.result);\n            };\n        });\n    };\n    cacheload = async (name) => {\n        return await new Promise((resolve) => {\n            const transaction = this.db.transaction('cache', 'readonly');\n            const store = transaction.objectStore('cache');\n            const request = store.get(name); // this.genHash(name)\n            request.onsuccess = () => {\n                // console.log('cacheload successful!');\n                resolve(request.result);\n            };\n            request.onerror = (event) => {\n                // console.error('cacheload error!:', event);\n                resolve(undefined);\n            };\n        });\n    };\n    cachesave = async (name, src) => {\n        return await new Promise((resolve, reject) => {\n            // if (src.length > 2000000) {\n            //     reject();\n            //     return;\n            // }\n            const transaction = this.db.transaction('cache', 'readwrite');\n            const store = transaction.objectStore('cache');\n            const request = store.put(src, name); // this.genHash(name)\n            request.onsuccess = () => {\n                // console.log('cachesave successful!');\n                resolve();\n            };\n            request.onerror = (event) => {\n                // console.error('cachesave error!:', event);\n                reject();\n            };\n        });\n    };\n    onclose = (event) => {\n        console.log('database close!');\n    };\n    onerror = (event) => {\n        console.log('database error!');\n    };\n    genHash = (str) => {\n        const trimmed = str.trim();\n        let hash = 0;\n        for (let i = 0; i < trimmed.length && i < 12; i++) {\n            const c = trimmed.charAt(i);\n            hash *= 37;\n            if (c >= 'A' && c <= 'Z') {\n                hash += c.charCodeAt(0) + 1 - 65;\n            }\n            else if (c >= 'a' && c <= 'z') {\n                hash += c.charCodeAt(0) + 1 - 97;\n            }\n            else if (c >= '0' && c <= '9') {\n                hash += c.charCodeAt(0) + 27 - 48;\n            }\n        }\n        return hash;\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/Database.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/Isaac.ts":
/*!***********************************!*\
  !*** ./src/js/jagex2/io/Isaac.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Isaac)\n/* harmony export */ });\nclass Isaac {\n    count = 0;\n    rsl = new Int32Array(256);\n    mem = new Int32Array(256);\n    a = 0;\n    b = 0;\n    c = 0;\n    constructor(seed) {\n        for (let i = 0; i < seed.length; i++) {\n            this.rsl[i] = seed[i];\n        }\n        this.init();\n    }\n    get nextInt() {\n        if (this.count-- === 0) {\n            this.isaac();\n            this.count = 255;\n        }\n        return this.rsl[this.count];\n    }\n    init() {\n        let a = 0x9e3779b9, b = 0x9e3779b9, c = 0x9e3779b9, d = 0x9e3779b9, e = 0x9e3779b9, f = 0x9e3779b9, g = 0x9e3779b9, h = 0x9e3779b9;\n        for (let i = 0; i < 4; i++) {\n            a ^= b << 11;\n            d += a;\n            b += c;\n            b ^= c >>> 2;\n            e += b;\n            c += d;\n            c ^= d << 8;\n            f += c;\n            d += e;\n            d ^= e >>> 16;\n            g += d;\n            e += f;\n            e ^= f << 10;\n            h += e;\n            f += g;\n            f ^= g >>> 4;\n            a += f;\n            g += h;\n            g ^= h << 8;\n            b += g;\n            h += a;\n            h ^= a >>> 9;\n            c += h;\n            a += b;\n        }\n        for (let i = 0; i < 256; i += 8) {\n            a += this.rsl[i];\n            b += this.rsl[i + 1];\n            c += this.rsl[i + 2];\n            d += this.rsl[i + 3];\n            e += this.rsl[i + 4];\n            f += this.rsl[i + 5];\n            g += this.rsl[i + 6];\n            h += this.rsl[i + 7];\n            a ^= b << 11;\n            d += a;\n            b += c;\n            b ^= c >>> 2;\n            e += b;\n            c += d;\n            c ^= d << 8;\n            f += c;\n            d += e;\n            d ^= e >>> 16;\n            g += d;\n            e += f;\n            e ^= f << 10;\n            h += e;\n            f += g;\n            f ^= g >>> 4;\n            a += f;\n            g += h;\n            g ^= h << 8;\n            b += g;\n            h += a;\n            h ^= a >>> 9;\n            c += h;\n            a += b;\n            this.mem[i] = a;\n            this.mem[i + 1] = b;\n            this.mem[i + 2] = c;\n            this.mem[i + 3] = d;\n            this.mem[i + 4] = e;\n            this.mem[i + 5] = f;\n            this.mem[i + 6] = g;\n            this.mem[i + 7] = h;\n        }\n        for (let i = 0; i < 256; i += 8) {\n            a += this.mem[i];\n            b += this.mem[i + 1];\n            c += this.mem[i + 2];\n            d += this.mem[i + 3];\n            e += this.mem[i + 4];\n            f += this.mem[i + 5];\n            g += this.mem[i + 6];\n            h += this.mem[i + 7];\n            a ^= b << 11;\n            d += a;\n            b += c;\n            b ^= c >>> 2;\n            e += b;\n            c += d;\n            c ^= d << 8;\n            f += c;\n            d += e;\n            d ^= e >>> 16;\n            g += d;\n            e += f;\n            e ^= f << 10;\n            h += e;\n            f += g;\n            f ^= g >>> 4;\n            a += f;\n            g += h;\n            g ^= h << 8;\n            b += g;\n            h += a;\n            h ^= a >>> 9;\n            c += h;\n            a += b;\n            this.mem[i] = a;\n            this.mem[i + 1] = b;\n            this.mem[i + 2] = c;\n            this.mem[i + 3] = d;\n            this.mem[i + 4] = e;\n            this.mem[i + 5] = f;\n            this.mem[i + 6] = g;\n            this.mem[i + 7] = h;\n        }\n        this.isaac();\n        this.count = 256;\n    }\n    isaac() {\n        this.c++;\n        this.b += this.c;\n        for (let i = 0; i < 256; i++) {\n            const x = this.mem[i];\n            const mem = i & 3;\n            if (mem === 0) {\n                this.a ^= this.a << 13;\n            }\n            else if (mem === 1) {\n                this.a ^= this.a >>> 6;\n            }\n            else if (mem === 2) {\n                this.a ^= this.a << 2;\n            }\n            else if (mem === 3) {\n                this.a ^= this.a >>> 16;\n            }\n            this.a += this.mem[(i + 128) & 0xff];\n            let y;\n            this.mem[i] = y = this.mem[(x >>> 2) & 0xff] + this.a + this.b;\n            this.rsl[i] = this.b = this.mem[((y >>> 8) >>> 2) & 0xff] + x;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/Isaac.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/Jagfile.ts":
/*!*************************************!*\
  !*** ./src/js/jagex2/io/Jagfile.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Jagfile)\n/* harmony export */ });\n/* harmony import */ var _Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _vendor_bzip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../vendor/bzip */ \"./src/js/vendor/bzip.ts\");\n\n\nclass Jagfile {\n    static genHash = (name) => {\n        let hash = 0;\n        name = name.toUpperCase();\n        for (let i = 0; i < name.length; i++) {\n            hash = (hash * 61 + name.charCodeAt(i) - 32) | 0; // wtf?\n        }\n        return hash;\n    };\n    // constructor\n    buffer;\n    compressedWhole;\n    fileCount;\n    fileHash;\n    fileUnpackedSize;\n    filePackedSize;\n    fileOffset;\n    fileUnpacked = [];\n    constructor(src) {\n        if (src instanceof Uint8Array) {\n            src = new Int8Array(src);\n        }\n        let data = new _Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new Uint8Array(src));\n        const unpackedSize = data.g3;\n        const packedSize = data.g3;\n        if (unpackedSize === packedSize) {\n            this.buffer = src;\n            this.compressedWhole = false;\n        }\n        else {\n            this.buffer = _vendor_bzip__WEBPACK_IMPORTED_MODULE_1__[\"default\"].read(unpackedSize, src, packedSize, 6);\n            data = new _Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](new Uint8Array(this.buffer));\n            this.compressedWhole = true;\n        }\n        this.fileCount = data.g2;\n        this.fileHash = [];\n        this.fileUnpackedSize = [];\n        this.filePackedSize = [];\n        this.fileOffset = [];\n        let offset = data.pos + this.fileCount * 10;\n        for (let i = 0; i < this.fileCount; i++) {\n            this.fileHash.push(data.g4);\n            this.fileUnpackedSize.push(data.g3);\n            this.filePackedSize.push(data.g3);\n            this.fileOffset.push(offset);\n            offset += this.filePackedSize[i];\n        }\n    }\n    read(name) {\n        const hash = Jagfile.genHash(name);\n        const index = this.fileHash.indexOf(hash);\n        if (index === -1) {\n            return null;\n        }\n        return this.readIndex(index);\n    }\n    readIndex(index) {\n        if (index < 0 || index >= this.fileCount) {\n            return null;\n        }\n        if (this.fileUnpacked[index]) {\n            return this.fileUnpacked[index];\n        }\n        const offset = this.fileOffset[index];\n        const length = offset + this.filePackedSize[index];\n        if (this.compressedWhole) {\n            const data = Uint8Array.from(this.buffer.subarray(offset, offset + length));\n            this.fileUnpacked[index] = data;\n            return data;\n        }\n        else {\n            const data = Uint8Array.from(_vendor_bzip__WEBPACK_IMPORTED_MODULE_1__[\"default\"].read(this.fileUnpackedSize[index], this.buffer, this.filePackedSize[index], this.fileOffset[index]));\n            this.fileUnpacked[index] = data;\n            return data;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/Jagfile.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/Packet.ts":
/*!************************************!*\
  !*** ./src/js/jagex2/io/Packet.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Packet)\n/* harmony export */ });\n/* harmony import */ var _util_JsUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/JsUtil */ \"./src/js/jagex2/util/JsUtil.ts\");\n/* harmony import */ var _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../datastruct/LinkList */ \"./src/js/jagex2/datastruct/LinkList.ts\");\n/* harmony import */ var _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../datastruct/Hashable */ \"./src/js/jagex2/datastruct/Hashable.ts\");\n/* harmony import */ var _client_GameShell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../client/GameShell */ \"./src/js/jagex2/client/GameShell.ts\");\n\n\n\n\nclass Packet extends _datastruct_Hashable__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    static CRC32_POLYNOMIAL = 0xedb88320;\n    static crctable = new Int32Array(256);\n    static bitmask = new Uint32Array(33);\n    static cacheMin = new _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    static cacheMid = new _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    static cacheMax = new _datastruct_LinkList__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    static cacheMinCount = 0;\n    static cacheMidCount = 0;\n    static cacheMaxCount = 0;\n    static {\n        for (let i = 0; i < 32; i++) {\n            Packet.bitmask[i] = (1 << i) - 1;\n        }\n        Packet.bitmask[32] = 0xffffffff;\n        for (let i = 0; i < 256; i++) {\n            let remainder = i;\n            for (let bit = 0; bit < 8; bit++) {\n                if ((remainder & 1) === 1) {\n                    remainder = (remainder >>> 1) ^ Packet.CRC32_POLYNOMIAL;\n                }\n                else {\n                    remainder >>>= 1;\n                }\n            }\n            Packet.crctable[i] = remainder;\n        }\n    }\n    static crc32 = (src) => {\n        let crc = 0xffffffff;\n        for (let i = 0; i < src.length; i++) {\n            crc = (crc >>> 8) ^ Packet.crctable[(crc ^ src[i]) & 0xff];\n        }\n        return ~crc;\n    };\n    // constructor\n    view;\n    data;\n    // runtime\n    pos = 0;\n    bitPos = 0;\n    random = null;\n    constructor(src) {\n        if (!src) {\n            throw new Error('Input src packet array was null!');\n        }\n        super();\n        if (src instanceof Int8Array) {\n            this.data = new Uint8Array(src);\n        }\n        else {\n            this.data = src;\n        }\n        this.view = new DataView(this.data.buffer);\n    }\n    get length() {\n        return this.view.byteLength;\n    }\n    get available() {\n        return this.length - this.pos;\n    }\n    static alloc = (type) => {\n        let cached = null;\n        if (type === 0 && Packet.cacheMinCount > 0) {\n            Packet.cacheMinCount--;\n            cached = Packet.cacheMin.removeHead();\n        }\n        else if (type === 1 && Packet.cacheMidCount > 0) {\n            Packet.cacheMidCount--;\n            cached = Packet.cacheMid.removeHead();\n        }\n        else if (type === 2 && Packet.cacheMaxCount > 0) {\n            Packet.cacheMaxCount--;\n            cached = Packet.cacheMax.removeHead();\n        }\n        if (cached) {\n            cached.pos = 0;\n            return cached;\n        }\n        if (type === 0) {\n            return new Packet(new Uint8Array(100));\n        }\n        else if (type === 1) {\n            return new Packet(new Uint8Array(5000));\n        }\n        return new Packet(new Uint8Array(30000));\n    };\n    release() {\n        this.pos = 0;\n        if (this.view.byteLength === 100 && Packet.cacheMinCount < 1000) {\n            Packet.cacheMin.addTail(this);\n            Packet.cacheMinCount++;\n        }\n        else if (this.view.byteLength === 5000 && Packet.cacheMidCount < 250) {\n            Packet.cacheMid.addTail(this);\n            Packet.cacheMidCount++;\n        }\n        else if (this.view.byteLength === 30000 && Packet.cacheMaxCount < 50) {\n            Packet.cacheMax.addTail(this);\n            Packet.cacheMaxCount++;\n        }\n    }\n    get g1() {\n        return this.view.getUint8(this.pos++);\n    }\n    // signed\n    get g1b() {\n        return this.view.getInt8(this.pos++);\n    }\n    get g2() {\n        const result = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return result;\n    }\n    // signed\n    get g2b() {\n        const result = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return result;\n    }\n    get g3() {\n        const result = (this.view.getUint8(this.pos++) << 16) | this.view.getUint16(this.pos);\n        this.pos += 2;\n        return result;\n    }\n    get g4() {\n        const result = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return result;\n    }\n    get g8() {\n        const result = this.view.getBigInt64(this.pos);\n        this.pos += 8;\n        return result;\n    }\n    get gsmart() {\n        return this.view.getUint8(this.pos) < 0x80 ? this.g1 - 0x40 : this.g2 - 0xc000;\n    }\n    // signed\n    get gsmarts() {\n        return this.view.getUint8(this.pos) < 0x80 ? this.g1 : this.g2 - 0x8000;\n    }\n    get gjstr() {\n        const view = this.view;\n        const length = view.byteLength;\n        let str = '';\n        let b;\n        while ((b = view.getUint8(this.pos++)) !== 10 && this.pos < length) {\n            str += String.fromCharCode(b);\n        }\n        return str;\n    }\n    gdata(length, offset, dest) {\n        const view = this.view;\n        const total = offset + length;\n        for (let i = offset; i < total; i++) {\n            dest[i] = view.getUint8(this.pos++);\n        }\n    }\n    p1isaac(opcode) {\n        this.view.setUint8(this.pos++, (opcode + (this.random?.nextInt ?? 0)) & 0xff);\n    }\n    p1(value) {\n        this.view.setUint8(this.pos++, value);\n    }\n    p2(value) {\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    }\n    ip2(value) {\n        this.view.setUint16(this.pos, value, true);\n        this.pos += 2;\n    }\n    p3(value) {\n        this.view.setUint8(this.pos++, value >> 16);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    }\n    p4(value) {\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    }\n    ip4(value) {\n        this.view.setInt32(this.pos, value, true);\n        this.pos += 4;\n    }\n    p8(value) {\n        this.view.setBigInt64(this.pos, value);\n        this.pos += 8;\n    }\n    pjstr(str) {\n        const view = this.view;\n        const length = str.length;\n        for (let i = 0; i < length; i++) {\n            view.setUint8(this.pos++, str.charCodeAt(i));\n        }\n        view.setUint8(this.pos++, 10);\n    }\n    pdata(src, length, offset) {\n        const view = this.view;\n        const total = offset + length;\n        for (let i = offset; i < total; i++) {\n            view.setUint8(this.pos++, src[i]);\n        }\n    }\n    psize1(size) {\n        this.view.setUint8(this.pos - size - 1, size);\n    }\n    bits() {\n        this.bitPos = this.pos * 8;\n    }\n    bytes() {\n        this.pos = ((this.bitPos + 7) / 8) | 0;\n    }\n    gBit(n) {\n        let bytePos = this.bitPos >>> 3;\n        let remaining = 8 - (this.bitPos & 7);\n        let value = 0;\n        this.bitPos += n;\n        for (; n > remaining; remaining = 8) {\n            value += (this.view.getUint8(bytePos++) & Packet.bitmask[remaining]) << (n - remaining);\n            n -= remaining;\n        }\n        if (n === remaining) {\n            value += this.view.getUint8(bytePos) & Packet.bitmask[remaining];\n        }\n        else {\n            value += (this.view.getUint8(bytePos) >>> (remaining - n)) & Packet.bitmask[n];\n        }\n        return value;\n    }\n    rsaenc(mod, exp) {\n        const length = this.pos;\n        this.pos = 0;\n        const temp = new Uint8Array(length);\n        this.gdata(length, 0, temp);\n        const bigRaw = (0,_util_JsUtil__WEBPACK_IMPORTED_MODULE_0__.bytesToBigInt)(temp);\n        const bigEnc = _client_GameShell__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getParameter('worker') === '0' ? (0,_util_JsUtil__WEBPACK_IMPORTED_MODULE_0__.bigIntModPow)(bigRaw, exp, mod) : bigRaw;\n        const rawEnc = (0,_util_JsUtil__WEBPACK_IMPORTED_MODULE_0__.bigIntToBytes)(bigEnc);\n        this.pos = 0;\n        this.p1(rawEnc.length);\n        this.pdata(rawEnc, rawEnc.length, 0);\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/Packet.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/Protocol.ts":
/*!**************************************!*\
  !*** ./src/js/jagex2/io/Protocol.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Protocol)\n/* harmony export */ });\nclass Protocol {\n    // prettier-ignore\n    static CLIENTPROT_SCRAMBLED = [\n        95, 218, 67, 50, 253, 222, 194, 60, 101, 128,\n        8, 251, 92, 111, 24, 33, 223, 66, 232, 59,\n        227, 113, 153, 105, 126, 98, 167, 102, 177,\n        238, 62, 190, 147, 23, 150, 151, 156, 144,\n        193, 155, 81, 0, 198, 22, 137, 210, 179, 16,\n        168, 170, 32, 181, 248, 141, 58, 87, 208, 106,\n        180, 191, 221, 241, 40, 176, 196, 154, 65, 145,\n        230, 78, 30, 161, 188, 41, 14, 129, 18, 199,\n        47, 247, 225, 34, 51, 10, 159, 75, 12, 56, 61,\n        31, 39, 91, 46, 242, 134, 5, 122, 123, 209,\n        228, 104, 195, 21, 3, 11, 44, 107, 172, 6,\n        186, 110, 215, 205, 103, 27, 185, 124, 77, 252,\n        117, 86, 115, 127, 207, 52, 79, 43, 97, 219,\n        116, 169, 7, 118, 162, 108, 36, 20, 233, 88,\n        135, 80, 19, 42, 237, 57, 152, 71, 9, 250, 17,\n        4, 119, 234, 130, 26, 200, 189, 163, 254, 245,\n        197, 171, 220, 235, 140, 244, 184, 94, 211, 231,\n        99, 246, 121, 212, 112, 204, 63, 148, 83, 178,\n        1, 255, 131, 13, 183, 142, 236, 45, 55, 35, 243,\n        136, 37, 85, 100, 160, 38, 224, 146, 174, 82, 48,\n        109, 132, 125, 90, 143, 138, 240, 173, 165, 164,\n        192, 175, 29, 74, 28, 114, 213, 73, 64, 206, 76,\n        139, 96, 2, 229, 15, 93, 25, 239, 202, 49, 70,\n        214, 201, 72, 203, 68, 89, 69, 157, 216, 217,\n        249, 120, 226, 84, 149, 187, 54, 53, 158, 166,\n        182, 133, 0\n    ];\n    // prettier-ignore\n    static SERVERPROT_SIZES = [\n        0, -2, 4, 6, -1, 0, 0, 2, 0, 0,\n        0, 0, 5, 4, 2, 2, 0, 0, 0, 0, 2,\n        -2, 2, 14, 0, 6, 3, 0, 4, 0, 0,\n        0, 3, 0, 0, 0, 0, 0, 0, 0, 0, -1,\n        4, 2, 6, 0, 6, 0, 0, 3, 7, 0, 0,\n        0, -1, 0, 0, 0, 0, 4, 0, 0, 0, 0,\n        0, 0, 0, 0, 1, 15, 0, 0, 0, 0, 6,\n        0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 0,\n        0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        -2, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,\n        -2, 0, 0, 2, 0, 0, 0, 2, 9, 0, 0, 0,\n        0, 0, 4, 0, 0, 0, 3, 7, 9, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, -2, 0, 0, 0, 0, 3,\n        2, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0,\n        0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 6,\n        0, 0, 0, 2, 0, 2, 0, 0, 0, -2, 0, 0,\n        4, 0, 0, 0, 0, 6, 0, 0, -2, -2, 0, 0,\n        0, 0, 0, 0, -2, 0, 0, 5, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 1, 0, 0\n    ];\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/Protocol.ts?");

/***/ }),

/***/ "./src/js/jagex2/io/ServerProt.ts":
/*!****************************************!*\
  !*** ./src/js/jagex2/io/ServerProt.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ServerProt)\n/* harmony export */ });\nclass ServerProt {\n    // interfaces\n    static IF_OPENCHATMODAL = 14;\n    static IF_OPENMAINSIDEMODAL = 28;\n    static IF_CLOSE = 129; // NXT has \"static readonly IF_CLOSESUB\"\n    static IF_OPENSIDEOVERLAY = 167;\n    static IF_OPENMAINMODAL = 168;\n    static IF_OPENSIDEMODAL = 195;\n    // updating interfaces\n    static IF_SETCOLOUR = 2; // NXT naming\n    static IF_SETHIDE = 26; // NXT naming\n    static IF_SETOBJECT = 46; // NXT naming\n    static IF_SHOWSIDE = 84;\n    static IF_SETMODEL = 87; // NXT naming\n    static IF_SETRECOL = 103; // NXT naming\n    static IF_SETANIM = 146; // NXT naming\n    static IF_SETPLAYERHEAD = 197; // NXT naming\n    static IF_SETTEXT = 201; // NXT naming\n    static IF_SETNPCHEAD = 204; // NXT naming\n    static IF_SETPOSITION = 209; // NXT naming\n    // tutorial area\n    static TUTORIAL_FLASHSIDE = 126;\n    static TUTORIAL_OPENCHAT = 185;\n    // inventory\n    static UPDATE_INV_STOP_TRANSMIT = 15; // NXT naming\n    static UPDATE_INV_FULL = 98; // NXT naming\n    static UPDATE_INV_PARTIAL = 213; // NXT naming\n    // camera control\n    static CAM_LOOKAT = 74; // NXT naming\n    static CAM_SHAKE = 13; // NXT naming\n    static CAM_MOVETO = 3; // NXT naming\n    static CAM_RESET = 239; // NXT naming\n    // entity updates\n    static NPC_INFO = 1; // NXT naming\n    static PLAYER_INFO = 184; // NXT naming\n    // input tracking\n    static FINISH_TRACKING = 133;\n    static ENABLE_TRACKING = 226;\n    // social\n    static MESSAGE_GAME = 4; // NXT naming\n    static UPDATE_IGNORELIST = 21; // NXT naming\n    static CHAT_FILTER_SETTINGS = 32; // NXT naming\n    static MESSAGE_PRIVATE = 41; // NXT naming\n    static UPDATE_FRIENDLIST = 152; // NXT naming\n    // misc\n    static UNSET_MAP_FLAG = 19; // NXT has \"SET_MAP_FLAG\" but we cannot control the position\n    static UPDATE_RUNWEIGHT = 22; // NXT naming\n    static HINT_ARROW = 25; // NXT naming\n    static UPDATE_REBOOT_TIMER = 43; // NXT naming\n    static UPDATE_STAT = 44; // NXT naming\n    static UPDATE_RUNENERGY = 68; // NXT naming\n    static RESET_ANIMS = 136; // NXT naming\n    static UPDATE_UID192 = 139; // NXT naming (not 100% certain if \"uid192\" means local player)\n    static LAST_LOGIN_INFO = 140; // NXT naming\n    static LOGOUT = 142; // NXT naming\n    static P_COUNTDIALOG = 243; // named after runescript command + client resume_p_countdialog packet\n    static SET_MULTIWAY = 254;\n    // maps\n    static DATA_LOC_DONE = 20;\n    static DATA_LAND_DONE = 80;\n    static DATA_LAND = 132;\n    static DATA_LOC = 220;\n    static REBUILD_NORMAL = 237; // NXT naming (do we really need _normal if there's no region rebuild?)\n    // vars\n    static VARP_SMALL = 150; // NXT naming\n    static VARP_LARGE = 175; // NXT naming\n    static RESET_CLIENT_VARCACHE = 193; // NXT naming\n    // audio\n    static SYNTH_SOUND = 12; // NXT naming\n    static MIDI_SONG = 54; // NXT naming\n    static MIDI_JINGLE = 212; // NXT naming\n    // zones\n    static UPDATE_ZONE_PARTIAL_FOLLOWS = 7; // NXT naming\n    static UPDATE_ZONE_FULL_FOLLOWS = 135; // NXT naming\n    static UPDATE_ZONE_PARTIAL_ENCLOSED = 162; // NXT naming\n    // zone protocol\n    static LOC_MERGE = 23; // based on runescript command p_locmerge\n    static LOC_ANIM = 42; // NXT naming\n    static OBJ_DEL = 49; // NXT naming\n    static OBJ_REVEAL = 50; // NXT naming\n    static LOC_ADD_CHANGE = 59; // NXT naming\n    static MAP_PROJANIM = 69; // NXT naming\n    static LOC_DEL = 76; // NXT naming\n    static OBJ_COUNT = 151; // NXT naming\n    static MAP_ANIM = 191; // NXT naming\n    static OBJ_ADD = 223; // NXT naming\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/io/ServerProt.ts?");

/***/ }),

/***/ "./src/js/jagex2/sound/SoundEnvelope.ts":
/*!**********************************************!*\
  !*** ./src/js/jagex2/sound/SoundEnvelope.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SoundEnvelope)\n/* harmony export */ });\nclass SoundEnvelope {\n    start = 0;\n    end = 0;\n    form = 0;\n    length = 0;\n    shapeDelta = null;\n    shapePeak = null;\n    threshold = 0;\n    position = 0;\n    delta = 0;\n    amplitude = 0;\n    ticks = 0;\n    read(dat) {\n        this.form = dat.g1;\n        this.start = dat.g4;\n        this.end = dat.g4;\n        this.length = dat.g1;\n        this.shapeDelta = new Int32Array(this.length);\n        this.shapePeak = new Int32Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            this.shapeDelta[i] = dat.g2;\n            this.shapePeak[i] = dat.g2;\n        }\n    }\n    reset() {\n        this.threshold = 0;\n        this.position = 0;\n        this.delta = 0;\n        this.amplitude = 0;\n        this.ticks = 0;\n    }\n    evaluate(delta) {\n        if (this.ticks >= this.threshold && this.shapePeak && this.shapeDelta) {\n            this.amplitude = this.shapePeak[this.position++] << 15;\n            if (this.position >= this.length) {\n                this.position = this.length - 1;\n            }\n            this.threshold = ((this.shapeDelta[this.position] / 65536.0) * delta) | 0;\n            if (this.threshold > this.ticks) {\n                this.delta = (((this.shapePeak[this.position] << 15) - this.amplitude) / (this.threshold - this.ticks)) | 0;\n            }\n        }\n        this.amplitude += this.delta;\n        this.ticks++;\n        return (this.amplitude - this.delta) >> 15;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/sound/SoundEnvelope.ts?");

/***/ }),

/***/ "./src/js/jagex2/sound/SoundTone.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/sound/SoundTone.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SoundTone)\n/* harmony export */ });\n/* harmony import */ var _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SoundEnvelope */ \"./src/js/jagex2/sound/SoundEnvelope.ts\");\n\nclass SoundTone {\n    static buffer = null;\n    static noise = null;\n    static sin = null;\n    static tmpPhases = new Int32Array(5);\n    static tmpDelays = new Int32Array(5);\n    static tmpVolumes = new Int32Array(5);\n    static tmpSemitones = new Int32Array(5);\n    static tmpStarts = new Int32Array(5);\n    frequencyBase = null;\n    amplitudeBase = null;\n    frequencyModRate = null;\n    frequencyModRange = null;\n    amplitudeModRate = null;\n    amplitudeModRange = null;\n    release = null;\n    attack = null;\n    harmonicVolume = new Int32Array(5);\n    harmonicSemitone = new Int32Array(5);\n    harmonicDelay = new Int32Array(5);\n    start = 0;\n    length = 500;\n    reverbVolume = 100;\n    reverbDelay = 0;\n    static init = () => {\n        this.noise = new Int32Array(32768);\n        for (let i = 0; i < 32768; i++) {\n            if (Math.random() > 0.5) {\n                this.noise[i] = 1;\n            }\n            else {\n                this.noise[i] = -1;\n            }\n        }\n        this.sin = new Int32Array(32768);\n        for (let i = 0; i < 32768; i++) {\n            this.sin[i] = (Math.sin(i / 5215.1903) * 16384.0) | 0;\n        }\n        this.buffer = new Int32Array(220500); // 10s * 22050 KHz\n    };\n    generate(sampleCount, length) {\n        for (let sample = 0; sample < sampleCount; sample++) {\n            SoundTone.buffer[sample] = 0;\n        }\n        if (length < 10) {\n            return SoundTone.buffer;\n        }\n        const samplesPerStep = (sampleCount / length) | 0;\n        this.frequencyBase?.reset();\n        this.amplitudeBase?.reset();\n        let frequencyStart = 0;\n        let frequencyDuration = 0;\n        let frequencyPhase = 0;\n        if (this.frequencyModRate && this.frequencyModRange) {\n            this.frequencyModRate.reset();\n            this.frequencyModRange.reset();\n            frequencyStart = (((this.frequencyModRate.end - this.frequencyModRate.start) * 32.768) / samplesPerStep) | 0;\n            frequencyDuration = ((this.frequencyModRate.start * 32.768) / samplesPerStep) | 0;\n        }\n        let amplitudeStart = 0;\n        let amplitudeDuration = 0;\n        let amplitudePhase = 0;\n        if (this.amplitudeModRate && this.amplitudeModRange) {\n            this.amplitudeModRate.reset();\n            this.amplitudeModRange.reset();\n            amplitudeStart = (((this.amplitudeModRate.end - this.amplitudeModRate.start) * 32.768) / samplesPerStep) | 0;\n            amplitudeDuration = ((this.amplitudeModRate.start * 32.768) / samplesPerStep) | 0;\n        }\n        for (let harmonic = 0; harmonic < 5; harmonic++) {\n            if (this.frequencyBase && this.harmonicVolume[harmonic] !== 0) {\n                SoundTone.tmpPhases[harmonic] = 0;\n                SoundTone.tmpDelays[harmonic] = this.harmonicDelay[harmonic] * samplesPerStep;\n                SoundTone.tmpVolumes[harmonic] = ((this.harmonicVolume[harmonic] << 14) / 100) | 0;\n                SoundTone.tmpSemitones[harmonic] = (((this.frequencyBase.end - this.frequencyBase.start) * 32.768 * Math.pow(1.0057929410678534, this.harmonicSemitone[harmonic])) / samplesPerStep) | 0;\n                SoundTone.tmpStarts[harmonic] = ((this.frequencyBase.start * 32.768) / samplesPerStep) | 0;\n            }\n        }\n        if (this.frequencyBase && this.amplitudeBase) {\n            for (let sample = 0; sample < sampleCount; sample++) {\n                let frequency = this.frequencyBase.evaluate(sampleCount);\n                let amplitude = this.amplitudeBase.evaluate(sampleCount);\n                if (this.frequencyModRate && this.frequencyModRange) {\n                    const rate = this.frequencyModRate.evaluate(sampleCount);\n                    const range = this.frequencyModRange.evaluate(sampleCount);\n                    frequency += this.generate2(range, frequencyPhase, this.frequencyModRate.form) >> 1;\n                    frequencyPhase += ((rate * frequencyStart) >> 16) + frequencyDuration;\n                }\n                if (this.amplitudeModRate && this.amplitudeModRange) {\n                    const rate = this.amplitudeModRate.evaluate(sampleCount);\n                    const range = this.amplitudeModRange.evaluate(sampleCount);\n                    amplitude = (amplitude * ((this.generate2(range, amplitudePhase, this.amplitudeModRate.form) >> 1) + 32768)) >> 15;\n                    amplitudePhase += ((rate * amplitudeStart) >> 16) + amplitudeDuration;\n                }\n                for (let harmonic = 0; harmonic < 5; harmonic++) {\n                    if (this.harmonicVolume[harmonic] !== 0) {\n                        const position = sample + SoundTone.tmpDelays[harmonic];\n                        if (position < sampleCount) {\n                            SoundTone.buffer[position] += this.generate2((amplitude * SoundTone.tmpVolumes[harmonic]) >> 15, SoundTone.tmpPhases[harmonic], this.frequencyBase.form);\n                            SoundTone.tmpPhases[harmonic] += ((frequency * SoundTone.tmpSemitones[harmonic]) >> 16) + SoundTone.tmpStarts[harmonic];\n                        }\n                    }\n                }\n            }\n        }\n        if (this.release && this.attack) {\n            this.release.reset();\n            this.attack.reset();\n            let counter = 0;\n            let muted = true;\n            for (let sample = 0; sample < sampleCount; sample++) {\n                const releaseValue = this.release.evaluate(sampleCount);\n                const attackValue = this.attack.evaluate(sampleCount);\n                let threshold;\n                if (muted) {\n                    threshold = this.release.start + (((this.release.end - this.release.start) * releaseValue) >> 8);\n                }\n                else {\n                    threshold = this.release.start + (((this.release.end - this.release.start) * attackValue) >> 8);\n                }\n                counter += 256;\n                if (counter >= threshold) {\n                    counter = 0;\n                    muted = !muted;\n                }\n                if (muted) {\n                    SoundTone.buffer[sample] = 0;\n                }\n            }\n        }\n        if (this.reverbDelay > 0 && this.reverbVolume > 0) {\n            const start = this.reverbDelay * samplesPerStep;\n            for (let sample = start; sample < sampleCount; sample++) {\n                SoundTone.buffer[sample] += ((SoundTone.buffer[sample - start] * this.reverbVolume) / 100) | 0;\n                SoundTone.buffer[sample] |= 0;\n            }\n        }\n        for (let sample = 0; sample < sampleCount; sample++) {\n            if (SoundTone.buffer[sample] < -32768) {\n                SoundTone.buffer[sample] = -32768;\n            }\n            if (SoundTone.buffer[sample] > 32767) {\n                SoundTone.buffer[sample] = 32767;\n            }\n        }\n        return SoundTone.buffer;\n    }\n    generate2(amplitude, phase, form) {\n        if (form === 1) {\n            return (phase & 0x7fff) < 16384 ? amplitude : -amplitude;\n        }\n        else if (form === 2) {\n            return (SoundTone.sin[phase & 0x7fff] * amplitude) >> 14;\n        }\n        else if (form === 3) {\n            return (((phase & 0x7fff) * amplitude) >> 14) - amplitude;\n        }\n        else if (form === 4) {\n            return SoundTone.noise[((phase / 2607) | 0) & 0x7fff] * amplitude;\n        }\n        else {\n            return 0;\n        }\n    }\n    read(dat) {\n        this.frequencyBase = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this.frequencyBase.read(dat);\n        this.amplitudeBase = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this.amplitudeBase.read(dat);\n        if (dat.g1 !== 0) {\n            dat.pos--;\n            this.frequencyModRate = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            this.frequencyModRate.read(dat);\n            this.frequencyModRange = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            this.frequencyModRange.read(dat);\n        }\n        if (dat.g1 !== 0) {\n            dat.pos--;\n            this.amplitudeModRate = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            this.amplitudeModRate.read(dat);\n            this.amplitudeModRange = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            this.amplitudeModRange.read(dat);\n        }\n        if (dat.g1 !== 0) {\n            dat.pos--;\n            this.release = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            this.release.read(dat);\n            this.attack = new _SoundEnvelope__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            this.attack.read(dat);\n        }\n        for (let harmonic = 0; harmonic < 10; harmonic++) {\n            const volume = dat.gsmarts;\n            if (volume === 0) {\n                break;\n            }\n            this.harmonicVolume[harmonic] = volume;\n            this.harmonicSemitone[harmonic] = dat.gsmart;\n            this.harmonicDelay[harmonic] = dat.gsmarts;\n        }\n        this.reverbDelay = dat.gsmarts;\n        this.reverbVolume = dat.gsmarts;\n        this.length = dat.g2;\n        this.start = dat.g2;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/sound/SoundTone.ts?");

/***/ }),

/***/ "./src/js/jagex2/sound/Wave.ts":
/*!*************************************!*\
  !*** ./src/js/jagex2/sound/Wave.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Wave)\n/* harmony export */ });\n/* harmony import */ var _SoundTone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SoundTone */ \"./src/js/jagex2/sound/SoundTone.ts\");\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n/* harmony import */ var _util_Arrays__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Arrays */ \"./src/js/jagex2/util/Arrays.ts\");\n\n\n\nclass Wave {\n    static delays = new Int32Array(1000);\n    static waveBytes = null;\n    static waveBuffer = null;\n    static tracks = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.TypedArray1d(1000, null);\n    tones = new _util_Arrays__WEBPACK_IMPORTED_MODULE_2__.TypedArray1d(10, null);\n    loopBegin = 0;\n    loopEnd = 0;\n    static unpack = (sounds) => {\n        const dat = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](sounds.read('sounds.dat'));\n        this.waveBytes = new Uint8Array(441000);\n        this.waveBuffer = new _io_Packet__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.waveBytes);\n        _SoundTone__WEBPACK_IMPORTED_MODULE_0__[\"default\"].init();\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const id = dat.g2;\n            if (id === 65535) {\n                break;\n            }\n            const wave = new Wave();\n            wave.read(dat);\n            this.tracks[id] = wave;\n            this.delays[id] = wave.trim();\n        }\n    };\n    static generate = (id, loopCount) => {\n        if (!this.tracks[id]) {\n            return null;\n        }\n        const track = this.tracks[id];\n        return track?.getWave(loopCount) ?? null;\n    };\n    read(dat) {\n        for (let tone = 0; tone < 10; tone++) {\n            if (dat.g1 !== 0) {\n                dat.pos--;\n                this.tones[tone] = new _SoundTone__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n                this.tones[tone]?.read(dat);\n            }\n        }\n        this.loopBegin = dat.g2;\n        this.loopEnd = dat.g2;\n    }\n    trim() {\n        let start = 9999999;\n        for (let tone = 0; tone < 10; tone++) {\n            if (this.tones[tone] && ((this.tones[tone].start / 20) | 0) < start) {\n                start = (this.tones[tone].start / 20) | 0;\n            }\n        }\n        if (this.loopBegin < this.loopEnd && ((this.loopBegin / 20) | 0) < start) {\n            start = (this.loopBegin / 20) | 0;\n        }\n        if (start === 9999999 || start === 0) {\n            return 0;\n        }\n        for (let tone = 0; tone < 10; tone++) {\n            if (this.tones[tone]) {\n                this.tones[tone].start -= start * 20;\n            }\n        }\n        if (this.loopBegin < this.loopEnd) {\n            this.loopBegin -= start * 20;\n            this.loopEnd -= start * 20;\n        }\n        return start;\n    }\n    getWave(loopCount) {\n        const length = this.generate(loopCount);\n        Wave.waveBuffer.pos = 0;\n        Wave.waveBuffer?.p4(0x52494646); // \"RIFF\" ChunkID\n        Wave.waveBuffer?.ip4(length + 36); // ChunkSize\n        Wave.waveBuffer?.p4(0x57415645); // \"WAVE\" format\n        Wave.waveBuffer?.p4(0x666d7420); // \"fmt \" chunk id\n        Wave.waveBuffer?.ip4(16); // chunk size\n        Wave.waveBuffer?.ip2(1); // audio format\n        Wave.waveBuffer?.ip2(1); // num channels\n        Wave.waveBuffer?.ip4(22050); // sample rate\n        Wave.waveBuffer?.ip4(22050); // byte rate\n        Wave.waveBuffer?.ip2(1); // block align\n        Wave.waveBuffer?.ip2(8); // bits per sample\n        Wave.waveBuffer?.p4(0x64617461); // \"data\"\n        Wave.waveBuffer?.ip4(length);\n        Wave.waveBuffer.pos += length;\n        return Wave.waveBuffer;\n    }\n    generate(loopCount) {\n        let duration = 0;\n        for (let tone = 0; tone < 10; tone++) {\n            if (this.tones[tone] && this.tones[tone].length + this.tones[tone].start > duration) {\n                duration = this.tones[tone].length + this.tones[tone].start;\n            }\n        }\n        if (duration === 0) {\n            return 0;\n        }\n        let sampleCount = ((duration * 22050) / 1000) | 0;\n        let loopStart = ((this.loopBegin * 22050) / 1000) | 0;\n        let loopStop = ((this.loopEnd * 22050) / 1000) | 0;\n        if (loopStart < 0 || loopStop < 0 || loopStop > sampleCount || loopStart >= loopStop) {\n            loopCount = 0;\n        }\n        let totalSampleCount = sampleCount + (loopStop - loopStart) * (loopCount - 1);\n        for (let sample = 44; sample < totalSampleCount + 44; sample++) {\n            if (Wave.waveBytes) {\n                Wave.waveBytes[sample] = -128;\n            }\n        }\n        for (let tone = 0; tone < 10; tone++) {\n            if (this.tones[tone]) {\n                const toneSampleCount = ((this.tones[tone].length * 22050) / 1000) | 0;\n                const start = ((this.tones[tone].start * 22050) / 1000) | 0;\n                const samples = this.tones[tone].generate(toneSampleCount, this.tones[tone].length);\n                for (let sample = 0; sample < toneSampleCount; sample++) {\n                    if (Wave.waveBytes) {\n                        Wave.waveBytes[sample + start + 44] += ((samples[sample] >> 8) << 24) >> 24;\n                    }\n                }\n            }\n        }\n        if (loopCount > 1) {\n            loopStart += 44;\n            loopStop += 44;\n            sampleCount += 44;\n            totalSampleCount += 44;\n            const endOffset = totalSampleCount - sampleCount;\n            for (let sample = sampleCount - 1; sample >= loopStop; sample--) {\n                if (Wave.waveBytes) {\n                    Wave.waveBytes[sample + endOffset] = Wave.waveBytes[sample];\n                }\n            }\n            for (let loop = 1; loop < loopCount; loop++) {\n                const offset = (loopStop - loopStart) * loop;\n                for (let sample = loopStart; sample < loopStop; sample++) {\n                    if (Wave.waveBytes) {\n                        Wave.waveBytes[sample + offset] = Wave.waveBytes[sample];\n                    }\n                }\n            }\n            totalSampleCount -= 44;\n        }\n        return totalSampleCount;\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/sound/Wave.ts?");

/***/ }),

/***/ "./src/js/jagex2/util/Arrays.ts":
/*!**************************************!*\
  !*** ./src/js/jagex2/util/Arrays.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Int32Array2d: () => (/* binding */ Int32Array2d),\n/* harmony export */   Int32Array3d: () => (/* binding */ Int32Array3d),\n/* harmony export */   TypedArray1d: () => (/* binding */ TypedArray1d),\n/* harmony export */   TypedArray2d: () => (/* binding */ TypedArray2d),\n/* harmony export */   TypedArray3d: () => (/* binding */ TypedArray3d),\n/* harmony export */   TypedArray4d: () => (/* binding */ TypedArray4d),\n/* harmony export */   Uint8Array3d: () => (/* binding */ Uint8Array3d)\n/* harmony export */ });\nclass TypedArray1d extends Array {\n    constructor(length, defaultValue) {\n        super(length);\n        for (let l = 0; l < length; l++) {\n            this[l] = defaultValue;\n        }\n    }\n}\nclass TypedArray2d extends Array {\n    constructor(length, width, defaultValue) {\n        super(length);\n        for (let l = 0; l < length; l++) {\n            this[l] = new Array(width);\n            for (let w = 0; w < width; w++) {\n                this[l][w] = defaultValue;\n            }\n        }\n    }\n}\nclass TypedArray3d extends Array {\n    constructor(length, width, height, defaultValue) {\n        super(length);\n        for (let l = 0; l < length; l++) {\n            this[l] = new Array(width);\n            for (let w = 0; w < width; w++) {\n                this[l][w] = new Array(height);\n                for (let h = 0; h < height; h++) {\n                    this[l][w][h] = defaultValue;\n                }\n            }\n        }\n    }\n}\nclass TypedArray4d extends Array {\n    constructor(length, width, height, space, defaultValue) {\n        super(length);\n        for (let l = 0; l < length; l++) {\n            this[l] = new Array(width);\n            for (let w = 0; w < width; w++) {\n                this[l][w] = new Array(height);\n                for (let h = 0; h < height; h++) {\n                    this[l][w][h] = new Array(space);\n                    for (let s = 0; s < space; s++) {\n                        this[l][w][h][s] = defaultValue;\n                    }\n                }\n            }\n        }\n    }\n}\nclass Uint8Array3d extends Array {\n    constructor(length, width, height) {\n        super(length);\n        for (let l = 0; l < length; l++) {\n            this[l] = new Array(width);\n            for (let w = 0; w < width; w++) {\n                this[l][w] = new Uint8Array(height);\n            }\n        }\n    }\n}\nclass Int32Array2d extends Array {\n    constructor(length, width) {\n        super(length);\n        for (let l = 0; l < length; l++) {\n            this[l] = new Int32Array(width);\n        }\n    }\n}\nclass Int32Array3d extends Array {\n    constructor(length, width, height) {\n        super(length);\n        for (let l = 0; l < length; l++) {\n            this[l] = new Array(width);\n            for (let w = 0; w < width; w++) {\n                this[l][w] = new Int32Array(height);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/util/Arrays.ts?");

/***/ }),

/***/ "./src/js/jagex2/util/JavaRandom.ts":
/*!******************************************!*\
  !*** ./src/js/jagex2/util/JavaRandom.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JavaRandom)\n/* harmony export */ });\nclass JavaRandom {\n    seed;\n    constructor(seed) {\n        this.seed = (seed ^ 0x5deece66dn) & ((1n << 48n) - 1n);\n    }\n    setSeed(seed) {\n        this.seed = (seed ^ 0x5deece66dn) & ((1n << 48n) - 1n);\n    }\n    nextInt() {\n        return this.next(32);\n    }\n    next(bits) {\n        this.seed = (this.seed * 0x5deece66dn + 0xbn) & ((1n << 48n) - 1n);\n        return Number(this.seed) >>> (48 - bits);\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/util/JavaRandom.ts?");

/***/ }),

/***/ "./src/js/jagex2/util/JsUtil.ts":
/*!**************************************!*\
  !*** ./src/js/jagex2/util/JsUtil.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arraycopy: () => (/* binding */ arraycopy),\n/* harmony export */   bigIntModPow: () => (/* binding */ bigIntModPow),\n/* harmony export */   bigIntToBytes: () => (/* binding */ bigIntToBytes),\n/* harmony export */   bytesToBigInt: () => (/* binding */ bytesToBigInt),\n/* harmony export */   downloadText: () => (/* binding */ downloadText),\n/* harmony export */   downloadUrl: () => (/* binding */ downloadUrl),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\nconst sleep = async (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst downloadUrl = async (url) => new Int8Array(await (await fetch(url)).arrayBuffer());\nconst downloadText = async (url) => (await fetch(url)).text();\nfunction arraycopy(src, srcPos, dst, dstPos, length) {\n    while (length--)\n        dst[dstPos++] = src[srcPos++];\n}\nfunction bytesToBigInt(bytes) {\n    let result = 0n;\n    for (let index = 0; index < bytes.length; index++) {\n        result = (result << 8n) | BigInt(bytes[index]);\n    }\n    return result;\n}\nfunction bigIntToBytes(bigInt) {\n    const bytes = [];\n    while (bigInt > 0n) {\n        bytes.unshift(Number(bigInt & 0xffn));\n        bigInt >>= 8n;\n    }\n    if (bytes[0] & 0x80) {\n        bytes.unshift(0);\n    }\n    return new Uint8Array(bytes);\n}\nfunction bigIntModPow(base, exponent, modulus) {\n    let result = 1n;\n    while (exponent > 0n) {\n        if (exponent % 2n === 1n) {\n            result = (result * base) % modulus;\n        }\n        base = (base * base) % modulus;\n        exponent >>= 1n;\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/util/JsUtil.ts?");

/***/ }),

/***/ "./src/js/jagex2/wordenc/WordFilter.ts":
/*!*********************************************!*\
  !*** ./src/js/jagex2/wordenc/WordFilter.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WordFilter)\n/* harmony export */ });\n/* harmony import */ var _io_Packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/Packet */ \"./src/js/jagex2/io/Packet.ts\");\n\nclass WordFilter {\n    static PERIOD = new Uint16Array(['d', 'o', 't']\n        .join('')\n        .split('')\n        .map((char) => char.charCodeAt(0)));\n    static AMPERSAT = new Uint16Array(['(', 'a', ')']\n        .join('')\n        .split('')\n        .map((char) => char.charCodeAt(0)));\n    static SLASH = new Uint16Array(['s', 'l', 'a', 's', 'h']\n        .join('')\n        .split('')\n        .map((char) => char.charCodeAt(0)));\n    static whitelist = ['cook', \"cook's\", 'cooks', 'seeks', 'sheet'];\n    static tlds = [];\n    static tldTypes = [];\n    static bads = [];\n    static badCombinations = [];\n    static domains = [];\n    static fragments = [];\n    static unpack = (wordenc) => {\n        const fragments = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](wordenc.read('fragmentsenc.txt'));\n        const bad = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](wordenc.read('badenc.txt'));\n        const domain = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](wordenc.read('domainenc.txt'));\n        const tld = new _io_Packet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](wordenc.read('tldlist.txt'));\n        this.read(bad, domain, fragments, tld);\n    };\n    static filter = (input) => {\n        const characters = [...input];\n        this.format(characters);\n        const trimmed = characters.join('').trim();\n        const lowercase = trimmed.toLowerCase();\n        const filtered = [...lowercase];\n        this.filterTlds(filtered);\n        this.filterBadWords(filtered);\n        this.filterDomains(filtered);\n        this.filterFragments(filtered);\n        for (let index = 0; index < this.whitelist.length; index++) {\n            let offset = -1;\n            while ((offset = lowercase.indexOf(this.whitelist[index], offset + 1)) !== -1) {\n                const whitelisted = [...this.whitelist[index]];\n                for (let charIndex = 0; charIndex < whitelisted.length; charIndex++) {\n                    filtered[charIndex + offset] = whitelisted[charIndex];\n                }\n            }\n        }\n        this.replaceUppercases(filtered, [...trimmed]);\n        this.formatUppercases(filtered);\n        return filtered.join('').trim();\n    };\n    static read = (bad, domain, fragments, tld) => {\n        this.readBadWords(bad);\n        this.readDomains(domain);\n        this.readFragments(fragments);\n        this.readTld(tld);\n    };\n    static readTld = (packet) => {\n        const count = packet.g4;\n        for (let index = 0; index < count; index++) {\n            this.tldTypes[index] = packet.g1;\n            this.tlds[index] = new Uint16Array(packet.g1).map(() => packet.g1);\n        }\n    };\n    static readBadWords = (packet) => {\n        const count = packet.g4;\n        for (let index = 0; index < count; index++) {\n            this.bads[index] = new Uint16Array(packet.g1).map(() => packet.g1);\n            const combos = new Array(packet.g1).fill([]).map(() => [packet.g1b, packet.g1b]);\n            if (combos.length > 0) {\n                this.badCombinations[index] = combos;\n            }\n        }\n    };\n    static readDomains = (packet) => {\n        const count = packet.g4;\n        for (let index = 0; index < count; index++) {\n            this.domains[index] = new Uint16Array(packet.g1).map(() => packet.g1);\n        }\n    };\n    static readFragments = (packet) => {\n        const count = packet.g4;\n        for (let index = 0; index < count; index++) {\n            this.fragments[index] = packet.g2;\n        }\n    };\n    static filterTlds = (chars) => {\n        const period = [...chars];\n        const slash = [...chars];\n        this.filterBadCombinations(null, period, this.PERIOD);\n        this.filterBadCombinations(null, slash, this.SLASH);\n        for (let index = 0; index < this.tlds.length; index++) {\n            this.filterTld(slash, this.tldTypes[index], chars, this.tlds[index], period);\n        }\n    };\n    static filterBadWords = (chars) => {\n        for (let comboIndex = 0; comboIndex < 2; comboIndex++) {\n            for (let index = this.bads.length - 1; index >= 0; index--) {\n                this.filterBadCombinations(this.badCombinations[index], chars, this.bads[index]);\n            }\n        }\n    };\n    static filterDomains = (chars) => {\n        const ampersat = [...chars];\n        const period = [...chars];\n        this.filterBadCombinations(null, ampersat, this.AMPERSAT);\n        this.filterBadCombinations(null, period, this.PERIOD);\n        for (let index = this.domains.length - 1; index >= 0; index--) {\n            this.filterDomain(period, ampersat, this.domains[index], chars);\n        }\n    };\n    static filterFragments = (chars) => {\n        for (let currentIndex = 0; currentIndex < chars.length;) {\n            const numberIndex = this.indexOfNumber(chars, currentIndex);\n            if (numberIndex === -1) {\n                return;\n            }\n            let isSymbolOrNotLowercaseAlpha = false;\n            for (let index = currentIndex; index >= 0 && index < numberIndex && !isSymbolOrNotLowercaseAlpha; index++) {\n                if (!this.isSymbol(chars[index]) && !this.isNotLowercaseAlpha(chars[index])) {\n                    isSymbolOrNotLowercaseAlpha = true;\n                }\n            }\n            let startIndex = 0;\n            if (isSymbolOrNotLowercaseAlpha) {\n                startIndex = 0;\n            }\n            if (startIndex === 0) {\n                startIndex = 1;\n                currentIndex = numberIndex;\n            }\n            let value = 0;\n            for (let index = numberIndex; index < chars.length && index < currentIndex; index++) {\n                value = value * 10 + chars[index].charCodeAt(0) - 48;\n            }\n            if (value <= 255 && currentIndex - numberIndex <= 8) {\n                startIndex++;\n            }\n            else {\n                startIndex = 0;\n            }\n            if (startIndex === 4) {\n                this.maskChars(numberIndex, currentIndex, chars);\n                startIndex = 0;\n            }\n            currentIndex = this.indexOfNonNumber(currentIndex, chars);\n        }\n    };\n    static isBadFragment = (chars) => {\n        if (this.isNumericalChars(chars)) {\n            return true;\n        }\n        const value = this.getInteger(chars);\n        const fragments = this.fragments;\n        const fragmentsLength = fragments.length;\n        if (value === fragments[0] || value === fragments[fragmentsLength - 1]) {\n            return true;\n        }\n        let start = 0;\n        let end = fragmentsLength - 1;\n        while (start <= end) {\n            const mid = ((start + end) / 2) | 0;\n            if (value === fragments[mid]) {\n                return true;\n            }\n            else if (value < fragments[mid]) {\n                end = mid - 1;\n            }\n            else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    };\n    static getInteger = (chars) => {\n        if (chars.length > 6) {\n            return 0;\n        }\n        let value = 0;\n        for (let index = 0; index < chars.length; index++) {\n            const char = chars[chars.length - index - 1];\n            if (this.isLowercaseAlpha(char)) {\n                value = value * 38 + char.charCodeAt(0) + 1 - 'a'.charCodeAt(0);\n            }\n            else if (char === \"'\") {\n                value = value * 38 + 27;\n            }\n            else if (this.isNumerical(char)) {\n                value = value * 38 + char.charCodeAt(0) + 28 - '0'.charCodeAt(0);\n            }\n            else if (char !== '\\u0000') {\n                return 0;\n            }\n        }\n        return value;\n    };\n    static indexOfNumber = (chars, offset) => {\n        for (let index = offset; index < chars.length && index >= 0; index++) {\n            if (this.isNumerical(chars[index])) {\n                return index;\n            }\n        }\n        return -1;\n    };\n    static indexOfNonNumber = (offset, chars) => {\n        for (let index = offset; index < chars.length && index >= 0; index++) {\n            if (!this.isNumerical(chars[index])) {\n                return index;\n            }\n        }\n        return chars.length;\n    };\n    static getEmulatedDomainCharLen = (nextChar, domainChar, currentChar) => {\n        if (domainChar === currentChar) {\n            return 1;\n        }\n        else if (domainChar === 'o' && currentChar === '0') {\n            return 1;\n        }\n        else if (domainChar === 'o' && currentChar === '(' && nextChar === ')') {\n            return 2;\n        }\n        else if (domainChar === 'c' && (currentChar === '(' || currentChar === '<' || currentChar === '[')) {\n            return 1;\n        }\n        else if (domainChar === 'e' && currentChar === '€') {\n            return 1;\n        }\n        else if (domainChar === 's' && currentChar === '$') {\n            return 1;\n        }\n        else if (domainChar === 'l' && currentChar === 'i') {\n            return 1;\n        }\n        return 0;\n    };\n    static filterDomain = (period, ampersat, domain, chars) => {\n        const domainLength = domain.length;\n        const charsLength = chars.length;\n        for (let index = 0; index <= charsLength - domainLength; index++) {\n            const { matched, currentIndex } = this.findMatchingDomain(index, domain, chars);\n            if (!matched) {\n                continue;\n            }\n            const ampersatStatus = this.prefixSymbolStatus(index, chars, 3, ampersat, ['@']);\n            const periodStatus = this.suffixSymbolStatus(currentIndex - 1, chars, 3, period, ['.', ',']);\n            const shouldFilter = ampersatStatus > 2 || periodStatus > 2;\n            if (!shouldFilter) {\n                continue;\n            }\n            this.maskChars(index, currentIndex, chars);\n        }\n    };\n    static findMatchingDomain = (startIndex, domain, chars) => {\n        const domainLength = domain.length;\n        let currentIndex = startIndex;\n        let domainIndex = 0;\n        while (currentIndex < chars.length && domainIndex < domainLength) {\n            const currentChar = chars[currentIndex];\n            const nextChar = currentIndex + 1 < chars.length ? chars[currentIndex + 1] : '\\u0000';\n            const currentLength = this.getEmulatedDomainCharLen(nextChar, String.fromCharCode(domain[domainIndex]), currentChar);\n            if (currentLength > 0) {\n                currentIndex += currentLength;\n                domainIndex++;\n            }\n            else {\n                if (domainIndex === 0)\n                    break;\n                const previousLength = this.getEmulatedDomainCharLen(nextChar, String.fromCharCode(domain[domainIndex - 1]), currentChar);\n                if (previousLength > 0) {\n                    currentIndex += previousLength;\n                    if (domainIndex === 1)\n                        startIndex++;\n                }\n                else {\n                    if (domainIndex >= domainLength || !this.isSymbol(currentChar))\n                        break;\n                    currentIndex++;\n                }\n            }\n        }\n        return { matched: domainIndex >= domainLength, currentIndex };\n    };\n    static filterBadCombinations = (combos, chars, bads) => {\n        if (bads.length > chars.length) {\n            return;\n        }\n        for (let startIndex = 0; startIndex <= chars.length - bads.length; startIndex++) {\n            let currentIndex = startIndex;\n            const { currentIndex: updatedCurrentIndex, badIndex, hasSymbol, hasNumber, hasDigit } = this.processBadCharacters(chars, bads, currentIndex);\n            currentIndex = updatedCurrentIndex;\n            let currentChar = chars[currentIndex];\n            let nextChar = currentIndex + 1 < chars.length ? chars[currentIndex + 1] : '\\u0000';\n            if (!(badIndex >= bads.length && (!hasNumber || !hasDigit))) {\n                continue;\n            }\n            let shouldFilter = true;\n            let localIndex;\n            if (hasSymbol) {\n                let isBeforeSymbol = false;\n                let isAfterSymbol = false;\n                if (startIndex - 1 < 0 || (this.isSymbol(chars[startIndex - 1]) && chars[startIndex - 1] !== \"'\")) {\n                    isBeforeSymbol = true;\n                }\n                if (currentIndex >= chars.length || (this.isSymbol(chars[currentIndex]) && chars[currentIndex] !== \"'\")) {\n                    isAfterSymbol = true;\n                }\n                if (!isBeforeSymbol || !isAfterSymbol) {\n                    let isSubstringValid = false;\n                    localIndex = startIndex - 2;\n                    if (isBeforeSymbol) {\n                        localIndex = startIndex;\n                    }\n                    while (!isSubstringValid && localIndex < currentIndex) {\n                        if (localIndex >= 0 && (!this.isSymbol(chars[localIndex]) || chars[localIndex] === \"'\")) {\n                            const localSubString = [];\n                            let localSubStringIndex;\n                            for (localSubStringIndex = 0; localSubStringIndex < 3 && localIndex + localSubStringIndex < chars.length && (!this.isSymbol(chars[localIndex + localSubStringIndex]) || chars[localIndex + localSubStringIndex] === \"'\"); localSubStringIndex++) {\n                                localSubString[localSubStringIndex] = chars[localIndex + localSubStringIndex];\n                            }\n                            let isSubStringValidCondition = true;\n                            if (localSubStringIndex === 0) {\n                                isSubStringValidCondition = false;\n                            }\n                            if (localSubStringIndex < 3 && localIndex - 1 >= 0 && (!this.isSymbol(chars[localIndex - 1]) || chars[localIndex - 1] === \"'\")) {\n                                isSubStringValidCondition = false;\n                            }\n                            if (isSubStringValidCondition && !this.isBadFragment(localSubString)) {\n                                isSubstringValid = true;\n                            }\n                        }\n                        localIndex++;\n                    }\n                    if (!isSubstringValid) {\n                        shouldFilter = false;\n                    }\n                }\n            }\n            else {\n                currentChar = ' ';\n                if (startIndex - 1 >= 0) {\n                    currentChar = chars[startIndex - 1];\n                }\n                nextChar = ' ';\n                if (currentIndex < chars.length) {\n                    nextChar = chars[currentIndex];\n                }\n                const current = this.getIndex(currentChar);\n                const next = this.getIndex(nextChar);\n                if (combos && this.comboMatches(current, combos, next)) {\n                    shouldFilter = false;\n                }\n            }\n            if (!shouldFilter) {\n                continue;\n            }\n            let numeralCount = 0;\n            let alphaCount = 0;\n            for (let index = startIndex; index < currentIndex; index++) {\n                if (this.isNumerical(chars[index])) {\n                    numeralCount++;\n                }\n                else if (this.isAlpha(chars[index])) {\n                    alphaCount++;\n                }\n            }\n            if (numeralCount <= alphaCount) {\n                this.maskChars(startIndex, currentIndex, chars);\n            }\n        }\n    };\n    static processBadCharacters = (chars, bads, startIndex) => {\n        let index = startIndex;\n        let badIndex = 0;\n        let count = 0;\n        let hasSymbol = false;\n        let hasNumber = false;\n        let hasDigit = false;\n        for (; index < chars.length && !(hasNumber && hasDigit);) {\n            if (index >= chars.length || (hasNumber && hasDigit)) {\n                break;\n            }\n            const currentChar = chars[index];\n            const nextChar = index + 1 < chars.length ? chars[index + 1] : '\\u0000';\n            let currentLength;\n            if (badIndex < bads.length && (currentLength = this.getEmulatedBadCharLen(nextChar, String.fromCharCode(bads[badIndex]), currentChar)) > 0) {\n                if (currentLength === 1 && this.isNumerical(currentChar)) {\n                    hasNumber = true;\n                }\n                if (currentLength === 2 && (this.isNumerical(currentChar) || this.isNumerical(nextChar))) {\n                    hasNumber = true;\n                }\n                index += currentLength;\n                badIndex++;\n            }\n            else {\n                if (badIndex === 0) {\n                    break;\n                }\n                let previousLength;\n                if ((previousLength = this.getEmulatedBadCharLen(nextChar, String.fromCharCode(bads[badIndex - 1]), currentChar)) > 0) {\n                    index += previousLength;\n                }\n                else {\n                    if (badIndex >= bads.length || !this.isNotLowercaseAlpha(currentChar)) {\n                        break;\n                    }\n                    if (this.isSymbol(currentChar) && currentChar !== \"'\") {\n                        hasSymbol = true;\n                    }\n                    if (this.isNumerical(currentChar)) {\n                        hasDigit = true;\n                    }\n                    index++;\n                    count++;\n                    if ((((count * 100) / (index - startIndex)) | 0) > 90) {\n                        break;\n                    }\n                }\n            }\n        }\n        return { currentIndex: index, badIndex, hasSymbol, hasNumber, hasDigit };\n    };\n    static getEmulatedBadCharLen = (nextChar, badChar, currentChar) => {\n        if (badChar === currentChar) {\n            return 1;\n        }\n        if (badChar >= 'a' && badChar <= 'm') {\n            if (badChar === 'a') {\n                if (currentChar !== '4' && currentChar !== '@' && currentChar !== '^') {\n                    if (currentChar === '/' && nextChar === '\\\\') {\n                        return 2;\n                    }\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'b') {\n                if (currentChar !== '6' && currentChar !== '8') {\n                    if (currentChar === '1' && nextChar === '3') {\n                        return 2;\n                    }\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'c') {\n                if (currentChar !== '(' && currentChar !== '<' && currentChar !== '{' && currentChar !== '[') {\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'd') {\n                if (currentChar === '[' && nextChar === ')') {\n                    return 2;\n                }\n                return 0;\n            }\n            if (badChar === 'e') {\n                if (currentChar !== '3' && currentChar !== '€') {\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'f') {\n                if (currentChar === 'p' && nextChar === 'h') {\n                    return 2;\n                }\n                if (currentChar === '£') {\n                    return 1;\n                }\n                return 0;\n            }\n            if (badChar === 'g') {\n                if (currentChar !== '9' && currentChar !== '6') {\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'h') {\n                if (currentChar === '#') {\n                    return 1;\n                }\n                return 0;\n            }\n            if (badChar === 'i') {\n                if (currentChar !== 'y' && currentChar !== 'l' && currentChar !== 'j' && currentChar !== '1' && currentChar !== '!' && currentChar !== ':' && currentChar !== ';' && currentChar !== '|') {\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'j') {\n                return 0;\n            }\n            if (badChar === 'k') {\n                return 0;\n            }\n            if (badChar === 'l') {\n                if (currentChar !== '1' && currentChar !== '|' && currentChar !== 'i') {\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'm') {\n                return 0;\n            }\n        }\n        if (badChar >= 'n' && badChar <= 'z') {\n            if (badChar === 'n') {\n                return 0;\n            }\n            if (badChar === 'o') {\n                if (currentChar !== '0' && currentChar !== '*') {\n                    if ((currentChar !== '(' || nextChar !== ')') && (currentChar !== '[' || nextChar !== ']') && (currentChar !== '{' || nextChar !== '}') && (currentChar !== '<' || nextChar !== '>')) {\n                        return 0;\n                    }\n                    return 2;\n                }\n                return 1;\n            }\n            if (badChar === 'p') {\n                return 0;\n            }\n            if (badChar === 'q') {\n                return 0;\n            }\n            if (badChar === 'r') {\n                return 0;\n            }\n            if (badChar === 's') {\n                if (currentChar !== '5' && currentChar !== 'z' && currentChar !== '$' && currentChar !== '2') {\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 't') {\n                if (currentChar !== '7' && currentChar !== '+') {\n                    return 0;\n                }\n                return 1;\n            }\n            if (badChar === 'u') {\n                if (currentChar === 'v') {\n                    return 1;\n                }\n                if ((currentChar !== '\\\\' || nextChar !== '/') && (currentChar !== '\\\\' || nextChar !== '|') && (currentChar !== '|' || nextChar !== '/')) {\n                    return 0;\n                }\n                return 2;\n            }\n            if (badChar === 'v') {\n                if ((currentChar !== '\\\\' || nextChar !== '/') && (currentChar !== '\\\\' || nextChar !== '|') && (currentChar !== '|' || nextChar !== '/')) {\n                    return 0;\n                }\n                return 2;\n            }\n            if (badChar === 'w') {\n                if (currentChar === 'v' && nextChar === 'v') {\n                    return 2;\n                }\n                return 0;\n            }\n            if (badChar === 'x') {\n                if ((currentChar !== ')' || nextChar !== '(') && (currentChar !== '}' || nextChar !== '{') && (currentChar !== ']' || nextChar !== '[') && (currentChar !== '>' || nextChar !== '<')) {\n                    return 0;\n                }\n                return 2;\n            }\n            if (badChar === 'y') {\n                return 0;\n            }\n            if (badChar === 'z') {\n                return 0;\n            }\n        }\n        if (badChar >= '0' && badChar <= '9') {\n            if (badChar === '0') {\n                if (currentChar === 'o' || currentChar === 'O') {\n                    return 1;\n                }\n                else if ((currentChar !== '(' || nextChar !== ')') && (currentChar !== '{' || nextChar !== '}') && (currentChar !== '[' || nextChar !== ']')) {\n                    return 0;\n                }\n                else {\n                    return 2;\n                }\n            }\n            else if (badChar === '1') {\n                return currentChar === 'l' ? 1 : 0;\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (badChar === ',') {\n            return currentChar === '.' ? 1 : 0;\n        }\n        else if (badChar === '.') {\n            return currentChar === ',' ? 1 : 0;\n        }\n        else if (badChar === '!') {\n            return currentChar === 'i' ? 1 : 0;\n        }\n        return 0;\n    };\n    static comboMatches = (currentIndex, combos, nextIndex) => {\n        let start = 0;\n        let end = combos.length - 1;\n        while (start <= end) {\n            const mid = ((start + end) / 2) | 0;\n            if (combos[mid][0] === currentIndex && combos[mid][1] === nextIndex) {\n                return true;\n            }\n            else if (currentIndex < combos[mid][0] || (currentIndex === combos[mid][0] && nextIndex < combos[mid][1])) {\n                end = mid - 1;\n            }\n            else {\n                start = mid + 1;\n            }\n        }\n        return false;\n    };\n    static getIndex = (char) => {\n        if (this.isLowercaseAlpha(char)) {\n            return char.charCodeAt(0) + 1 - 'a'.charCodeAt(0);\n        }\n        else if (char === \"'\") {\n            return 28;\n        }\n        else if (this.isNumerical(char)) {\n            return char.charCodeAt(0) + 29 - '0'.charCodeAt(0);\n        }\n        return 27;\n    };\n    static filterTld = (slash, tldType, chars, tld, period) => {\n        if (tld.length > chars.length) {\n            return;\n        }\n        for (let index = 0; index <= chars.length - tld.length; index++) {\n            const { currentIndex, tldIndex } = this.processTlds(chars, tld, index);\n            if (tldIndex < tld.length) {\n                continue;\n            }\n            let shouldFilter = false;\n            const periodFilterStatus = this.prefixSymbolStatus(index, chars, 3, period, [',', '.']);\n            const slashFilterStatus = this.suffixSymbolStatus(currentIndex - 1, chars, 5, slash, ['\\\\', '/']);\n            if (tldType === 1 && periodFilterStatus > 0 && slashFilterStatus > 0) {\n                shouldFilter = true;\n            }\n            if (tldType === 2 && ((periodFilterStatus > 2 && slashFilterStatus > 0) || (periodFilterStatus > 0 && slashFilterStatus > 2))) {\n                shouldFilter = true;\n            }\n            if (tldType === 3 && periodFilterStatus > 0 && slashFilterStatus > 2) {\n                shouldFilter = true;\n            }\n            if (!shouldFilter) {\n                continue;\n            }\n            let startFilterIndex = index;\n            let endFilterIndex = currentIndex - 1;\n            let foundPeriod = false;\n            let periodIndex;\n            if (periodFilterStatus > 2) {\n                if (periodFilterStatus === 4) {\n                    foundPeriod = false;\n                    for (periodIndex = index - 1; periodIndex >= 0; periodIndex--) {\n                        if (foundPeriod) {\n                            if (period[periodIndex] !== '*') {\n                                break;\n                            }\n                            startFilterIndex = periodIndex;\n                        }\n                        else if (period[periodIndex] === '*') {\n                            startFilterIndex = periodIndex;\n                            foundPeriod = true;\n                        }\n                    }\n                }\n                foundPeriod = false;\n                for (periodIndex = startFilterIndex - 1; periodIndex >= 0; periodIndex--) {\n                    if (foundPeriod) {\n                        if (this.isSymbol(chars[periodIndex])) {\n                            break;\n                        }\n                        startFilterIndex = periodIndex;\n                    }\n                    else if (!this.isSymbol(chars[periodIndex])) {\n                        foundPeriod = true;\n                        startFilterIndex = periodIndex;\n                    }\n                }\n            }\n            if (slashFilterStatus > 2) {\n                if (slashFilterStatus === 4) {\n                    foundPeriod = false;\n                    for (periodIndex = endFilterIndex + 1; periodIndex < chars.length; periodIndex++) {\n                        if (foundPeriod) {\n                            if (slash[periodIndex] !== '*') {\n                                break;\n                            }\n                            endFilterIndex = periodIndex;\n                        }\n                        else if (slash[periodIndex] === '*') {\n                            endFilterIndex = periodIndex;\n                            foundPeriod = true;\n                        }\n                    }\n                }\n                foundPeriod = false;\n                for (periodIndex = endFilterIndex + 1; periodIndex < chars.length; periodIndex++) {\n                    if (foundPeriod) {\n                        if (this.isSymbol(chars[periodIndex])) {\n                            break;\n                        }\n                        endFilterIndex = periodIndex;\n                    }\n                    else if (!this.isSymbol(chars[periodIndex])) {\n                        foundPeriod = true;\n                        endFilterIndex = periodIndex;\n                    }\n                }\n            }\n            this.maskChars(startFilterIndex, endFilterIndex + 1, chars);\n        }\n    };\n    static processTlds = (chars, tld, currentIndex) => {\n        let tldIndex = 0;\n        while (currentIndex < chars.length && tldIndex < tld.length) {\n            const currentChar = chars[currentIndex];\n            const nextChar = currentIndex + 1 < chars.length ? chars[currentIndex + 1] : '\\u0000';\n            let currentLength;\n            if ((currentLength = this.getEmulatedDomainCharLen(nextChar, String.fromCharCode(tld[tldIndex]), currentChar)) > 0) {\n                currentIndex += currentLength;\n                tldIndex++;\n            }\n            else {\n                if (tldIndex === 0) {\n                    break;\n                }\n                let previousLength;\n                if ((previousLength = this.getEmulatedDomainCharLen(nextChar, String.fromCharCode(tld[tldIndex - 1]), currentChar)) > 0) {\n                    currentIndex += previousLength;\n                }\n                else {\n                    if (!this.isSymbol(currentChar)) {\n                        break;\n                    }\n                    currentIndex++;\n                }\n            }\n        }\n        return { currentIndex, tldIndex };\n    };\n    static isSymbol = (char) => !this.isAlpha(char) && !this.isNumerical(char);\n    static isNotLowercaseAlpha = (char) => (this.isLowercaseAlpha(char) ? char === 'v' || char === 'x' || char === 'j' || char === 'q' || char === 'z' : true);\n    static isAlpha = (char) => this.isLowercaseAlpha(char) || this.isUppercaseAlpha(char);\n    static isNumerical = (char) => char >= '0' && char <= '9';\n    static isLowercaseAlpha = (char) => char >= 'a' && char <= 'z';\n    static isUppercaseAlpha = (char) => char >= 'A' && char <= 'Z';\n    static isNumericalChars = (chars) => {\n        for (let index = 0; index < chars.length; index++) {\n            if (!this.isNumerical(chars[index]) && chars[index] !== '\\u0000') {\n                return false;\n            }\n        }\n        return true;\n    };\n    static maskChars = (offset, length, chars) => {\n        for (let index = offset; index < length; index++) {\n            chars[index] = '*';\n        }\n    };\n    static maskedCountBackwards = (chars, offset) => {\n        let count = 0;\n        for (let index = offset - 1; index >= 0 && this.isSymbol(chars[index]); index--) {\n            if (chars[index] === '*') {\n                count++;\n            }\n        }\n        return count;\n    };\n    static maskedCountForwards = (chars, offset) => {\n        let count = 0;\n        for (let index = offset + 1; index < chars.length && this.isSymbol(chars[index]); index++) {\n            if (chars[index] === '*') {\n                count++;\n            }\n        }\n        return count;\n    };\n    static maskedCharsStatus = (chars, filtered, offset, length, prefix) => {\n        const count = prefix ? this.maskedCountBackwards(filtered, offset) : this.maskedCountForwards(filtered, offset);\n        if (count >= length) {\n            return 4;\n        }\n        else if (this.isSymbol(prefix ? chars[offset - 1] : chars[offset + 1])) {\n            return 1;\n        }\n        return 0;\n    };\n    static prefixSymbolStatus = (offset, chars, length, symbolChars, symbols) => {\n        if (offset === 0) {\n            return 2;\n        }\n        for (let index = offset - 1; index >= 0 && this.isSymbol(chars[index]); index--) {\n            if (symbols.includes(chars[index])) {\n                return 3;\n            }\n        }\n        return this.maskedCharsStatus(chars, symbolChars, offset, length, true);\n    };\n    static suffixSymbolStatus = (offset, chars, length, symbolChars, symbols) => {\n        if (offset + 1 === chars.length) {\n            return 2;\n        }\n        for (let index = offset + 1; index < chars.length && this.isSymbol(chars[index]); index++) {\n            if (symbols.includes(chars[index])) {\n                return 3;\n            }\n        }\n        return this.maskedCharsStatus(chars, symbolChars, offset, length, false);\n    };\n    static format = (chars) => {\n        let pos = 0;\n        for (let index = 0; index < chars.length; index++) {\n            if (this.isCharacterAllowed(chars[index])) {\n                chars[pos] = chars[index];\n            }\n            else {\n                chars[pos] = ' ';\n            }\n            if (pos === 0 || chars[pos] !== ' ' || chars[pos - 1] !== ' ') {\n                pos++;\n            }\n        }\n        for (let index = pos; index < chars.length; index++) {\n            chars[index] = ' ';\n        }\n    };\n    static isCharacterAllowed = (char) => (char >= ' ' && char <= '\\u007f') || char === ' ' || char === '\\n' || char === '\\t' || char === '£' || char === '€';\n    static replaceUppercases = (chars, comparison) => {\n        for (let index = 0; index < comparison.length; index++) {\n            if (chars[index] !== '*' && this.isUppercaseAlpha(comparison[index])) {\n                chars[index] = comparison[index];\n            }\n        }\n    };\n    static formatUppercases = (chars) => {\n        let flagged = true;\n        for (let index = 0; index < chars.length; index++) {\n            const char = chars[index];\n            if (!this.isAlpha(char)) {\n                flagged = true;\n            }\n            else if (flagged) {\n                if (this.isLowercaseAlpha(char)) {\n                    flagged = false;\n                }\n            }\n            else if (this.isUppercaseAlpha(char)) {\n                chars[index] = String.fromCharCode(char.charCodeAt(0) + 'a'.charCodeAt(0) - 65);\n            }\n        }\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/wordenc/WordFilter.ts?");

/***/ }),

/***/ "./src/js/jagex2/wordenc/WordPack.ts":
/*!*******************************************!*\
  !*** ./src/js/jagex2/wordenc/WordPack.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WordPack)\n/* harmony export */ });\nclass WordPack {\n    // prettier-ignore\n    static TABLE = [\n        ' ',\n        'e', 't', 'a', 'o', 'i', 'h', 'n', 's', 'r', 'd', 'l', 'u', 'm',\n        'w', 'c', 'y', 'f', 'g', 'p', 'b', 'v', 'k', 'x', 'j', 'q', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        ' ', '!', '?', '.', ',', ':', ';', '(', ')', '-',\n        '&', '*', '\\\\', '\\'', '@', '#', '+', '=', '£', '$', '%', '\"', '[', ']'\n    ];\n    static charBuffer = [];\n    static unpack = (word, length) => {\n        let pos = 0;\n        let carry = -1;\n        let nibble;\n        for (let index = 0; index < length && pos < 100; index++) {\n            const value = word.g1;\n            nibble = (value >> 4) & 0xf;\n            if (carry !== -1) {\n                this.charBuffer[pos++] = this.TABLE[(carry << 4) + nibble - 195];\n                carry = -1;\n            }\n            else if (nibble < 13) {\n                this.charBuffer[pos++] = this.TABLE[nibble];\n            }\n            else {\n                carry = nibble;\n            }\n            nibble = value & 0xf;\n            if (carry !== -1) {\n                this.charBuffer[pos++] = this.TABLE[(carry << 4) + nibble - 195];\n                carry = -1;\n            }\n            else if (nibble < 13) {\n                this.charBuffer[pos++] = this.TABLE[nibble];\n            }\n            else {\n                carry = nibble;\n            }\n        }\n        let uppercase = true;\n        for (let index = 0; index < pos; index++) {\n            const char = this.charBuffer[index];\n            if (uppercase && char >= 'a' && char <= 'z') {\n                this.charBuffer[index] = char.toUpperCase();\n                uppercase = false;\n            }\n            if (char === '.' || char === '!') {\n                uppercase = true;\n            }\n        }\n        return this.charBuffer.slice(0, pos).join('');\n    };\n    static pack = (word, str) => {\n        if (str.length > 80) {\n            str = str.substring(0, 80);\n        }\n        str = str.toLowerCase();\n        let carry = -1;\n        for (let index = 0; index < str.length; index++) {\n            const char = str.charAt(index);\n            let currentChar = 0;\n            for (let lookupIndex = 0; lookupIndex < this.TABLE.length; lookupIndex++) {\n                if (char === this.TABLE[lookupIndex]) {\n                    currentChar = lookupIndex;\n                    break;\n                }\n            }\n            if (currentChar > 12) {\n                currentChar += 195;\n            }\n            if (carry === -1) {\n                if (currentChar < 13) {\n                    carry = currentChar;\n                }\n                else {\n                    word.p1(currentChar);\n                }\n            }\n            else if (currentChar < 13) {\n                word.p1((carry << 4) + currentChar);\n                carry = -1;\n            }\n            else {\n                word.p1((carry << 4) + (currentChar >> 4));\n                carry = currentChar & 0xf;\n            }\n        }\n        if (carry !== -1) {\n            word.p1(carry << 4);\n        }\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/wordenc/WordPack.ts?");

/***/ }),

/***/ "./src/js/vendor/bzip.ts":
/*!*******************************!*\
  !*** ./src/js/vendor/bzip.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Bzip)\n/* harmony export */ });\n/* harmony import */ var _bz2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bz2.js */ \"./src/js/vendor/bz2.js\");\n\nclass Bzip {\n    static bz2 = null;\n    static load = async (bytes) => {\n        this.bz2 = await (0,_bz2_js__WEBPACK_IMPORTED_MODULE_0__.instantiate)(new WebAssembly.Module(bytes), { env: undefined });\n    };\n    static read = (length, stream, avail_in, next_in) => {\n        if (!this.bz2) {\n            throw new Error('bz2 not found!!');\n        }\n        return Int8Array.from(this.bz2.read(length, stream, avail_in, next_in));\n    };\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/vendor/bzip.ts?");

/***/ }),

/***/ "./src/js/jagex2/util/AudioUtil.js":
/*!*****************************************!*\
  !*** ./src/js/jagex2/util/AudioUtil.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   playMidi: () => (/* binding */ playMidi),\n/* harmony export */   playWave: () => (/* binding */ playWave),\n/* harmony export */   setMidiVolume: () => (/* binding */ setMidiVolume),\n/* harmony export */   setWaveVolume: () => (/* binding */ setWaveVolume),\n/* harmony export */   stopMidi: () => (/* binding */ stopMidi)\n/* harmony export */ });\nlet waveGain;\n\nasync function playWave(data, vol) {\n    setWaveVolume(vol);\n\n    try {\n        const audioBuffer = await window.audioContext.decodeAudioData(Uint8Array.from(data).buffer);\n        let bufferSource = window.audioContext.createBufferSource();\n        bufferSource.buffer = audioBuffer;\n        bufferSource.connect(waveGain);\n        bufferSource.start();\n    } catch (err) {\n        console.log(err);\n    }\n}\n\nfunction setWaveVolume(vol) {\n    if (!waveGain) {\n        waveGain = window.audioContext.createGain();\n        waveGain.connect(window.audioContext.destination);\n    }\n\n    waveGain.gain.value = vol / 256;\n}\n\nfunction playMidi(data, vol) {\n    if (window._tinyMidiPlay) {\n        window._tinyMidiPlay(data, vol / 256);\n    }\n}\n\nfunction setMidiVolume(vol) {\n    if (window._tinyMidiVolume) {\n        window._tinyMidiVolume(vol / 256);\n    }\n}\n\nfunction stopMidi() {\n    if (window._tinyMidiStop) {\n        window._tinyMidiStop();\n    }\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/jagex2/util/AudioUtil.js?");

/***/ }),

/***/ "./src/js/vendor/bz2.js":
/*!******************************!*\
  !*** ./src/js/vendor/bz2.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   instantiate: () => (/* binding */ instantiate)\n/* harmony export */ });\nasync function instantiate(module, imports = {}) {\n  const adaptedImports = {\n    env: Object.assign(Object.create(globalThis), imports.env || {}, {\n      abort(message, fileName, lineNumber, columnNumber) {\n        // ~lib/builtins/abort(~lib/string/String | null?, ~lib/string/String | null?, u32?, u32?) => void\n        message = __liftString(message >>> 0);\n        fileName = __liftString(fileName >>> 0);\n        lineNumber = lineNumber >>> 0;\n        columnNumber = columnNumber >>> 0;\n        (() => {\n          // @external.js\n          throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\n        })();\n      },\n    }),\n  };\n  const { exports } = await WebAssembly.instantiate(module, adaptedImports);\n  const memory = exports.memory || imports.env.memory;\n  const adaptedExports = Object.setPrototypeOf({\n    read(length, stream, avail_in, next_in) {\n      // assembly/bz2/read(i32, ~lib/staticarray/StaticArray<i8>, i32, i32) => ~lib/staticarray/StaticArray<i8>\n      stream = __lowerStaticArray(__setU8, 6, 0, stream, Int8Array) || __notnull();\n      return __liftStaticArray(__getI8, 0, exports.read(length, stream, avail_in, next_in) >>> 0);\n    },\n  }, exports);\n  function __liftString(pointer) {\n    if (!pointer) return null;\n    const\n      end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1,\n      memoryU16 = new Uint16Array(memory.buffer);\n    let\n      start = pointer >>> 1,\n      string = \"\";\n    while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));\n    return string + String.fromCharCode(...memoryU16.subarray(start, end));\n  }\n  function __liftStaticArray(liftElement, align, pointer) {\n    if (!pointer) return null;\n    const\n      length = __getU32(pointer - 4) >>> align,\n      values = new Array(length);\n    for (let i = 0; i < length; ++i) values[i] = liftElement(pointer + (i << align >>> 0));\n    return values;\n  }\n  function __lowerStaticArray(lowerElement, id, align, values, typedConstructor) {\n    if (values == null) return 0;\n    const\n      length = values.length,\n      buffer = exports.__pin(exports.__new(length << align, id)) >>> 0;\n    if (typedConstructor) {\n      new typedConstructor(memory.buffer, buffer, length).set(values);\n    } else {\n      for (let i = 0; i < length; i++) lowerElement(buffer + (i << align >>> 0), values[i]);\n    }\n    exports.__unpin(buffer);\n    return buffer;\n  }\n  function __notnull() {\n    throw TypeError(\"value must not be null\");\n  }\n  let __dataview = new DataView(memory.buffer);\n  function __setU8(pointer, value) {\n    try {\n      __dataview.setUint8(pointer, value, true);\n    } catch {\n      __dataview = new DataView(memory.buffer);\n      __dataview.setUint8(pointer, value, true);\n    }\n  }\n  function __getI8(pointer) {\n    try {\n      return __dataview.getInt8(pointer, true);\n    } catch {\n      __dataview = new DataView(memory.buffer);\n      return __dataview.getInt8(pointer, true);\n    }\n  }\n  function __getU32(pointer) {\n    try {\n      return __dataview.getUint32(pointer, true);\n    } catch {\n      __dataview = new DataView(memory.buffer);\n      return __dataview.getUint32(pointer, true);\n    }\n  }\n  return adaptedExports;\n}\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/vendor/bz2.js?");

/***/ }),

/***/ "./src/js/vendor/midi.js":
/*!*******************************!*\
  !*** ./src/js/vendor/midi.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tinymidipcm_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tinymidipcm/index.js */ \"./src/js/vendor/tinymidipcm/index.js\");\n\n\n// Fix iOS Audio Context by Blake Kus https://gist.github.com/kus/3f01d60569eeadefe3a1\n// MIT license\n(function () {\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (window.AudioContext) {\n        window.audioContext = new window.AudioContext();\n    }\n    var fixAudioContext = function (e) {\n        if (window.audioContext) {\n            // Create empty buffer\n            var buffer = window.audioContext.createBuffer(1, 1, 22050);\n            var source = window.audioContext.createBufferSource();\n            source.buffer = buffer;\n            // Connect to output (speakers)\n            source.connect(window.audioContext.destination);\n            // Play sound\n            if (source.start) {\n                source.start(0);\n            } else if (source.play) {\n                source.play(0);\n            } else if (source.noteOn) {\n                source.noteOn(0);\n            }\n        }\n        // Remove events\n        document.removeEventListener('touchstart', fixAudioContext);\n        document.removeEventListener('touchend', fixAudioContext);\n        document.removeEventListener('click', fixAudioContext);\n    };\n    // iOS 6-8\n    document.addEventListener('touchstart', fixAudioContext);\n    // iOS 9\n    document.addEventListener('touchend', fixAudioContext);\n    // Safari\n    document.addEventListener('click', fixAudioContext);\n})();\n\n// controlling tinymidipcm:\n(async () => {\n    const channels = 2;\n    const sampleRate = 44100;\n    const flushTime = 250;\n    const renderInterval = 30;\n\n    // let renderEndSeconds = 0;\n    // let currentMidiBuffer = null;\n    let samples = new Float32Array();\n\n    let gainNode = window.audioContext.createGain();\n    gainNode.gain.value = 0.1;\n    gainNode.connect(window.audioContext.destination);\n\n    // let startTime = 0;\n    let lastTime = window.audioContext.currentTime;\n    let bufferSources = [];\n\n    const tinyMidiPCM = new _tinymidipcm_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        renderInterval,\n        onPCMData: pcm => {\n            let float32 = new Float32Array(pcm.buffer);\n            let temp = new Float32Array(samples.length + float32.length);\n            temp.set(samples, 0);\n            temp.set(float32, samples.length);\n            samples = temp;\n        },\n        onRenderEnd: ms => {\n            // renderEndSeconds = Math.floor(startTime + Math.floor(ms / 1000));\n        },\n        bufferSize: 1024 * 100\n    });\n\n    await tinyMidiPCM.init();\n\n    const soundfontRes = await fetch('./SCC1_Florestan.sf2');\n    const soundfontBuffer = new Uint8Array(await soundfontRes.arrayBuffer());\n    tinyMidiPCM.setSoundfont(soundfontBuffer);\n\n    function flush() {\n        if (!window.audioContext || !samples.length) {\n            return;\n        }\n\n        let bufferSource = window.audioContext.createBufferSource();\n        // bufferSource.onended = function(event) {\n        //     const timeSeconds = Math.floor(window.audioContext.currentTime);\n\n        //     if (renderEndSeconds > 0 && Math.abs(timeSeconds - renderEndSeconds) <= 2) {\n        //         renderEndSeconds = 0;\n\n        //         if (currentMidiBuffer) {\n        //             // midi looping\n        //             // note: this was buggy with some midi files\n        //             window._tinyMidiPlay(currentMidiBuffer, -1);\n        //         }\n        //     }\n        // }\n\n        const length = samples.length / channels;\n        const audioBuffer = window.audioContext.createBuffer(channels, length, sampleRate);\n\n        for (let channel = 0; channel < channels; channel++) {\n            const audioData = audioBuffer.getChannelData(channel);\n\n            let offset = channel;\n            for (let i = 0; i < length; i++) {\n                audioData[i] = samples[offset];\n                offset += channels;\n            }\n        }\n\n        if (lastTime < window.audioContext.currentTime) {\n            lastTime = window.audioContext.currentTime;\n        }\n\n        bufferSource.buffer = audioBuffer;\n        bufferSource.connect(gainNode);\n        bufferSource.start(lastTime);\n        bufferSources.push(bufferSource);\n\n        lastTime += audioBuffer.duration;\n        samples = new Float32Array();\n    }\n\n    let flushInterval;\n\n    window._tinyMidiStop = async () => {\n        if (flushInterval) {\n            clearInterval(flushInterval);\n        }\n\n        // currentMidiBuffer = null;\n        samples = new Float32Array();\n\n        if (bufferSources.length) {\n            let temp = gainNode.gain.value;\n            gainNode.gain.value = 0;\n            bufferSources.forEach(bufferSource => {\n                bufferSource.stop(window.audioContext.currentTime);\n            });\n            bufferSources = [];\n            gainNode.gain.value = temp;\n        }\n    };\n\n    window._tinyMidiVolume = (vol = 1) => {\n        gainNode.gain.value = vol;\n    };\n\n    window._tinyMidiPlay = async (midiBuffer, vol = 1) => {\n        if (!midiBuffer) {\n            return;\n        }\n\n        await window._tinyMidiStop();\n\n        // vol -1 = reuse last volume level\n        if (vol != -1) {\n            window._tinyMidiVolume(vol);\n        }\n\n        // currentMidiBuffer = midiBuffer;\n        // startTime = window.audioContext.currentTime;\n        lastTime = window.audioContext.currentTime;\n        flushInterval = setInterval(flush, flushTime);\n        tinyMidiPCM.render(midiBuffer);\n    };\n})();\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/vendor/midi.js?");

/***/ }),

/***/ "./src/js/vendor/tinymidipcm/index.js":
/*!********************************************!*\
  !*** ./src/js/vendor/tinymidipcm/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _tinymidipcm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tinymidipcm.mjs */ \"./src/js/vendor/tinymidipcm/tinymidipcm.mjs\");\n\n\nclass TinyMidiPCM {\n    constructor(options = {}) {\n        this.wasmModule = undefined;\n\n        this.soundfontBufferPtr = 0;\n        this.soundfontPtr = 0;\n\n        this.midiBufferPtr = 0;\n\n        this.renderInterval = options.renderInterval || 100;\n\n        this.sampleRate = options.sampleRate || 44100;\n        this.channels = options.channels || 2;\n        this.gain = options.gain || 0;\n\n        if (!options.bufferSize) {\n            this.setBufferDuration(1);\n        } else {\n            this.bufferSize = options.bufferSize;\n        }\n\n        this.onPCMData = options.onPCMData || (() => {});\n        this.onRenderEnd = options.onRenderEnd || (() => {});\n\n        this.renderTimer = undefined;\n\n        this.test = 0;\n    }\n\n    async init() {\n        if (this.wasmModule) {\n            return;\n        }\n\n        // check if node\n        // http://philiplassen.com/2021/08/11/node-es6-emscripten.html\n        if (typeof process !== 'undefined') {\n            const {dirname} = await import(/* webpackIgnore: true */ 'path');\n            const {createRequire} = await import(/* webpackIgnore: true */ 'module');\n\n            globalThis.__dirname = dirname(\"file:///home/runner/work/Client2/Client2/src/js/vendor/tinymidipcm/index.js\");\n            globalThis.require = createRequire(\"file:///home/runner/work/Client2/Client2/src/js/vendor/tinymidipcm/index.js\");\n        }\n\n        this.wasmModule = await (0,_tinymidipcm_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n        this.pcmBufferPtr = this.wasmModule._malloc(this.bufferSize);\n        this.msecsPtr = this.wasmModule._malloc(8);\n    }\n\n    // set buffer size based on seconds\n    setBufferDuration(seconds) {\n        this.bufferSize = 4 * this.sampleRate * this.channels * seconds;\n    }\n\n    ensureInitialized() {\n        if (!this.wasmModule) {\n            throw new Error(`${this.constructor.name} not initalized. call .init()`);\n        }\n    }\n\n    setSoundfont(buffer) {\n        this.ensureInitialized();\n\n        const {_malloc, _free, _tsf_load_memory, _tsf_set_output, _tsf_channel_set_bank_preset, _tsf_set_max_voices, _tsf_channel_set_presetnumber} = this.wasmModule;\n\n        _free(this.soundfontBufferPtr);\n\n        this.soundfontBufferPtr = _malloc(buffer.length);\n        this.wasmModule.HEAPU8.set(buffer, this.soundfontBufferPtr);\n\n        //_tsf_channel_set_bank_preset(this.soundfontPtr, 9, 128, 0);\n\n        this.soundfontPtr = _tsf_load_memory(this.soundfontBufferPtr, buffer.length);\n\n        //_tsf_set_max_voices(this.soundfontPtr, 10);\n\n        _tsf_set_output(this.soundfontPtr, this.channels === 2 ? 0 : 2, this.sampleRate, this.gain);\n    }\n\n    getPCMBuffer() {\n        this.ensureInitialized();\n\n        const pcm = new Uint8Array(this.bufferSize);\n\n        pcm.set(this.wasmModule.HEAPU8.subarray(this.pcmBufferPtr, this.pcmBufferPtr + this.bufferSize));\n\n        return pcm;\n    }\n\n    getMIDIMessagePtr(midiBuffer) {\n        const {_malloc, _free, _tml_load_memory} = this.wasmModule;\n\n        _free(this.midiBufferPtr);\n\n        this.midiBufferPtr = _malloc(midiBuffer.length);\n        this.wasmModule.HEAPU8.set(midiBuffer, this.midiBufferPtr);\n\n        return _tml_load_memory(this.midiBufferPtr, midiBuffer.length);\n    }\n\n    renderMIDIMessage(midiMessagePtr) {\n        const {_midi_render} = this.wasmModule;\n\n        return _midi_render(this.soundfontPtr, midiMessagePtr, this.channels, this.sampleRate, this.pcmBufferPtr, this.bufferSize, this.msecsPtr);\n    }\n\n    render(midiBuffer) {\n        this.ensureInitialized();\n\n        if (!this.soundfontPtr) {\n            throw new Error('no soundfont buffer set. call .setSoundfont');\n        }\n\n        window.clearTimeout(this.renderTimer);\n\n        const {setValue, getValue} = this.wasmModule;\n\n        setValue(this.msecsPtr, 0, 'double');\n\n        this.wasmModule._tsf_reset(this.soundfontPtr);\n        this.wasmModule._tsf_channel_set_bank_preset(this.soundfontPtr, 9, 128, 0);\n\n        if (midiBuffer[0] === 'R'.charCodeAt(0)) {\n            // there is a RIFF header before the midi, quick hack\n            midiBuffer = midiBuffer.slice(0x14);\n        }\n        let midiMessagePtr = this.getMIDIMessagePtr(midiBuffer);\n\n        const bindReducer = () => {\n            midiMessagePtr = this.renderMIDIMessage(midiMessagePtr);\n\n            const pcm = this.getPCMBuffer();\n\n            this.onPCMData(pcm);\n\n            if (midiMessagePtr) {\n                this.renderTimer = setTimeout(bindReducer, this.renderInterval);\n            } else {\n                this.onRenderEnd(getValue(this.msecsPtr, 'double'));\n            }\n        };\n\n        this.renderTimer = setTimeout(bindReducer, 16);\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TinyMidiPCM);\n\n\n//# sourceURL=webpack://2004scape-client/./src/js/vendor/tinymidipcm/index.js?");

/***/ }),

/***/ "./src/js/vendor/tinymidipcm/tinymidipcm.wasm":
/*!****************************************************!*\
  !*** ./src/js/vendor/tinymidipcm/tinymidipcm.wasm ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"9f86b5397894e28b5ae2.wasm\";\n\n//# sourceURL=webpack://2004scape-client/./src/js/vendor/tinymidipcm/tinymidipcm.wasm?");

/***/ }),

/***/ "./src/js/vendor/tinymidipcm/tinymidipcm.mjs":
/*!***************************************************!*\
  !*** ./src/js/vendor/tinymidipcm/tinymidipcm.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nvar loadTinyMidiPCM = (() => {\n  var _scriptDir = \"file:///home/runner/work/Client2/Client2/src/js/vendor/tinymidipcm/tinymidipcm.mjs\";\n  \n  return (\nfunction(loadTinyMidiPCM) {\n  loadTinyMidiPCM = loadTinyMidiPCM || {};\n\n\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof loadTinyMidiPCM != 'undefined' ? loadTinyMidiPCM : {};\n\n// See https://caniuse.com/mdn-javascript_builtins_object_assign\n\n// See https://caniuse.com/mdn-javascript_builtins_bigint64array\n\n// Set up the promise that indicates the Module is initialized\nvar readyPromiseResolve, readyPromiseReject;\nModule['ready'] = new Promise(function(resolve, reject) {\n  readyPromiseResolve = resolve;\n  readyPromiseReject = reject;\n});\n[\"_tsf_load_memory\",\"_tsf_set_output\",\"_tsf_channel_set_bank_preset\",\"_tsf_set_max_voices\",\"_tsf_channel_set_presetnumber\",\"_tsf_reset\",\"_tsf_close\",\"_tml_load_memory\",\"_midi_render\",\"_malloc\",\"_realloc\",\"_free\",\"_fflush\",\"onRuntimeInitialized\"].forEach((prop) => {\n  if (!Object.getOwnPropertyDescriptor(Module['ready'], prop)) {\n    Object.defineProperty(Module['ready'], prop, {\n      get: () => abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n      set: () => abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\n    });\n  }\n});\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = Object.assign({}, Module);\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n}\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar read_,\n    readAsync,\n    readBinary,\n    setWindowTitle;\n\n// Normally we don't log exceptions but instead let them bubble out the top\n// level where the embedding environment (e.g. the browser) can handle\n// them.\n// However under v8 and node we sometimes exit the process direcly in which case\n// its up to use us to log the exception before exiting.\n// If we fix https://github.com/emscripten-core/emscripten/issues/15080\n// this may no longer be needed under node.\nfunction logExceptionOnExit(e) {\n  if (e instanceof ExitStatus) return;\n  let toLog = e;\n  if (e && typeof e == 'object' && e.stack) {\n    toLog = [e, e.stack];\n  }\n  err('exiting due to exception: ' + toLog);\n}\n\nif (ENVIRONMENT_IS_NODE) {\n  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = require('path').dirname(scriptDirectory) + '/';\n  } else {\n    scriptDirectory = __dirname + '/';\n  }\n\n// include: node_shell_read.js\n\n\nvar fs;\nvar nodePath;\n\nvar requireNodeFS = () => {\n  // Use nodePath as the indicator for these not being initialized,\n  // since in some environments a global fs may have already been\n  // created.\n  if (!nodePath) {\n    fs = require('fs');\n    nodePath = require('path');\n  }\n};\n\nread_ = (filename, binary) => {\n  requireNodeFS();\n  filename = nodePath['normalize'](filename);\n  return fs.readFileSync(filename, binary ? undefined : 'utf8');\n};\n\nreadBinary = (filename) => {\n  var ret = read_(filename, true);\n  if (!ret.buffer) {\n    ret = new Uint8Array(ret);\n  }\n  assert(ret.buffer);\n  return ret;\n};\n\nreadAsync = (filename, onload, onerror) => {\n  requireNodeFS();\n  filename = nodePath['normalize'](filename);\n  fs.readFile(filename, function(err, data) {\n    if (err) onerror(err);\n    else onload(data.buffer);\n  });\n};\n\n// end include: node_shell_read.js\n  if (process['argv'].length > 1) {\n    thisProgram = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  arguments_ = process['argv'].slice(2);\n\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n\n  // Without this older versions of node (< v15) will log unhandled rejections\n  // but return 0, which is not normally the desired behaviour.  This is\n  // not be needed with node v15 and about because it is now the default\n  // behaviour:\n  // See https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode\n  process['on']('unhandledRejection', function(reason) { throw reason; });\n\n  quit_ = (status, toThrow) => {\n    if (keepRuntimeAlive()) {\n      process['exitCode'] = status;\n      throw toThrow;\n    }\n    logExceptionOnExit(toThrow);\n    process['exit'](status);\n  };\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n\n} else\nif (ENVIRONMENT_IS_SHELL) {\n\n  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  if (typeof read != 'undefined') {\n    read_ = function shell_read(f) {\n      return read(f);\n    };\n  }\n\n  readBinary = function readBinary(f) {\n    let data;\n    if (typeof readbuffer == 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n    data = read(f, 'binary');\n    assert(typeof data == 'object');\n    return data;\n  };\n\n  readAsync = function readAsync(f, onload, onerror) {\n    setTimeout(() => onload(readBinary(f)), 0);\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    arguments_ = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    arguments_ = arguments;\n  }\n\n  if (typeof quit == 'function') {\n    quit_ = (status, toThrow) => {\n      logExceptionOnExit(toThrow);\n      quit(status);\n    };\n  }\n\n  if (typeof print != 'undefined') {\n    // Prefer to use print/printErr where they exist, as they usually work better.\n    if (typeof console == 'undefined') console = /** @type{!Console} */({});\n    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);\n    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);\n  }\n\n} else\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptDir) {\n    scriptDirectory = _scriptDir;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n  // they are removed because they could contain a slash.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  // Differentiate the Web Worker from the Node Worker case, as reading must\n  // be done differently.\n  {\n// include: web_or_worker_shell_read.js\n\n\n  read_ = (url) => {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  }\n\n  if (ENVIRONMENT_IS_WORKER) {\n    readBinary = (url) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\n    };\n  }\n\n  readAsync = (url, onload, onerror) => {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = () => {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  }\n\n// end include: web_or_worker_shell_read.js\n  }\n\n  setWindowTitle = (title) => document.title = title;\n} else\n{\n  throw new Error('environment detection error');\n}\n\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console);\n\n// Merge back in the overrides\nObject.assign(Module, moduleOverrides);\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = null;\ncheckIncomingModuleAPI();\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\n\nif (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');\n\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\n\nif (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\nlegacyModuleProp('read', 'read_');\nlegacyModuleProp('readAsync', 'readAsync');\nlegacyModuleProp('readBinary', 'readBinary');\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\");\n\n\n\n\nvar STACK_ALIGN = 16;\nvar POINTER_SIZE = 4;\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': case 'u8': return 1;\n    case 'i16': case 'u16': return 2;\n    case 'i32': case 'u32': return 4;\n    case 'i64': case 'u64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length - 1] === '*') {\n        return POINTER_SIZE;\n      }\n      if (type[0] === 'i') {\n        const bits = Number(type.substr(1));\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n        return bits / 8;\n      }\n      return 0;\n    }\n  }\n}\n\n// include: runtime_debug.js\n\n\nfunction legacyModuleProp(prop, newName) {\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n    Object.defineProperty(Module, prop, {\n      configurable: true,\n      get: function() {\n        abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');\n      }\n    });\n  }\n}\n\nfunction ignoredModuleProp(prop) {\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\n    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');\n  }\n}\n\n// forcing the filesystem exports a few things by default\nfunction isExportedByForceFilesystem(name) {\n  return name === 'FS_createPath' ||\n         name === 'FS_createDataFile' ||\n         name === 'FS_createPreloadedFile' ||\n         name === 'FS_unlink' ||\n         name === 'addRunDependency' ||\n         // The old FS has some functionality that WasmFS lacks.\n         name === 'FS_createLazyFile' ||\n         name === 'FS_createDevice' ||\n         name === 'removeRunDependency';\n}\n\nfunction missingLibrarySymbol(sym) {\n  if (typeof globalThis !== 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get: function() {\n        // Can't `abort()` here because it would break code that does runtime\n        // checks.  e.g. `if (typeof SDL === 'undefined')`.\n        var msg = '`' + sym + '` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line';\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        warnOnce(msg);\n        return undefined;\n      }\n    });\n  }\n}\n\nfunction unexportedRuntimeSymbol(sym) {\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n    Object.defineProperty(Module, sym, {\n      configurable: true,\n      get: function() {\n        var msg = \"'\" + sym + \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\";\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        abort(msg);\n      }\n    });\n  }\n}\n\n// end include: runtime_debug.js\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary;\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\nvar noExitRuntime = Module['noExitRuntime'] || true;legacyModuleProp('noExitRuntime', 'noExitRuntime');\n\nif (typeof WebAssembly != 'object') {\n  abort('no native wasm support detected');\n}\n\n// Wasm globals\n\nvar wasmMemory;\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed' + (text ? ': ' + text : ''));\n  }\n}\n\n// We used to include malloc/free by default in the past. Show a helpful error in\n// builds with assertions.\n\n// include: runtime_strings.js\n\n\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n\nvar UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n/**\n * heapOrArray is either a regular array, or a JavaScript typed array view.\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n  }\n  var str = '';\n  // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n  while (idx < endPtr) {\n    // For UTF8 byte structure, see:\n    // http://en.wikipedia.org/wiki/UTF-8#Description\n    // https://www.ietf.org/rfc/rfc2279.txt\n    // https://tools.ietf.org/html/rfc3629\n    var u0 = heapOrArray[idx++];\n    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n    var u1 = heapOrArray[idx++] & 63;\n    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n    var u2 = heapOrArray[idx++] & 63;\n    if ((u0 & 0xF0) == 0xE0) {\n      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n    }\n\n    if (u0 < 0x10000) {\n      str += String.fromCharCode(u0);\n    } else {\n      var ch = u0 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    }\n  }\n  return str;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 0xC0 | (u >> 6);\n      heap[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 0xE0 | (u >> 12);\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n      heap[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n      heap[outIdx++] = 0xF0 | (u >> 18);\n      heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n      heap[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var c = str.charCodeAt(i); // possibly a lead surrogate\n    if (c <= 0x7F) {\n      len++;\n    } else if (c <= 0x7FF) {\n      len += 2;\n    } else if (c >= 0xD800 && c <= 0xDFFF) {\n      len += 4; ++i;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\n// end include: runtime_strings.js\n// Memory management\n\nvar HEAP,\n/** @type {!ArrayBuffer} */\n  buffer,\n/** @type {!Int8Array} */\n  HEAP8,\n/** @type {!Uint8Array} */\n  HEAPU8,\n/** @type {!Int16Array} */\n  HEAP16,\n/** @type {!Uint16Array} */\n  HEAPU16,\n/** @type {!Int32Array} */\n  HEAP32,\n/** @type {!Uint32Array} */\n  HEAPU32,\n/** @type {!Float32Array} */\n  HEAPF32,\n/** @type {!Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\nvar TOTAL_STACK = 5242880;\nif (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')\n\nvar INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');\n\nassert(INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\n       'JS engine does not provide full typed array support');\n\n// If memory is defined in wasm, the user can't provide it.\nassert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\nassert(INITIAL_MEMORY == 16777216, 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\n\n// include: runtime_init_table.js\n// In regular non-RELOCATABLE mode the table is exported\n// from the wasm module and this will be assigned once\n// the exports are available.\nvar wasmTable;\n\n// end include: runtime_init_table.js\n// include: runtime_stack_check.js\n\n\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  var max = _emscripten_stack_get_end();\n  assert((max & 3) == 0);\n  // The stack grow downwards towards _emscripten_stack_get_end.\n  // We write cookies to the final two words in the stack and detect if they are\n  // ever overwritten.\n  HEAPU32[((max)>>2)] = 0x2135467;\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  HEAPU32[0] = 0x63736d65; /* 'emsc' */\n}\n\nfunction checkStackCookie() {\n  if (ABORT) return;\n  var max = _emscripten_stack_get_end();\n  var cookie1 = HEAPU32[((max)>>2)];\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\n  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten at 0x' + max.toString(16) + ', expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' 0x' + cookie1.toString(16));\n  }\n  // Also test the global address 0 for integrity.\n  if (HEAPU32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n}\n\n// end include: runtime_stack_check.js\n// include: runtime_assertions.js\n\n\n// Endianness check\n(function() {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n})();\n\n// end include: runtime_assertions.js\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\n\nfunction keepRuntimeAlive() {\n  return noExitRuntime;\n}\n\nfunction preRun() {\n\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n\n  checkStackCookie();\n\n  \n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction postRun() {\n  checkStackCookie();\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// include: runtime_math.js\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n\n// end include: runtime_math.js\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function() {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err('dependency: ' + dep);\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  {\n    if (Module['onAbort']) {\n      Module['onAbort'](what);\n    }\n  }\n\n  what = 'Aborted(' + what + ')';\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // defintion for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n\n  readyPromiseReject(e);\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\n// {{MEM_INITIALIZER}}\n\n// include: memoryprofiler.js\n\n\n// end include: memoryprofiler.js\n// show errors on likely calls to FS when it was not included\nvar FS = {\n  error: function() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');\n  },\n  init: function() { FS.error() },\n  createDataFile: function() { FS.error() },\n  createPreloadedFile: function() { FS.error() },\n  createLazyFile: function() { FS.error() },\n  open: function() { FS.error() },\n  mkdev: function() { FS.error() },\n  registerDevice: function() { FS.error() },\n  analyzePath: function() { FS.error() },\n  loadFilesFromDB: function() { FS.error() },\n\n  ErrnoError: function ErrnoError() { FS.error() },\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n// include: URIUtils.js\n\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  // Prefix of data URIs emitted by SINGLE_FILE and related options.\n  return filename.startsWith(dataURIPrefix);\n}\n\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\nfunction isFileURI(filename) {\n  return filename.startsWith('file://');\n}\n\n// end include: URIUtils.js\n/** @param {boolean=} fixedasm */\nfunction createExportWrapper(name, fixedasm) {\n  return function() {\n    var displayName = name;\n    var asm = fixedasm;\n    if (!fixedasm) {\n      asm = Module['asm'];\n    }\n    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');\n    if (!asm[name]) {\n      assert(asm[name], 'exported native function `' + displayName + '` not found');\n    }\n    return asm[name].apply(null, arguments);\n  };\n}\n\nvar wasmBinaryFile;\nif (Module['locateFile']) {\n  wasmBinaryFile = 'tinymidipcm.wasm';\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile);\n  }\n} else {\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\n  wasmBinaryFile = new URL(/* asset import */ __webpack_require__(/*! tinymidipcm.wasm */ \"./src/js/vendor/tinymidipcm/tinymidipcm.wasm\"), __webpack_require__.b).toString();\n}\n\nfunction getBinary(file) {\n  try {\n    if (file == wasmBinaryFile && wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n    if (readBinary) {\n      return readBinary(file);\n    }\n    throw \"both async and sync fetching of the wasm failed\";\n  }\n  catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // If we don't have the binary yet, try to to load it asynchronously.\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n  // Cordova or Electron apps are typically loaded from a file:// url.\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n    if (typeof fetch == 'function'\n      && !isFileURI(wasmBinaryFile)\n    ) {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        if (!response['ok']) {\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n        }\n        return response['arrayBuffer']();\n      }).catch(function () {\n          return getBinary(wasmBinaryFile);\n      });\n    }\n    else {\n      if (readAsync) {\n        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)\n        return new Promise(function(resolve, reject) {\n          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)\n        });\n      }\n    }\n  }\n\n  // Otherwise, getBinary should be able to get it synchronously\n  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_snapshot_preview1': asmLibraryArg,\n  };\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n\n    Module['asm'] = exports;\n\n    wasmMemory = Module['asm']['memory'];\n    assert(wasmMemory, \"memory not found in wasm exports\");\n    // This assertion doesn't hold when emscripten is run in --post-link\n    // mode.\n    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\n    //assert(wasmMemory.buffer.byteLength === 16777216);\n    updateGlobalBufferAndViews(wasmMemory.buffer);\n\n    wasmTable = Module['asm']['__indirect_function_table'];\n    assert(wasmTable, \"table not found in wasm exports\");\n\n    addOnInit(Module['asm']['__wasm_call_ctors']);\n\n    removeRunDependency('wasm-instantiate');\n\n  }\n  // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n  addRunDependency('wasm-instantiate');\n\n  // Prefer streaming instantiation if available.\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n    receiveInstance(result['instance']);\n  }\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function(binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(function (instance) {\n      return instance;\n    }).then(receiver, function(reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n\n      // Warn on some common problems.\n      if (isFileURI(wasmBinaryFile)) {\n        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');\n      }\n      abort(reason);\n    });\n  }\n\n  function instantiateAsync() {\n    if (!wasmBinary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\n        !isFileURI(wasmBinaryFile) &&\n        // Avoid instantiateStreaming() on Node.js environment for now, as while\n        // Node.js v18.1.0 implements it, it does not have a full fetch()\n        // implementation yet.\n        //\n        // Reference:\n        //   https://github.com/emscripten-core/emscripten/pull/16917\n        !ENVIRONMENT_IS_NODE &&\n        typeof fetch == 'function') {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        // Suppress closure warning here since the upstream definition for\n        // instantiateStreaming only allows Promise<Repsponse> rather than\n        // an actual Response.\n        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n        /** @suppress {checkTypes} */\n        var result = WebAssembly.instantiateStreaming(response, info);\n\n        return result.then(\n          receiveInstantiationResult,\n          function(reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            return instantiateArrayBuffer(receiveInstantiationResult);\n          });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiationResult);\n    }\n  }\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this path.\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch(e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n        // If instantiation fails, reject the module ready promise.\n        readyPromiseReject(e);\n    }\n  }\n\n  // If instantiation fails, reject the module ready promise.\n  instantiateAsync().catch(readyPromiseReject);\n  return {}; // no exports yet; we'll fill them in later\n}\n\n// Globals used by JS i64 conversions (see makeSetValue)\nvar tempDouble;\nvar tempI64;\n\n// === Body ===\n\nvar ASM_CONSTS = {\n  \n};\n\n\n\n\n\n\n  /** @constructor */\n  function ExitStatus(status) {\n      this.name = 'ExitStatus';\n      this.message = 'Program terminated with exit(' + status + ')';\n      this.status = status;\n    }\n\n  function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    }\n\n  function withStackSave(f) {\n      var stack = stackSave();\n      var ret = f();\n      stackRestore(stack);\n      return ret;\n    }\n  function demangle(func) {\n      warnOnce('warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling');\n      return func;\n    }\n\n  function demangleAll(text) {\n      var regex =\n        /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex,\n        function(x) {\n          var y = demangle(x);\n          return x === y ? x : (y + ' [' + x + ']');\n        });\n    }\n\n  \n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n  function getValue(ptr, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1': return HEAP8[((ptr)>>0)];\n        case 'i8': return HEAP8[((ptr)>>0)];\n        case 'i16': return HEAP16[((ptr)>>1)];\n        case 'i32': return HEAP32[((ptr)>>2)];\n        case 'i64': return HEAP32[((ptr)>>2)];\n        case 'float': return HEAPF32[((ptr)>>2)];\n        case 'double': return HEAPF64[((ptr)>>3)];\n        case '*': return HEAPU32[((ptr)>>2)];\n        default: abort('invalid type for getValue: ' + type);\n      }\n      return null;\n    }\n\n  function handleException(e) {\n      // Certain exception types we do not treat as errors since they are used for\n      // internal control flow.\n      // 1. ExitStatus, which is thrown by exit()\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\n      //    that wish to return to JS event loop.\n      if (e instanceof ExitStatus || e == 'unwind') {\n        return EXITSTATUS;\n      }\n      quit_(1, e);\n    }\n\n  function jsStackTrace() {\n      var error = new Error();\n      if (!error.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only\n        // populated if an Error object is thrown, so try that as a special-case.\n        try {\n          throw new Error();\n        } catch(e) {\n          error = e;\n        }\n        if (!error.stack) {\n          return '(no stack trace available)';\n        }\n      }\n      return error.stack.toString();\n    }\n\n  \n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n  function setValue(ptr, value, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1': HEAP8[((ptr)>>0)] = value; break;\n        case 'i8': HEAP8[((ptr)>>0)] = value; break;\n        case 'i16': HEAP16[((ptr)>>1)] = value; break;\n        case 'i32': HEAP32[((ptr)>>2)] = value; break;\n        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;\n        case 'float': HEAPF32[((ptr)>>2)] = value; break;\n        case 'double': HEAPF64[((ptr)>>3)] = value; break;\n        case '*': HEAPU32[((ptr)>>2)] = value; break;\n        default: abort('invalid type for setValue: ' + type);\n      }\n    }\n\n  function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n  function warnOnce(text) {\n      if (!warnOnce.shown) warnOnce.shown = {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;\n        err(text);\n      }\n    }\n\n  function writeArrayToMemory(array, buffer) {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n      HEAP8.set(array, buffer);\n    }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n\n  function getHeapMax() {\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n      // for any code that deals with heap sizes, which would require special\n      // casing all heap size related code to treat 0 specially.\n      return 2147483648;\n    }\n  \n  function emscripten_realloc_buffer(size) {\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1 /*success*/;\n      } catch(e) {\n        err('emscripten_realloc_buffer: Attempted to grow heap from ' + buffer.byteLength  + ' bytes to ' + size + ' bytes, but got error: ' + e);\n      }\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n      // anyhow)\n    }\n  function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      requestedSize = requestedSize >>> 0;\n      // With multithreaded builds, races can happen (another thread might increase the size\n      // in between), so return a failure, and let the caller retry.\n      assert(requestedSize > oldSize);\n  \n      // Memory resize rules:\n      // 1.  Always increase heap size to at least the requested size, rounded up\n      //     to next page multiple.\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n      //     geometrically: increase the heap size according to\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n      //     linearly: increase the heap size by at least\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n      // 4.  If we were unable to allocate as much memory, it may be due to\n      //     over-eager decision to excessively reserve due to (3) above.\n      //     Hence if an allocation fails, cut down on the amount of excess\n      //     growth, in an attempt to succeed to perform a smaller allocation.\n  \n      // A limit is set for how much we can grow. We should not exceed that\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + maxHeapSize + ' bytes!');\n        return false;\n      }\n  \n      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\n  \n      // Loop through potential heap size increases. If we attempt a too eager\n      // reservation that fails, cut down on the attempted size and reserve a\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\n  \n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n  \n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n  \n          return true;\n        }\n      }\n      err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');\n      return false;\n    }\n\n\nvar ASSERTIONS = true;\n\nfunction checkIncomingModuleAPI() {\n  ignoredModuleProp('fetchSettings');\n}\nvar asmLibraryArg = {\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n  \"emscripten_resize_heap\": _emscripten_resize_heap\n};\nvar asm = createWasm();\n/** @type {function(...*):?} */\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = createExportWrapper(\"__wasm_call_ctors\");\n\n/** @type {function(...*):?} */\nvar _malloc = Module[\"_malloc\"] = createExportWrapper(\"malloc\");\n\n/** @type {function(...*):?} */\nvar _free = Module[\"_free\"] = createExportWrapper(\"free\");\n\n/** @type {function(...*):?} */\nvar _tsf_load_memory = Module[\"_tsf_load_memory\"] = createExportWrapper(\"tsf_load_memory\");\n\n/** @type {function(...*):?} */\nvar _tsf_close = Module[\"_tsf_close\"] = createExportWrapper(\"tsf_close\");\n\n/** @type {function(...*):?} */\nvar _tsf_reset = Module[\"_tsf_reset\"] = createExportWrapper(\"tsf_reset\");\n\n/** @type {function(...*):?} */\nvar _tsf_set_output = Module[\"_tsf_set_output\"] = createExportWrapper(\"tsf_set_output\");\n\n/** @type {function(...*):?} */\nvar _tsf_set_max_voices = Module[\"_tsf_set_max_voices\"] = createExportWrapper(\"tsf_set_max_voices\");\n\n/** @type {function(...*):?} */\nvar _realloc = Module[\"_realloc\"] = createExportWrapper(\"realloc\");\n\n/** @type {function(...*):?} */\nvar _tsf_channel_set_presetnumber = Module[\"_tsf_channel_set_presetnumber\"] = createExportWrapper(\"tsf_channel_set_presetnumber\");\n\n/** @type {function(...*):?} */\nvar _tsf_channel_set_bank_preset = Module[\"_tsf_channel_set_bank_preset\"] = createExportWrapper(\"tsf_channel_set_bank_preset\");\n\n/** @type {function(...*):?} */\nvar _tml_load_memory = Module[\"_tml_load_memory\"] = createExportWrapper(\"tml_load_memory\");\n\n/** @type {function(...*):?} */\nvar _midi_render = Module[\"_midi_render\"] = createExportWrapper(\"midi_render\");\n\n/** @type {function(...*):?} */\nvar ___errno_location = Module[\"___errno_location\"] = createExportWrapper(\"__errno_location\");\n\n/** @type {function(...*):?} */\nvar _fflush = Module[\"_fflush\"] = createExportWrapper(\"fflush\");\n\n/** @type {function(...*):?} */\nvar _emscripten_stack_init = Module[\"_emscripten_stack_init\"] = function() {\n  return (_emscripten_stack_init = Module[\"_emscripten_stack_init\"] = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = function() {\n  return (_emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = function() {\n  return (_emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = function() {\n  return (_emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar stackSave = Module[\"stackSave\"] = createExportWrapper(\"stackSave\");\n\n/** @type {function(...*):?} */\nvar stackRestore = Module[\"stackRestore\"] = createExportWrapper(\"stackRestore\");\n\n/** @type {function(...*):?} */\nvar stackAlloc = Module[\"stackAlloc\"] = createExportWrapper(\"stackAlloc\");\n\n\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule[\"setValue\"] = setValue;\nModule[\"getValue\"] = getValue;\nvar unexportedRuntimeSymbols = [\n  'run',\n  'UTF8ArrayToString',\n  'UTF8ToString',\n  'stringToUTF8Array',\n  'stringToUTF8',\n  'lengthBytesUTF8',\n  'addOnPreRun',\n  'addOnInit',\n  'addOnPreMain',\n  'addOnExit',\n  'addOnPostRun',\n  'addRunDependency',\n  'removeRunDependency',\n  'FS_createFolder',\n  'FS_createPath',\n  'FS_createDataFile',\n  'FS_createPreloadedFile',\n  'FS_createLazyFile',\n  'FS_createLink',\n  'FS_createDevice',\n  'FS_unlink',\n  'getLEB',\n  'getFunctionTables',\n  'alignFunctionTables',\n  'registerFunctions',\n  'prettyPrint',\n  'getCompilerSetting',\n  'print',\n  'printErr',\n  'callMain',\n  'abort',\n  'keepRuntimeAlive',\n  'wasmMemory',\n  'stackAlloc',\n  'stackSave',\n  'stackRestore',\n  'getTempRet0',\n  'setTempRet0',\n  'writeStackCookie',\n  'checkStackCookie',\n  'ptrToString',\n  'zeroMemory',\n  'stringToNewUTF8',\n  'exitJS',\n  'getHeapMax',\n  'emscripten_realloc_buffer',\n  'ENV',\n  'ERRNO_CODES',\n  'ERRNO_MESSAGES',\n  'setErrNo',\n  'inetPton4',\n  'inetNtop4',\n  'inetPton6',\n  'inetNtop6',\n  'readSockaddr',\n  'writeSockaddr',\n  'DNS',\n  'getHostByName',\n  'Protocols',\n  'Sockets',\n  'getRandomDevice',\n  'warnOnce',\n  'traverseStack',\n  'UNWIND_CACHE',\n  'convertPCtoSourceLocation',\n  'readAsmConstArgsArray',\n  'readAsmConstArgs',\n  'mainThreadEM_ASM',\n  'jstoi_q',\n  'jstoi_s',\n  'getExecutableName',\n  'listenOnce',\n  'autoResumeAudioContext',\n  'dynCallLegacy',\n  'getDynCaller',\n  'dynCall',\n  'handleException',\n  'runtimeKeepalivePush',\n  'runtimeKeepalivePop',\n  'callUserCallback',\n  'maybeExit',\n  'safeSetTimeout',\n  'asmjsMangle',\n  'asyncLoad',\n  'alignMemory',\n  'mmapAlloc',\n  'writeI53ToI64',\n  'writeI53ToI64Clamped',\n  'writeI53ToI64Signaling',\n  'writeI53ToU64Clamped',\n  'writeI53ToU64Signaling',\n  'readI53FromI64',\n  'readI53FromU64',\n  'convertI32PairToI53',\n  'convertI32PairToI53Checked',\n  'convertU32PairToI53',\n  'getCFunc',\n  'ccall',\n  'cwrap',\n  'uleb128Encode',\n  'sigToWasmTypes',\n  'generateFuncType',\n  'convertJsFunctionToWasm',\n  'freeTableIndexes',\n  'functionsInTableMap',\n  'getEmptyTableSlot',\n  'updateTableMap',\n  'addFunction',\n  'removeFunction',\n  'reallyNegative',\n  'unSign',\n  'strLen',\n  'reSign',\n  'formatString',\n  'PATH',\n  'PATH_FS',\n  'intArrayFromString',\n  'intArrayToString',\n  'AsciiToString',\n  'stringToAscii',\n  'UTF16Decoder',\n  'UTF16ToString',\n  'stringToUTF16',\n  'lengthBytesUTF16',\n  'UTF32ToString',\n  'stringToUTF32',\n  'lengthBytesUTF32',\n  'allocateUTF8',\n  'allocateUTF8OnStack',\n  'writeStringToMemory',\n  'writeArrayToMemory',\n  'writeAsciiToMemory',\n  'SYSCALLS',\n  'getSocketFromFD',\n  'getSocketAddress',\n  'JSEvents',\n  'registerKeyEventCallback',\n  'specialHTMLTargets',\n  'maybeCStringToJsString',\n  'findEventTarget',\n  'findCanvasEventTarget',\n  'getBoundingClientRect',\n  'fillMouseEventData',\n  'registerMouseEventCallback',\n  'registerWheelEventCallback',\n  'registerUiEventCallback',\n  'registerFocusEventCallback',\n  'fillDeviceOrientationEventData',\n  'registerDeviceOrientationEventCallback',\n  'fillDeviceMotionEventData',\n  'registerDeviceMotionEventCallback',\n  'screenOrientation',\n  'fillOrientationChangeEventData',\n  'registerOrientationChangeEventCallback',\n  'fillFullscreenChangeEventData',\n  'registerFullscreenChangeEventCallback',\n  'JSEvents_requestFullscreen',\n  'JSEvents_resizeCanvasForFullscreen',\n  'registerRestoreOldStyle',\n  'hideEverythingExceptGivenElement',\n  'restoreHiddenElements',\n  'setLetterbox',\n  'currentFullscreenStrategy',\n  'restoreOldWindowedStyle',\n  'softFullscreenResizeWebGLRenderTarget',\n  'doRequestFullscreen',\n  'fillPointerlockChangeEventData',\n  'registerPointerlockChangeEventCallback',\n  'registerPointerlockErrorEventCallback',\n  'requestPointerLock',\n  'fillVisibilityChangeEventData',\n  'registerVisibilityChangeEventCallback',\n  'registerTouchEventCallback',\n  'fillGamepadEventData',\n  'registerGamepadEventCallback',\n  'registerBeforeUnloadEventCallback',\n  'fillBatteryEventData',\n  'battery',\n  'registerBatteryEventCallback',\n  'setCanvasElementSize',\n  'getCanvasElementSize',\n  'demangle',\n  'demangleAll',\n  'jsStackTrace',\n  'stackTrace',\n  'ExitStatus',\n  'getEnvStrings',\n  'checkWasiClock',\n  'flush_NO_FILESYSTEM',\n  'dlopenMissingError',\n  'createDyncallWrapper',\n  'setImmediateWrapped',\n  'clearImmediateWrapped',\n  'polyfillSetImmediate',\n  'uncaughtExceptionCount',\n  'exceptionLast',\n  'exceptionCaught',\n  'ExceptionInfo',\n  'exception_addRef',\n  'exception_decRef',\n  'Browser',\n  'setMainLoop',\n  'wget',\n  'FS',\n  'MEMFS',\n  'TTY',\n  'PIPEFS',\n  'SOCKFS',\n  '_setNetworkCallback',\n  'tempFixedLengthArray',\n  'miniTempWebGLFloatBuffers',\n  'heapObjectForWebGLType',\n  'heapAccessShiftForWebGLHeap',\n  'GL',\n  'emscriptenWebGLGet',\n  'computeUnpackAlignedImageSize',\n  'emscriptenWebGLGetTexPixelData',\n  'emscriptenWebGLGetUniform',\n  'webglGetUniformLocation',\n  'webglPrepareUniformLocationsBeforeFirstUse',\n  'webglGetLeftBracePos',\n  'emscriptenWebGLGetVertexAttrib',\n  'writeGLArray',\n  'AL',\n  'SDL_unicode',\n  'SDL_ttfContext',\n  'SDL_audio',\n  'SDL',\n  'SDL_gfx',\n  'GLUT',\n  'EGL',\n  'GLFW_Window',\n  'GLFW',\n  'GLEW',\n  'IDBStore',\n  'runAndAbortIfError',\n  'ALLOC_NORMAL',\n  'ALLOC_STACK',\n  'allocate',\n];\nunexportedRuntimeSymbols.forEach(unexportedRuntimeSymbol);\nvar missingLibrarySymbols = [\n  'ptrToString',\n  'zeroMemory',\n  'stringToNewUTF8',\n  'exitJS',\n  'setErrNo',\n  'inetPton4',\n  'inetNtop4',\n  'inetPton6',\n  'inetNtop6',\n  'readSockaddr',\n  'writeSockaddr',\n  'getHostByName',\n  'getRandomDevice',\n  'traverseStack',\n  'convertPCtoSourceLocation',\n  'readAsmConstArgs',\n  'mainThreadEM_ASM',\n  'jstoi_q',\n  'jstoi_s',\n  'getExecutableName',\n  'listenOnce',\n  'autoResumeAudioContext',\n  'dynCallLegacy',\n  'getDynCaller',\n  'dynCall',\n  'runtimeKeepalivePush',\n  'runtimeKeepalivePop',\n  'callUserCallback',\n  'maybeExit',\n  'safeSetTimeout',\n  'asmjsMangle',\n  'asyncLoad',\n  'alignMemory',\n  'mmapAlloc',\n  'writeI53ToI64',\n  'writeI53ToI64Clamped',\n  'writeI53ToI64Signaling',\n  'writeI53ToU64Clamped',\n  'writeI53ToU64Signaling',\n  'readI53FromI64',\n  'readI53FromU64',\n  'convertI32PairToI53',\n  'convertI32PairToI53Checked',\n  'convertU32PairToI53',\n  'getCFunc',\n  'ccall',\n  'cwrap',\n  'uleb128Encode',\n  'sigToWasmTypes',\n  'generateFuncType',\n  'convertJsFunctionToWasm',\n  'getEmptyTableSlot',\n  'updateTableMap',\n  'addFunction',\n  'removeFunction',\n  'reallyNegative',\n  'unSign',\n  'strLen',\n  'reSign',\n  'formatString',\n  'intArrayFromString',\n  'intArrayToString',\n  'AsciiToString',\n  'stringToAscii',\n  'UTF16ToString',\n  'stringToUTF16',\n  'lengthBytesUTF16',\n  'UTF32ToString',\n  'stringToUTF32',\n  'lengthBytesUTF32',\n  'allocateUTF8',\n  'allocateUTF8OnStack',\n  'writeStringToMemory',\n  'writeAsciiToMemory',\n  'getSocketFromFD',\n  'getSocketAddress',\n  'registerKeyEventCallback',\n  'maybeCStringToJsString',\n  'findEventTarget',\n  'findCanvasEventTarget',\n  'getBoundingClientRect',\n  'fillMouseEventData',\n  'registerMouseEventCallback',\n  'registerWheelEventCallback',\n  'registerUiEventCallback',\n  'registerFocusEventCallback',\n  'fillDeviceOrientationEventData',\n  'registerDeviceOrientationEventCallback',\n  'fillDeviceMotionEventData',\n  'registerDeviceMotionEventCallback',\n  'screenOrientation',\n  'fillOrientationChangeEventData',\n  'registerOrientationChangeEventCallback',\n  'fillFullscreenChangeEventData',\n  'registerFullscreenChangeEventCallback',\n  'JSEvents_requestFullscreen',\n  'JSEvents_resizeCanvasForFullscreen',\n  'registerRestoreOldStyle',\n  'hideEverythingExceptGivenElement',\n  'restoreHiddenElements',\n  'setLetterbox',\n  'softFullscreenResizeWebGLRenderTarget',\n  'doRequestFullscreen',\n  'fillPointerlockChangeEventData',\n  'registerPointerlockChangeEventCallback',\n  'registerPointerlockErrorEventCallback',\n  'requestPointerLock',\n  'fillVisibilityChangeEventData',\n  'registerVisibilityChangeEventCallback',\n  'registerTouchEventCallback',\n  'fillGamepadEventData',\n  'registerGamepadEventCallback',\n  'registerBeforeUnloadEventCallback',\n  'fillBatteryEventData',\n  'battery',\n  'registerBatteryEventCallback',\n  'setCanvasElementSize',\n  'getCanvasElementSize',\n  'getEnvStrings',\n  'checkWasiClock',\n  'flush_NO_FILESYSTEM',\n  'createDyncallWrapper',\n  'setImmediateWrapped',\n  'clearImmediateWrapped',\n  'polyfillSetImmediate',\n  'ExceptionInfo',\n  'exception_addRef',\n  'exception_decRef',\n  'setMainLoop',\n  '_setNetworkCallback',\n  'heapObjectForWebGLType',\n  'heapAccessShiftForWebGLHeap',\n  'emscriptenWebGLGet',\n  'computeUnpackAlignedImageSize',\n  'emscriptenWebGLGetTexPixelData',\n  'emscriptenWebGLGetUniform',\n  'webglGetUniformLocation',\n  'webglPrepareUniformLocationsBeforeFirstUse',\n  'webglGetLeftBracePos',\n  'emscriptenWebGLGetVertexAttrib',\n  'writeGLArray',\n  'SDL_unicode',\n  'SDL_ttfContext',\n  'SDL_audio',\n  'GLFW_Window',\n  'runAndAbortIfError',\n  'ALLOC_NORMAL',\n  'ALLOC_STACK',\n  'allocate',\n];\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\n\n\nvar calledRun;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\nfunction stackCheckInit() {\n  // This is normally called automatically during __wasm_call_ctors but need to\n  // get these values before even running any of the ctors so we call it redundantly\n  // here.\n  _emscripten_stack_init();\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\n  writeStackCookie();\n}\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n    stackCheckInit();\n\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    return;\n  }\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    readyPromiseResolve(Module);\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var oldOut = out;\n  var oldErr = err;\n  var has = false;\n  out = err = (x) => {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    _fflush(0);\n  } catch(e) {}\n  out = oldOut;\n  err = oldErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');\n  }\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\nrun();\n\n\n\n\n\n\n\n  return loadTinyMidiPCM.ready\n}\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadTinyMidiPCM);\n\n//# sourceURL=webpack://2004scape-client/./src/js/vendor/tinymidipcm/tinymidipcm.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"index": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/game.ts");
/******/ 	
/******/ })()
;